ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 1


   1              		.cpu cortex-m4
   2              		.arch armv7e-m
   3              		.fpu fpv4-sp-d16
   4              		.eabi_attribute 27, 1
   5              		.eabi_attribute 28, 1
   6              		.eabi_attribute 20, 1
   7              		.eabi_attribute 21, 1
   8              		.eabi_attribute 23, 3
   9              		.eabi_attribute 24, 1
  10              		.eabi_attribute 25, 1
  11              		.eabi_attribute 26, 1
  12              		.eabi_attribute 30, 6
  13              		.eabi_attribute 34, 1
  14              		.eabi_attribute 18, 4
  15              		.file	"mc_interface.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.section	.rodata.OFFSET_TAB_CCMRx,"a"
  20              		.align	2
  23              	OFFSET_TAB_CCMRx:
  24 0000 00000000 		.ascii	"\000\000\000\000\004\004\004<<"
  24      0404043C 
  24      3C
  25              		.section	.rodata.SHIFT_TAB_OCxx,"a"
  26              		.align	2
  29              	SHIFT_TAB_OCxx:
  30 0000 00000800 		.ascii	"\000\000\010\000\000\000\010\000\010"
  30      00000800 
  30      08
  31              		.section	.rodata.SHIFT_TAB_ICxx,"a"
  32              		.align	2
  35              	SHIFT_TAB_ICxx:
  36 0000 00000800 		.ascii	"\000\000\010\000\000\000\010\000\000"
  36      00000800 
  36      00
  37              		.section	.rodata.SHIFT_TAB_CCxP,"a"
  38              		.align	2
  41              	SHIFT_TAB_CCxP:
  42 0000 00020406 		.ascii	"\000\002\004\006\010\012\014\020\024"
  42      080A0C10 
  42      14
  43              		.section	.rodata.SHIFT_TAB_OISx,"a"
  44              		.align	2
  47              	SHIFT_TAB_OISx:
  48 0000 00010203 		.ascii	"\000\001\002\003\004\005\006\010\012"
  48      04050608 
  48      0A
  49              		.section	.rodata.CHANNEL_OFFSET_TAB,"a"
  50              		.align	2
  53              	CHANNEL_OFFSET_TAB:
  54 0000 081C3044 		.ascii	"\010\0340DXl\200"
  54      586C80
  55              		.section	.text.MCM_Modulus,"ax",%progbits
  56              		.align	1
  57              		.syntax unified
  58              		.thumb
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 2


  59              		.thumb_func
  61              	MCM_Modulus:
  62              	.LFB1088:
  63              		.file 1 "Inc/mc_math.h"
   1:Inc/mc_math.h **** 
   2:Inc/mc_math.h **** /**
   3:Inc/mc_math.h ****   ******************************************************************************
   4:Inc/mc_math.h ****   * @file    mc_math.h
   5:Inc/mc_math.h ****   * @author  Motor Control SDK Team, ST Microelectronics
   6:Inc/mc_math.h ****   * @brief   This file provides mathematics functions useful for and specific to
   7:Inc/mc_math.h ****   *          Motor Control.
   8:Inc/mc_math.h ****   *
   9:Inc/mc_math.h ****   ******************************************************************************
  10:Inc/mc_math.h ****   * @attention
  11:Inc/mc_math.h ****   *
  12:Inc/mc_math.h ****   * <h2><center>&copy; Copyright (c) 2023 STMicroelectronics.
  13:Inc/mc_math.h ****   * All rights reserved.</center></h2>
  14:Inc/mc_math.h ****   *
  15:Inc/mc_math.h ****   * This software component is licensed by ST under Ultimate Liberty license
  16:Inc/mc_math.h ****   * SLA0044, the "License"; You may not use this file except in compliance with
  17:Inc/mc_math.h ****   * the License. You may obtain a copy of the License at:
  18:Inc/mc_math.h ****   *                             www.st.com/SLA0044
  19:Inc/mc_math.h ****   *
  20:Inc/mc_math.h ****   ******************************************************************************
  21:Inc/mc_math.h ****   * @ingroup MC_Math
  22:Inc/mc_math.h ****   */
  23:Inc/mc_math.h **** /* Define to prevent recursive inclusion -------------------------------------*/
  24:Inc/mc_math.h **** #ifndef MC_MATH_H
  25:Inc/mc_math.h **** #define MC_MATH_H
  26:Inc/mc_math.h **** 
  27:Inc/mc_math.h **** /* Includes ------------------------------------------------------------------*/
  28:Inc/mc_math.h **** #include "mc_type.h"
  29:Inc/mc_math.h **** 
  30:Inc/mc_math.h **** /** @addtogroup MCSDK
  31:Inc/mc_math.h ****   * @{
  32:Inc/mc_math.h ****   */
  33:Inc/mc_math.h **** 
  34:Inc/mc_math.h **** /** @addtogroup MC_Math
  35:Inc/mc_math.h ****   * @{
  36:Inc/mc_math.h ****   */
  37:Inc/mc_math.h **** #define SQRT_2  1.4142
  38:Inc/mc_math.h **** #define SQRT_3  1.732
  39:Inc/mc_math.h **** 
  40:Inc/mc_math.h **** /**
  41:Inc/mc_math.h ****   * @brief  Macro to compute logarithm of two
  42:Inc/mc_math.h ****   */
  43:Inc/mc_math.h **** #define LOG2(x) \
  44:Inc/mc_math.h ****   (((x) == 65535 ) ? 16 : \
  45:Inc/mc_math.h ****    (((x) == (2*2*2*2*2*2*2*2*2*2*2*2*2*2*2)) ? 15 : \
  46:Inc/mc_math.h ****     (((x) == (2*2*2*2*2*2*2*2*2*2*2*2*2*2)) ? 14 : \
  47:Inc/mc_math.h ****      (((x) == (2*2*2*2*2*2*2*2*2*2*2*2*2)) ? 13 : \
  48:Inc/mc_math.h ****       (((x) == (2*2*2*2*2*2*2*2*2*2*2*2)) ? 12 : \
  49:Inc/mc_math.h ****        (((x) == (2*2*2*2*2*2*2*2*2*2*2)) ? 11 : \
  50:Inc/mc_math.h ****         (((x) == (2*2*2*2*2*2*2*2*2*2)) ? 10 : \
  51:Inc/mc_math.h ****          (((x) == (2*2*2*2*2*2*2*2*2)) ? 9 : \
  52:Inc/mc_math.h ****           (((x) == (2*2*2*2*2*2*2*2)) ? 8 : \
  53:Inc/mc_math.h ****            (((x) == (2*2*2*2*2*2*2)) ? 7 : \
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 3


  54:Inc/mc_math.h ****             (((x) == (2*2*2*2*2*2)) ? 6 : \
  55:Inc/mc_math.h ****              (((x) == (2*2*2*2*2)) ? 5 : \
  56:Inc/mc_math.h ****               (((x) == (2*2*2*2)) ? 4 : \
  57:Inc/mc_math.h ****                (((x) == (2*2*2)) ? 3 : \
  58:Inc/mc_math.h ****                 (((x) == (2*2)) ? 2 : \
  59:Inc/mc_math.h ****                  (((x) == 2) ? 1 : \
  60:Inc/mc_math.h ****                   (((x) == 1) ? 0 : -1)))))))))))))))))
  61:Inc/mc_math.h **** 
  62:Inc/mc_math.h **** /**
  63:Inc/mc_math.h ****   * @brief  Trigonometrical functions type definition
  64:Inc/mc_math.h ****   */
  65:Inc/mc_math.h **** typedef struct
  66:Inc/mc_math.h **** {
  67:Inc/mc_math.h ****   int16_t hCos;
  68:Inc/mc_math.h ****   int16_t hSin;
  69:Inc/mc_math.h **** } Trig_Components;
  70:Inc/mc_math.h **** 
  71:Inc/mc_math.h **** /**
  72:Inc/mc_math.h ****   * @brief  This function transforms stator currents Ia and qIb (which are
  73:Inc/mc_math.h ****   *         directed along axes each displaced by 120 degrees) into currents
  74:Inc/mc_math.h ****   *         Ialpha and Ibeta in a stationary qd reference frame.
  75:Inc/mc_math.h ****   *                               Ialpha = Ia
  76:Inc/mc_math.h ****   *                       Ibeta = -(2*Ib+Ia)/sqrt(3)
  77:Inc/mc_math.h ****   * @param  Curr_Input: stator current Ia and Ib in ab_t format.
  78:Inc/mc_math.h ****   * @retval Stator current Ialpha and Ibeta in alphabeta_t format.
  79:Inc/mc_math.h ****   */
  80:Inc/mc_math.h **** alphabeta_t MCM_Clarke(ab_t Input);
  81:Inc/mc_math.h **** 
  82:Inc/mc_math.h **** /**
  83:Inc/mc_math.h ****   * @brief  This function transforms stator values alpha and beta, which
  84:Inc/mc_math.h ****   *         belong to a stationary qd reference frame, to a rotor flux
  85:Inc/mc_math.h ****   *         synchronous reference frame (properly oriented), so as Iq and Id.
  86:Inc/mc_math.h ****   *                   Id= Ialpha *sin(theta)+qIbeta *cos(Theta)
  87:Inc/mc_math.h ****   *                   Iq=qIalpha *cos(Theta)-qIbeta *sin(Theta)
  88:Inc/mc_math.h ****   * @param  Curr_Input: stator values alpha and beta in alphabeta_t format.
  89:Inc/mc_math.h ****   * @param  Theta: rotating frame angular position in q1.15 format.
  90:Inc/mc_math.h ****   * @retval Stator current q and d in qd_t format.
  91:Inc/mc_math.h ****   */
  92:Inc/mc_math.h **** qd_t MCM_Park(alphabeta_t Input, int16_t Theta);
  93:Inc/mc_math.h **** 
  94:Inc/mc_math.h **** /**
  95:Inc/mc_math.h ****   * @brief  This function transforms stator voltage qVq and qVd, that belong to
  96:Inc/mc_math.h ****   *         a rotor flux synchronous rotating frame, to a stationary reference
  97:Inc/mc_math.h ****   *         frame, so as to obtain qValpha and qVbeta:
  98:Inc/mc_math.h ****   *                  Valfa= Vq*Cos(theta)+ Vd*Sin(theta)
  99:Inc/mc_math.h ****   *                  Vbeta=-Vq*Sin(theta)+ Vd*Cos(theta)
 100:Inc/mc_math.h ****   * @param  Curr_Input: stator voltage Vq and Vd in qd_t format.
 101:Inc/mc_math.h ****   * @param  Theta: rotating frame angular position in q1.15 format.
 102:Inc/mc_math.h ****   * @retval Stator values alpha and beta in alphabeta_t format.
 103:Inc/mc_math.h ****   */
 104:Inc/mc_math.h **** alphabeta_t MCM_Rev_Park(qd_t Input, int16_t Theta);
 105:Inc/mc_math.h **** 
 106:Inc/mc_math.h **** /**
 107:Inc/mc_math.h ****   * @brief  This function returns cosine and sine functions of the angle fed in input.
 108:Inc/mc_math.h ****   * @param  hAngle: angle in q1.15 format.
 109:Inc/mc_math.h ****   * @retval Trig_Components Cos(angle) and Sin(angle) in Trig_Components format.
 110:Inc/mc_math.h ****   */
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 4


 111:Inc/mc_math.h **** Trig_Components MCM_Trig_Functions(int16_t hAngle);
 112:Inc/mc_math.h **** 
 113:Inc/mc_math.h **** /**
 114:Inc/mc_math.h ****   * @brief  It calculates the square root of a non-negative s32. It returns 0 for negative s32.
 115:Inc/mc_math.h ****   * @param  Input int32_t number.
 116:Inc/mc_math.h ****   * @retval int32_t Square root of Input (0 if Input<0).
 117:Inc/mc_math.h ****   */
 118:Inc/mc_math.h **** int32_t MCM_Sqrt(int32_t wInput);
 119:Inc/mc_math.h **** 
 120:Inc/mc_math.h **** /**
 121:Inc/mc_math.h ****   * @brief  Sqrt table used by Circle Limitation function
 122:Inc/mc_math.h ****   *         used for STM32F0/STM32G0 series only
 123:Inc/mc_math.h ****   */
 124:Inc/mc_math.h **** #define SQRT_CIRCLE_LIMITATION {\
 125:Inc/mc_math.h ****      0 , 1023 , 1448 , 1773 , 2047 , 2289 , 2508 , 2709,\
 126:Inc/mc_math.h ****      2896 , 3071 , 3238 , 3396 , 3547 , 3691 , 3831 , 3965,\
 127:Inc/mc_math.h ****      4095 , 4221 , 4344 , 4463 , 4579 , 4692 , 4802 , 4910,\
 128:Inc/mc_math.h ****      5016 , 5119 , 5221 , 5320 , 5418 , 5514 , 5608 , 5701,\
 129:Inc/mc_math.h ****      5792 , 5882 , 5970 , 6057 , 6143 , 6228 , 6312 , 6394,\
 130:Inc/mc_math.h ****      6476 , 6556 , 6636 , 6714 , 6792 , 6868 , 6944 , 7019,\
 131:Inc/mc_math.h ****      7094 , 7167 , 7240 , 7312 , 7383 , 7454 , 7524 , 7593,\
 132:Inc/mc_math.h ****      7662 , 7730 , 7798 , 7865 , 7931 , 7997 , 8062 , 8127,\
 133:Inc/mc_math.h ****      8191 , 8255 , 8318 , 8381 , 8443 , 8505 , 8567 , 8628,\
 134:Inc/mc_math.h ****      8688 , 8748 , 8808 , 8867 , 8926 , 8985 , 9043 , 9101,\
 135:Inc/mc_math.h ****      9158 , 9215 , 9272 , 9328 , 9384 , 9440 , 9495 , 9550,\
 136:Inc/mc_math.h ****      9605 , 9660 , 9714 , 9768 , 9821 , 9874 , 9927 , 9980,\
 137:Inc/mc_math.h ****      10032 , 10084 , 10136 , 10188 , 10239 , 10290 , 10341 , 10392,\
 138:Inc/mc_math.h ****      10442 , 10492 , 10542 , 10592 , 10641 , 10690 , 10739 , 10788,\
 139:Inc/mc_math.h ****      10836 , 10884 , 10932 , 10980 , 11028 , 11075 , 11123 , 11170,\
 140:Inc/mc_math.h ****      11217 , 11263 , 11310 , 11356 , 11402 , 11448 , 11494 , 11539,\
 141:Inc/mc_math.h ****      11584 , 11630 , 11675 , 11719 , 11764 , 11808 , 11853 , 11897,\
 142:Inc/mc_math.h ****      11941 , 11985 , 12028 , 12072 , 12115 , 12158 , 12201 , 12244,\
 143:Inc/mc_math.h ****      12287 , 12330 , 12372 , 12414 , 12457 , 12499 , 12541 , 12582,\
 144:Inc/mc_math.h ****      12624 , 12665 , 12707 , 12748 , 12789 , 12830 , 12871 , 12911,\
 145:Inc/mc_math.h ****      12952 , 12992 , 13032 , 13073 , 13113 , 13153 , 13192 , 13232,\
 146:Inc/mc_math.h ****      13272 , 13311 , 13350 , 13390 , 13429 , 13468 , 13507 , 13545,\
 147:Inc/mc_math.h ****      13584 , 13623 , 13661 , 13699 , 13737 , 13776 , 13814 , 13851,\
 148:Inc/mc_math.h ****      13889 , 13927 , 13965 , 14002 , 14039 , 14077 , 14114 , 14151,\
 149:Inc/mc_math.h ****      14188 , 14225 , 14262 , 14298 , 14335 , 14372 , 14408 , 14444,\
 150:Inc/mc_math.h ****      14481 , 14517 , 14553 , 14589 , 14625 , 14661 , 14696 , 14732,\
 151:Inc/mc_math.h ****      14767 , 14803 , 14838 , 14874 , 14909 , 14944 , 14979 , 15014,\
 152:Inc/mc_math.h ****      15049 , 15084 , 15118 , 15153 , 15187 , 15222 , 15256 , 15291,\
 153:Inc/mc_math.h ****      15325 , 15359 , 15393 , 15427 , 15461 , 15495 , 15529 , 15562,\
 154:Inc/mc_math.h ****      15596 , 15630 , 15663 , 15697 , 15730 , 15763 , 15797 , 15830,\
 155:Inc/mc_math.h ****      15863 , 15896 , 15929 , 15962 , 15994 , 16027 , 16060 , 16092,\
 156:Inc/mc_math.h ****      16125 , 16157 , 16190 , 16222 , 16254 , 16287 , 16319 , 16351,\
 157:Inc/mc_math.h ****      16383 , 16415 , 16447 , 16479 , 16510 , 16542 , 16574 , 16605,\
 158:Inc/mc_math.h ****      16637 , 16669 , 16700 , 16731 , 16763 , 16794 , 16825 , 16856,\
 159:Inc/mc_math.h ****      16887 , 16918 , 16949 , 16980 , 17011 , 17042 , 17072 , 17103,\
 160:Inc/mc_math.h ****      17134 , 17164 , 17195 , 17225 , 17256 , 17286 , 17316 , 17347,\
 161:Inc/mc_math.h ****      17377 , 17407 , 17437 , 17467 , 17497 , 17527 , 17557 , 17587,\
 162:Inc/mc_math.h ****      17617 , 17646 , 17676 , 17706 , 17735 , 17765 , 17794 , 17824,\
 163:Inc/mc_math.h ****      17853 , 17882 , 17912 , 17941 , 17970 , 17999 , 18028 , 18057,\
 164:Inc/mc_math.h ****      18086 , 18115 , 18144 , 18173 , 18202 , 18231 , 18259 , 18288,\
 165:Inc/mc_math.h ****      18317 , 18345 , 18374 , 18402 , 18431 , 18459 , 18488 , 18516,\
 166:Inc/mc_math.h ****      18544 , 18573 , 18601 , 18629 , 18657 , 18685 , 18713 , 18741,\
 167:Inc/mc_math.h ****      18769 , 18797 , 18825 , 18853 , 18881 , 18908 , 18936 , 18964,\
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 5


 168:Inc/mc_math.h ****      18991 , 19019 , 19046 , 19074 , 19101 , 19129 , 19156 , 19184,\
 169:Inc/mc_math.h ****      19211 , 19238 , 19265 , 19293 , 19320 , 19347 , 19374 , 19401,\
 170:Inc/mc_math.h ****      19428 , 19455 , 19482 , 19509 , 19536 , 19562 , 19589 , 19616,\
 171:Inc/mc_math.h ****      19643 , 19669 , 19696 , 19723 , 19749 , 19776 , 19802 , 19829,\
 172:Inc/mc_math.h ****      19855 , 19881 , 19908 , 19934 , 19960 , 19987 , 20013 , 20039,\
 173:Inc/mc_math.h ****      20065 , 20091 , 20117 , 20143 , 20169 , 20235 , 20231 , 20247,\
 174:Inc/mc_math.h ****      20273 , 20299 , 20325 , 20350 , 20376 , 20402 , 20428 , 20453,\
 175:Inc/mc_math.h ****      20479 , 20504 , 20530 , 20556 , 20581 , 20606 , 20632 , 20657,\
 176:Inc/mc_math.h ****      20683 , 20708 , 20733 , 20759 , 20784 , 20809 , 20834 , 20859,\
 177:Inc/mc_math.h ****      20884 , 20910 , 20935 , 20960 , 20985 , 21010 , 21035 , 21059,\
 178:Inc/mc_math.h ****      21084 , 21109 , 21134 , 21159 , 21184 , 21208 , 21233 , 21258,\
 179:Inc/mc_math.h ****      21282 , 21307 , 21331 , 21356 , 21381 , 21405 , 21430 , 21454,\
 180:Inc/mc_math.h ****      21478 , 21503 , 21527 , 21552 , 21576 , 21600 , 21624 , 21649,\
 181:Inc/mc_math.h ****      21673 , 21697 , 21721 , 21745 , 21769 , 21793 , 21817 , 21841,\
 182:Inc/mc_math.h ****      21865 , 21889 , 21913 , 21937 , 21961 , 21985 , 22009 , 22033,\
 183:Inc/mc_math.h ****      22056 , 22080 , 22104 , 22128 , 22151 , 22175 , 22199 , 22222,\
 184:Inc/mc_math.h ****      22246 , 22269 , 22293 , 22316 , 22340 , 22363 , 22387 , 22410,\
 185:Inc/mc_math.h ****      22434 , 22457 , 22480 , 22504 , 22527 , 22550 , 22573 , 22597,\
 186:Inc/mc_math.h ****      22620 , 22643 , 22666 , 22689 , 22712 , 22735 , 22758 , 22781,\
 187:Inc/mc_math.h ****      22804 , 22827 , 22850 , 22873 , 22896 , 22919 , 22942 , 22965,\
 188:Inc/mc_math.h ****      22988 , 23010 , 23033 , 23056 , 23079 , 23101 , 23124 , 23147,\
 189:Inc/mc_math.h ****      23169 , 23192 , 23214 , 23237 , 23260 , 23282 , 23305 , 23327,\
 190:Inc/mc_math.h ****      23350 , 23372 , 23394 , 23417 , 23439 , 23462 , 23484 , 23506,\
 191:Inc/mc_math.h ****      23529 , 23551 , 23573 , 23595 , 23617 , 23640 , 23662 , 23684,\
 192:Inc/mc_math.h ****      23706 , 23728 , 23750 , 23772 , 23794 , 23816 , 23838 , 23860,\
 193:Inc/mc_math.h ****      23882 , 23904 , 23926 , 23948 , 23970 , 23992 , 24014 , 24036,\
 194:Inc/mc_math.h ****      24057 , 24079 , 24101 , 24123 , 24144 , 24166 , 24188 , 24209,\
 195:Inc/mc_math.h ****      24231 , 24253 , 24274 , 24296 , 24317 , 24339 , 24360 , 24382,\
 196:Inc/mc_math.h ****      24403 , 24425 , 24446 , 24468 , 24489 , 24511 , 24532 , 24553,\
 197:Inc/mc_math.h ****      24575 , 24596 , 24617 , 24639 , 24660 , 24681 , 24702 , 24724,\
 198:Inc/mc_math.h ****      24745 , 24766 , 24787 , 24808 , 24829 , 24851 , 24872 , 24893,\
 199:Inc/mc_math.h ****      24914 , 24935 , 24956 , 24977 , 24998 , 25019 , 25040 , 25061,\
 200:Inc/mc_math.h ****      25082 , 25102 , 25123 , 25144 , 25165 , 25186 , 25207 , 25227,\
 201:Inc/mc_math.h ****      25248 , 25269 , 25290 , 25310 , 25331 , 25352 , 25372 , 25393,\
 202:Inc/mc_math.h ****      25414 , 25434 , 25455 , 25476 , 25496 , 25517 , 25537 , 25558,\
 203:Inc/mc_math.h ****      25578 , 25599 , 25619 , 25640 , 25660 , 25681 , 25701 , 25721,\
 204:Inc/mc_math.h ****      25742 , 25762 , 25782 , 25803 , 25823 , 25843 , 25864 , 25884,\
 205:Inc/mc_math.h ****      25904 , 25924 , 25945 , 25965 , 25985 , 26005 , 26025 , 26045,\
 206:Inc/mc_math.h ****      26065 , 26086 , 26106 , 26126 , 26146 , 26166 , 26186 , 26206,\
 207:Inc/mc_math.h ****      26226 , 26246 , 26266 , 26286 , 26306 , 26326 , 26346 , 26365,\
 208:Inc/mc_math.h ****      26385 , 26405 , 26425 , 26445 , 26465 , 26484 , 26504 , 26524,\
 209:Inc/mc_math.h ****      26544 , 26564 , 26583 , 26603 , 26623 , 26642 , 26662 , 26682,\
 210:Inc/mc_math.h ****      26701 , 26721 , 26741 , 26760 , 26780 , 26799 , 26819 , 26838,\
 211:Inc/mc_math.h ****      26858 , 26877 , 26897 , 26916 , 26936 , 26955 , 26975 , 26994,\
 212:Inc/mc_math.h ****      27014 , 27033 , 27052 , 27072 , 27091 , 27111 , 27130 , 27149,\
 213:Inc/mc_math.h ****      27168 , 27188 , 27207 , 27226 , 27246 , 27265 , 27284 , 27303,\
 214:Inc/mc_math.h ****      27322 , 27342 , 27361 , 27380 , 27399 , 27418 , 27437 , 27456,\
 215:Inc/mc_math.h ****      27475 , 27495 , 27514 , 27533 , 27552 , 27571 , 27590 , 27609,\
 216:Inc/mc_math.h ****      27628 , 27647 , 27666 , 27685 , 27703 , 27722 , 27741 , 27760,\
 217:Inc/mc_math.h ****      27779 , 27798 , 27817 , 27836 , 27854 , 27873 , 27892 , 27911,\
 218:Inc/mc_math.h ****      27930 , 27948 , 27967 , 27986 , 28005 , 28023 , 28042 , 28061,\
 219:Inc/mc_math.h ****      28079 , 28098 , 28117 , 28135 , 28154 , 28173 , 28191 , 28210,\
 220:Inc/mc_math.h ****      28228 , 28247 , 28265 , 28284 , 28303 , 28321 , 28340 , 28358,\
 221:Inc/mc_math.h ****      28377 , 28395 , 28413 , 28432 , 28450 , 28469 , 28487 , 28506,\
 222:Inc/mc_math.h ****      28524 , 28542 , 28561 , 28579 , 28597 , 28616 , 28634 , 28652,\
 223:Inc/mc_math.h ****      28671 , 28689 , 28707 , 28725 , 28744 , 28762 , 28780 , 28798,\
 224:Inc/mc_math.h ****      28817 , 28835 , 28853 , 28871 , 28889 , 28907 , 28925 , 28944,\
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 6


 225:Inc/mc_math.h ****      28962 , 28980 , 28998 , 29016 , 29034 , 29052 , 29070 , 29088,\
 226:Inc/mc_math.h ****      29106 , 29124 , 29142 , 29160 , 29178 , 29196 , 29214 , 29232,\
 227:Inc/mc_math.h ****      29250 , 29268 , 29286 , 29304 , 29322 , 29339 , 29357 , 29375,\
 228:Inc/mc_math.h ****      29393 , 29411 , 29429 , 29446 , 29464 , 29482 , 29500 , 29518,\
 229:Inc/mc_math.h ****      29535 , 29553 , 29571 , 29588 , 29606 , 29624 , 29642 , 29659,\
 230:Inc/mc_math.h ****      29677 , 29695 , 29712 , 29730 , 29748 , 29765 , 29783 , 29800,\
 231:Inc/mc_math.h ****      29818 , 29835 , 29853 , 29871 , 29888 , 29906 , 29923 , 29941,\
 232:Inc/mc_math.h ****      29958 , 29976 , 29993 , 30011 , 30028 , 30046 , 30063 , 30080,\
 233:Inc/mc_math.h ****      30098 , 30115 , 30133 , 30150 , 30168 , 30185 , 30202 , 30220,\
 234:Inc/mc_math.h ****      30237 , 30254 , 30272 , 30289 , 30306 , 30324 , 30341 , 30358,\
 235:Inc/mc_math.h ****      30375 , 30393 , 30410 , 30427 , 30444 , 30461 , 30479 , 30496,\
 236:Inc/mc_math.h ****      30513 , 30530 , 30547 , 30565 , 30582 , 30599 , 30616 , 30633,\
 237:Inc/mc_math.h ****      30650 , 30667 , 30684 , 30701 , 30719 , 30736 , 30753 , 30770,\
 238:Inc/mc_math.h ****      30787 , 30804 , 30821 , 30838 , 30855 , 30872 , 30889 , 30906,\
 239:Inc/mc_math.h ****      30923 , 30940 , 30957 , 30973 , 30990 , 31007 , 31024 , 31041,\
 240:Inc/mc_math.h ****      31058 , 31075 , 31092 , 31109 , 31125 , 31142 , 31159 , 31176,\
 241:Inc/mc_math.h ****      31193 , 31210 , 31226 , 31243 , 31260 , 31277 , 31293 , 31310,\
 242:Inc/mc_math.h ****      31327 , 31344 , 31360 , 31377 , 31394 , 31410 , 31427 , 31444,\
 243:Inc/mc_math.h ****      31461 , 31477 , 31494 , 31510 , 31527 , 31544 , 31560 , 31577,\
 244:Inc/mc_math.h ****      31594 , 31610 , 31627 , 31643 , 31660 , 31676 , 31693 , 31709,\
 245:Inc/mc_math.h ****      31726 , 31743 , 31759 , 31776 , 31792 , 31809 , 31825 , 31841,\
 246:Inc/mc_math.h ****      31858 , 31874 , 31891 , 31907 , 31924 , 31940 , 31957 , 31973,\
 247:Inc/mc_math.h ****      31989 , 32006 , 32023 , 32038 , 32055 , 32071 , 32087 , 32104,\
 248:Inc/mc_math.h ****      32120 , 32136 , 32153 , 32169 , 32185 , 32202 , 32218 , 32234,\
 249:Inc/mc_math.h ****      32250 , 32267 , 32283 , 32299 , 32315 , 32332 , 32348 , 32364,\
 250:Inc/mc_math.h ****      32380 , 32396 , 32413 , 32429 , 32445 , 32461 , 32477 , 32493,\
 251:Inc/mc_math.h ****      32509 , 32526 , 32542 , 32558 , 32574 , 32590 , 32606 , 32622,\
 252:Inc/mc_math.h ****      32638 , 32654 , 32670 , 32686 , 32702 , 32718 , 32734 , 32750,\
 253:Inc/mc_math.h ****      32767 }
 254:Inc/mc_math.h **** 
 255:Inc/mc_math.h **** #define ATAN1DIV1     (int16_t)8192
 256:Inc/mc_math.h **** #define ATAN1DIV2     (int16_t)4836
 257:Inc/mc_math.h **** #define ATAN1DIV4     (int16_t)2555
 258:Inc/mc_math.h **** #define ATAN1DIV8     (int16_t)1297
 259:Inc/mc_math.h **** #define ATAN1DIV16    (int16_t)651
 260:Inc/mc_math.h **** #define ATAN1DIV32    (int16_t)326
 261:Inc/mc_math.h **** #define ATAN1DIV64    (int16_t)163
 262:Inc/mc_math.h **** #define ATAN1DIV128   (int16_t)81
 263:Inc/mc_math.h **** #define ATAN1DIV256   (int16_t)41
 264:Inc/mc_math.h **** #define ATAN1DIV512   (int16_t)20
 265:Inc/mc_math.h **** #define ATAN1DIV1024  (int16_t)10
 266:Inc/mc_math.h **** #define ATAN1DIV2048  (int16_t)5
 267:Inc/mc_math.h **** #define ATAN1DIV4096  (int16_t)3
 268:Inc/mc_math.h **** #define ATAN1DIV8192  (int16_t)1
 269:Inc/mc_math.h **** 
 270:Inc/mc_math.h **** /**
 271:Inc/mc_math.h ****   * @brief  It executes Modulus algorithm.
 272:Inc/mc_math.h ****   * @param  alpha component,
 273:Inc/mc_math.h ****   *         beta component.
 274:Inc/mc_math.h ****   * @retval int16_t Modulus.
 275:Inc/mc_math.h ****   */
 276:Inc/mc_math.h **** static inline int16_t MCM_Modulus(int16_t alpha, int16_t beta)
 277:Inc/mc_math.h **** {
  64              		.loc 1 277 1
  65              		.cfi_startproc
  66              		@ args = 0, pretend = 0, frame = 16
  67              		@ frame_needed = 1, uses_anonymous_args = 0
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 7


  68 0000 80B5     		push	{r7, lr}
  69              	.LCFI0:
  70              		.cfi_def_cfa_offset 8
  71              		.cfi_offset 7, -8
  72              		.cfi_offset 14, -4
  73 0002 84B0     		sub	sp, sp, #16
  74              	.LCFI1:
  75              		.cfi_def_cfa_offset 24
  76 0004 00AF     		add	r7, sp, #0
  77              	.LCFI2:
  78              		.cfi_def_cfa_register 7
  79 0006 0346     		mov	r3, r0
  80 0008 0A46     		mov	r2, r1
  81 000a FB80     		strh	r3, [r7, #6]	@ movhi
  82 000c 1346     		mov	r3, r2	@ movhi
  83 000e BB80     		strh	r3, [r7, #4]	@ movhi
 278:Inc/mc_math.h **** 
 279:Inc/mc_math.h ****   int32_t wAux1;
 280:Inc/mc_math.h ****   int32_t wAux2;
 281:Inc/mc_math.h **** 
 282:Inc/mc_math.h ****   wAux1 = (int32_t)(alpha  * alpha);
  84              		.loc 1 282 11
  85 0010 B7F90630 		ldrsh	r3, [r7, #6]
  86 0014 B7F90620 		ldrsh	r2, [r7, #6]
  87              		.loc 1 282 9
  88 0018 02FB03F3 		mul	r3, r2, r3
  89 001c FB60     		str	r3, [r7, #12]
 283:Inc/mc_math.h ****   wAux2 = (int32_t)(beta * beta);
  90              		.loc 1 283 11
  91 001e B7F90430 		ldrsh	r3, [r7, #4]
  92 0022 B7F90420 		ldrsh	r2, [r7, #4]
  93              		.loc 1 283 9
  94 0026 02FB03F3 		mul	r3, r2, r3
  95 002a BB60     		str	r3, [r7, #8]
 284:Inc/mc_math.h **** 
 285:Inc/mc_math.h ****   wAux1 += wAux2;
  96              		.loc 1 285 9
  97 002c FA68     		ldr	r2, [r7, #12]
  98 002e BB68     		ldr	r3, [r7, #8]
  99 0030 1344     		add	r3, r3, r2
 100 0032 FB60     		str	r3, [r7, #12]
 286:Inc/mc_math.h ****   wAux1 = MCM_Sqrt(wAux1);
 101              		.loc 1 286 11
 102 0034 F868     		ldr	r0, [r7, #12]
 103 0036 FFF7FEFF 		bl	MCM_Sqrt
 104 003a F860     		str	r0, [r7, #12]
 287:Inc/mc_math.h **** 
 288:Inc/mc_math.h ****   if (wAux1 > INT16_MAX)
 105              		.loc 1 288 6
 106 003c FB68     		ldr	r3, [r7, #12]
 107 003e B3F5004F 		cmp	r3, #32768
 108 0042 02DB     		blt	.L2
 289:Inc/mc_math.h ****   {
 290:Inc/mc_math.h ****     wAux1 = (int32_t)INT16_MAX;
 109              		.loc 1 290 11
 110 0044 47F6FF73 		movw	r3, #32767
 111 0048 FB60     		str	r3, [r7, #12]
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 8


 112              	.L2:
 291:Inc/mc_math.h ****   }
 292:Inc/mc_math.h ****   else
 293:Inc/mc_math.h ****   {
 294:Inc/mc_math.h ****     /* Nothing to do */
 295:Inc/mc_math.h ****   }
 296:Inc/mc_math.h **** 
 297:Inc/mc_math.h ****   return ((int16_t)wAux1);
 113              		.loc 1 297 11
 114 004a FB68     		ldr	r3, [r7, #12]
 115 004c 1BB2     		sxth	r3, r3
 298:Inc/mc_math.h **** 
 299:Inc/mc_math.h **** }
 116              		.loc 1 299 1
 117 004e 1846     		mov	r0, r3
 118 0050 1037     		adds	r7, r7, #16
 119              	.LCFI3:
 120              		.cfi_def_cfa_offset 8
 121 0052 BD46     		mov	sp, r7
 122              	.LCFI4:
 123              		.cfi_def_cfa_register 13
 124              		@ sp needed
 125 0054 80BD     		pop	{r7, pc}
 126              		.cfi_endproc
 127              	.LFE1088:
 129              		.section	.text.MCI_Init,"ax",%progbits
 130              		.align	1
 131              		.weak	MCI_Init
 132              		.syntax unified
 133              		.thumb
 134              		.thumb_func
 136              	MCI_Init:
 137              	.LFB1090:
 138              		.file 2 "Src/mc_interface.c"
   1:Src/mc_interface.c **** 
   2:Src/mc_interface.c **** /**
   3:Src/mc_interface.c ****   ******************************************************************************
   4:Src/mc_interface.c ****   * @file    mc_interface.c
   5:Src/mc_interface.c ****   * @author  Motor Control SDK Team, ST Microelectronics
   6:Src/mc_interface.c ****   * @brief   This file provides firmware functions that implement the features
   7:Src/mc_interface.c ****   *          of the MC Interface component of the Motor Control SDK:
   8:Src/mc_interface.c ****   *
   9:Src/mc_interface.c ****   ******************************************************************************
  10:Src/mc_interface.c ****   * @attention
  11:Src/mc_interface.c ****   *
  12:Src/mc_interface.c ****   * <h2><center>&copy; Copyright (c) 2023 STMicroelectronics.
  13:Src/mc_interface.c ****   * All rights reserved.</center></h2>
  14:Src/mc_interface.c ****   *
  15:Src/mc_interface.c ****   * This software component is licensed by ST under Ultimate Liberty license
  16:Src/mc_interface.c ****   * SLA0044, the "License"; You may not use this file except in compliance with
  17:Src/mc_interface.c ****   * the License. You may obtain a copy of the License at:
  18:Src/mc_interface.c ****   *                             www.st.com/SLA0044
  19:Src/mc_interface.c ****   *
  20:Src/mc_interface.c ****   ******************************************************************************
  21:Src/mc_interface.c ****   * @ingroup MCInterface
  22:Src/mc_interface.c ****   */
  23:Src/mc_interface.c **** 
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 9


  24:Src/mc_interface.c **** /* Includes ------------------------------------------------------------------*/
  25:Src/mc_interface.c **** #include "mc_math.h"
  26:Src/mc_interface.c **** #include "speed_torq_ctrl.h"
  27:Src/mc_interface.c **** #include "mc_interface.h"
  28:Src/mc_interface.c **** #include "motorcontrol.h"
  29:Src/mc_interface.c **** 
  30:Src/mc_interface.c **** #define ROUNDING_OFF
  31:Src/mc_interface.c **** 
  32:Src/mc_interface.c **** /** @addtogroup MCSDK
  33:Src/mc_interface.c ****   * @{
  34:Src/mc_interface.c ****   */
  35:Src/mc_interface.c **** 
  36:Src/mc_interface.c **** /** @addtogroup CAI
  37:Src/mc_interface.c ****   * @{
  38:Src/mc_interface.c ****   */
  39:Src/mc_interface.c **** 
  40:Src/mc_interface.c **** /** @defgroup MCInterface Motor Control Interface
  41:Src/mc_interface.c ****   * @brief MC Interface component of the Motor Control SDK
  42:Src/mc_interface.c ****   *
  43:Src/mc_interface.c ****   *  This interface allows for performing basic operations on the motor driven by a
  44:Src/mc_interface.c ****   *  Motor Control SDK based application. With it, motors can be started and stopped, speed or
  45:Src/mc_interface.c ****   *  torque ramps can be programmed and executed and information on the state of the motor can
  46:Src/mc_interface.c ****   *  be retrieved, among others.
  47:Src/mc_interface.c ****   *
  48:Src/mc_interface.c ****   *  These functions aims at being the main interface used by an application to control the motor.
  49:Src/mc_interface.c ****   *
  50:Src/mc_interface.c ****   * @{
  51:Src/mc_interface.c ****   */
  52:Src/mc_interface.c **** /* Private macros ------------------------------------------------------------*/
  53:Src/mc_interface.c **** 
  54:Src/mc_interface.c **** #define round(x) ((x)>=0?(int32_t)((x)+0.5):(int32_t)((x)-0.5))
  55:Src/mc_interface.c **** 
  56:Src/mc_interface.c **** /* Functions -----------------------------------------------*/
  57:Src/mc_interface.c **** 
  58:Src/mc_interface.c **** /**
  59:Src/mc_interface.c ****   * @brief  Initializes all the object variables, usually it has to be called
  60:Src/mc_interface.c ****   *         once right after object creation. It is also used to assign the
  61:Src/mc_interface.c ****   *         state machine object, the speed and torque controller, and the FOC
  62:Src/mc_interface.c ****   *         drive object to be used by MC Interface.
  63:Src/mc_interface.c ****   * @param  pHandle pointer on the component instance to initialize.
  64:Src/mc_interface.c ****   * @param  pSTC the speed and torque controller used by the MCI.
  65:Src/mc_interface.c ****   * @param  pFOCVars pointer to FOC vars to be used by MCI.
  66:Src/mc_interface.c ****   * @param  pPosCtrl pointer to the position controller to be used by the MCI
  67:Src/mc_interface.c ****   *         (only present if position control is enabled)
  68:Src/mc_interface.c ****   * @param  pPWMHandle pointer to the PWM & current feedback component to be used by the MCI.
  69:Src/mc_interface.c ****   */
  70:Src/mc_interface.c **** __weak void MCI_Init(MCI_Handle_t *pHandle, SpeednTorqCtrl_Handle_t *pSTC,
  71:Src/mc_interface.c ****                      pFOCVars_t pFOCVars, PosCtrl_Handle_t *pPosCtrl, PWMC_Handle_t *pPWMHandle)
  72:Src/mc_interface.c **** {
 139              		.loc 2 72 1
 140              		.cfi_startproc
 141              		@ args = 4, pretend = 0, frame = 16
 142              		@ frame_needed = 1, uses_anonymous_args = 0
 143              		@ link register save eliminated.
 144 0000 80B4     		push	{r7}
 145              	.LCFI5:
 146              		.cfi_def_cfa_offset 4
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 10


 147              		.cfi_offset 7, -4
 148 0002 85B0     		sub	sp, sp, #20
 149              	.LCFI6:
 150              		.cfi_def_cfa_offset 24
 151 0004 00AF     		add	r7, sp, #0
 152              	.LCFI7:
 153              		.cfi_def_cfa_register 7
 154 0006 F860     		str	r0, [r7, #12]
 155 0008 B960     		str	r1, [r7, #8]
 156 000a 7A60     		str	r2, [r7, #4]
 157 000c 3B60     		str	r3, [r7]
  73:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
  74:Src/mc_interface.c ****   if (MC_NULL == pHandle)
  75:Src/mc_interface.c ****   {
  76:Src/mc_interface.c ****     /* Nothing to do */
  77:Src/mc_interface.c ****   }
  78:Src/mc_interface.c ****   else
  79:Src/mc_interface.c ****   {
  80:Src/mc_interface.c **** #endif
  81:Src/mc_interface.c ****     pHandle->pSTC = pSTC;
 158              		.loc 2 81 19
 159 000e FB68     		ldr	r3, [r7, #12]
 160 0010 BA68     		ldr	r2, [r7, #8]
 161 0012 1A60     		str	r2, [r3]
  82:Src/mc_interface.c ****     pHandle->pFOCVars = pFOCVars;
 162              		.loc 2 82 23
 163 0014 FB68     		ldr	r3, [r7, #12]
 164 0016 7A68     		ldr	r2, [r7, #4]
 165 0018 5A60     		str	r2, [r3, #4]
  83:Src/mc_interface.c ****     pHandle->pPosCtrl = pPosCtrl;
 166              		.loc 2 83 23
 167 001a FB68     		ldr	r3, [r7, #12]
 168 001c 3A68     		ldr	r2, [r7]
 169 001e 1A61     		str	r2, [r3, #16]
  84:Src/mc_interface.c ****     pHandle->pPWM = pPWMHandle;
 170              		.loc 2 84 19
 171 0020 FB68     		ldr	r3, [r7, #12]
 172 0022 BA69     		ldr	r2, [r7, #24]
 173 0024 9A60     		str	r2, [r3, #8]
  85:Src/mc_interface.c **** 
  86:Src/mc_interface.c ****     /* Buffer related initialization */
  87:Src/mc_interface.c ****     pHandle->lastCommand = MCI_NOCOMMANDSYET;
 174              		.loc 2 87 26
 175 0026 FB68     		ldr	r3, [r7, #12]
 176 0028 0022     		movs	r2, #0
 177 002a 1A75     		strb	r2, [r3, #20]
  88:Src/mc_interface.c ****     pHandle->hFinalSpeed = 0;
 178              		.loc 2 88 26
 179 002c FB68     		ldr	r3, [r7, #12]
 180 002e 0022     		movs	r2, #0
 181 0030 DA82     		strh	r2, [r3, #22]	@ movhi
  89:Src/mc_interface.c ****     pHandle->hFinalTorque = 0;
 182              		.loc 2 89 27
 183 0032 FB68     		ldr	r3, [r7, #12]
 184 0034 0022     		movs	r2, #0
 185 0036 1A83     		strh	r2, [r3, #24]	@ movhi
  90:Src/mc_interface.c ****     pHandle->hDurationms = 0;
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 11


 186              		.loc 2 90 26
 187 0038 FB68     		ldr	r3, [r7, #12]
 188 003a 0022     		movs	r2, #0
 189 003c 9A84     		strh	r2, [r3, #36]	@ movhi
  91:Src/mc_interface.c ****     pHandle->CommandState = MCI_BUFFER_EMPTY;
 190              		.loc 2 91 27
 191 003e FB68     		ldr	r3, [r7, #12]
 192 0040 0022     		movs	r2, #0
 193 0042 83F82C20 		strb	r2, [r3, #44]
  92:Src/mc_interface.c ****     pHandle->DirectCommand = MCI_NO_COMMAND;
 194              		.loc 2 92 28
 195 0046 FB68     		ldr	r3, [r7, #12]
 196 0048 0022     		movs	r2, #0
 197 004a 83F82620 		strb	r2, [r3, #38]
  93:Src/mc_interface.c ****     pHandle->State = IDLE;
 198              		.loc 2 93 20
 199 004e FB68     		ldr	r3, [r7, #12]
 200 0050 0022     		movs	r2, #0
 201 0052 83F82720 		strb	r2, [r3, #39]
  94:Src/mc_interface.c ****     pHandle->CurrentFaults = MC_NO_FAULTS;
 202              		.loc 2 94 28
 203 0056 FB68     		ldr	r3, [r7, #12]
 204 0058 0022     		movs	r2, #0
 205 005a 1A85     		strh	r2, [r3, #40]	@ movhi
  95:Src/mc_interface.c ****     pHandle->PastFaults = MC_NO_FAULTS;
 206              		.loc 2 95 25
 207 005c FB68     		ldr	r3, [r7, #12]
 208 005e 0022     		movs	r2, #0
 209 0060 5A85     		strh	r2, [r3, #42]	@ movhi
  96:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
  97:Src/mc_interface.c ****   }
  98:Src/mc_interface.c **** #endif
  99:Src/mc_interface.c **** }
 210              		.loc 2 99 1
 211 0062 00BF     		nop
 212 0064 1437     		adds	r7, r7, #20
 213              	.LCFI8:
 214              		.cfi_def_cfa_offset 4
 215 0066 BD46     		mov	sp, r7
 216              	.LCFI9:
 217              		.cfi_def_cfa_register 13
 218              		@ sp needed
 219 0068 5DF8047B 		ldr	r7, [sp], #4
 220              	.LCFI10:
 221              		.cfi_restore 7
 222              		.cfi_def_cfa_offset 0
 223 006c 7047     		bx	lr
 224              		.cfi_endproc
 225              	.LFE1090:
 227              		.section	.text.MCI_ExecSpeedRamp,"ax",%progbits
 228              		.align	1
 229              		.weak	MCI_ExecSpeedRamp
 230              		.syntax unified
 231              		.thumb
 232              		.thumb_func
 234              	MCI_ExecSpeedRamp:
 235              	.LFB1091:
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 12


 100:Src/mc_interface.c **** 
 101:Src/mc_interface.c **** /**
 102:Src/mc_interface.c ****   * @brief  Programs a motor speed ramp
 103:Src/mc_interface.c ****   *
 104:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to operate on.
 105:Src/mc_interface.c ****   * @param  hFinalSpeed The value of mechanical rotor speed reference at the
 106:Src/mc_interface.c ****   *         end of the ramp expressed in the unit defined by #SPEED_UNIT.
 107:Src/mc_interface.c ****   * @param  hDurationms The duration of the ramp expressed in milliseconds. It
 108:Src/mc_interface.c ****   *         is possible to set 0 to perform an instantaneous change in the
 109:Src/mc_interface.c ****   *         value.
 110:Src/mc_interface.c ****   *
 111:Src/mc_interface.c ****   *  This command is executed immediately if the target motor's state machine is in
 112:Src/mc_interface.c ****   * the #RUN state. Otherwise, it is buffered and its execution is delayed until This
 113:Src/mc_interface.c ****   * state is reached.
 114:Src/mc_interface.c ****   *
 115:Src/mc_interface.c ****   * Users can check the status of the command by calling the MCI_IsCommandAcknowledged()
 116:Src/mc_interface.c ****   * function.
 117:Src/mc_interface.c ****   *
 118:Src/mc_interface.c ****   * @sa MCI_ExecSpeedRamp_F
 119:Src/mc_interface.c ****   */
 120:Src/mc_interface.c **** __weak void MCI_ExecSpeedRamp(MCI_Handle_t *pHandle, int16_t hFinalSpeed, uint16_t hDurationms)
 121:Src/mc_interface.c **** {
 236              		.loc 2 121 1
 237              		.cfi_startproc
 238              		@ args = 0, pretend = 0, frame = 8
 239              		@ frame_needed = 1, uses_anonymous_args = 0
 240              		@ link register save eliminated.
 241 0000 80B4     		push	{r7}
 242              	.LCFI11:
 243              		.cfi_def_cfa_offset 4
 244              		.cfi_offset 7, -4
 245 0002 83B0     		sub	sp, sp, #12
 246              	.LCFI12:
 247              		.cfi_def_cfa_offset 16
 248 0004 00AF     		add	r7, sp, #0
 249              	.LCFI13:
 250              		.cfi_def_cfa_register 7
 251 0006 7860     		str	r0, [r7, #4]
 252 0008 0B46     		mov	r3, r1
 253 000a 7B80     		strh	r3, [r7, #2]	@ movhi
 254 000c 1346     		mov	r3, r2	@ movhi
 255 000e 3B80     		strh	r3, [r7]	@ movhi
 122:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
 123:Src/mc_interface.c ****   if (MC_NULL == pHandle)
 124:Src/mc_interface.c ****   {
 125:Src/mc_interface.c ****     /* Nothing to do */
 126:Src/mc_interface.c ****   }
 127:Src/mc_interface.c ****   else
 128:Src/mc_interface.c ****   {
 129:Src/mc_interface.c **** #endif
 130:Src/mc_interface.c ****     pHandle->lastCommand = MCI_CMD_EXECSPEEDRAMP;
 256              		.loc 2 130 26
 257 0010 7B68     		ldr	r3, [r7, #4]
 258 0012 0122     		movs	r2, #1
 259 0014 1A75     		strb	r2, [r3, #20]
 131:Src/mc_interface.c ****     pHandle->hFinalSpeed = hFinalSpeed;
 260              		.loc 2 131 26
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 13


 261 0016 7B68     		ldr	r3, [r7, #4]
 262 0018 7A88     		ldrh	r2, [r7, #2]	@ movhi
 263 001a DA82     		strh	r2, [r3, #22]	@ movhi
 132:Src/mc_interface.c ****     pHandle->hDurationms = hDurationms;
 264              		.loc 2 132 26
 265 001c 7B68     		ldr	r3, [r7, #4]
 266 001e 3A88     		ldrh	r2, [r7]	@ movhi
 267 0020 9A84     		strh	r2, [r3, #36]	@ movhi
 133:Src/mc_interface.c ****     pHandle->CommandState = MCI_COMMAND_NOT_ALREADY_EXECUTED;
 268              		.loc 2 133 27
 269 0022 7B68     		ldr	r3, [r7, #4]
 270 0024 0122     		movs	r2, #1
 271 0026 83F82C20 		strb	r2, [r3, #44]
 134:Src/mc_interface.c ****     pHandle->LastModalitySetByUser = MCM_SPEED_MODE;
 272              		.loc 2 134 36
 273 002a 7B68     		ldr	r3, [r7, #4]
 274 002c 0322     		movs	r2, #3
 275 002e 83F82D20 		strb	r2, [r3, #45]
 135:Src/mc_interface.c **** 
 136:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
 137:Src/mc_interface.c ****   }
 138:Src/mc_interface.c **** #endif
 139:Src/mc_interface.c **** }
 276              		.loc 2 139 1
 277 0032 00BF     		nop
 278 0034 0C37     		adds	r7, r7, #12
 279              	.LCFI14:
 280              		.cfi_def_cfa_offset 4
 281 0036 BD46     		mov	sp, r7
 282              	.LCFI15:
 283              		.cfi_def_cfa_register 13
 284              		@ sp needed
 285 0038 5DF8047B 		ldr	r7, [sp], #4
 286              	.LCFI16:
 287              		.cfi_restore 7
 288              		.cfi_def_cfa_offset 0
 289 003c 7047     		bx	lr
 290              		.cfi_endproc
 291              	.LFE1091:
 293              		.section	.text.MCI_ExecSpeedRamp_F,"ax",%progbits
 294              		.align	1
 295              		.weak	MCI_ExecSpeedRamp_F
 296              		.syntax unified
 297              		.thumb
 298              		.thumb_func
 300              	MCI_ExecSpeedRamp_F:
 301              	.LFB1092:
 140:Src/mc_interface.c **** 
 141:Src/mc_interface.c **** /**
 142:Src/mc_interface.c ****   * @brief  Programs a motor speed ramp
 143:Src/mc_interface.c ****   *
 144:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to operate on.
 145:Src/mc_interface.c ****   * @param  FinalSpeed is the value of mechanical rotor speed reference at the
 146:Src/mc_interface.c ****   *         end of the ramp expressed in RPM.
 147:Src/mc_interface.c ****   * @param  hDurationms the duration of the ramp expressed in milliseconds. It
 148:Src/mc_interface.c ****   *         is possible to set 0 to perform an instantaneous change in the
 149:Src/mc_interface.c ****   *         value.
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 14


 150:Src/mc_interface.c ****   *
 151:Src/mc_interface.c ****   *  This command is executed immediately if the target motor's state machine is in
 152:Src/mc_interface.c ****   * the #RUN state. Otherwise, it is buffered and its execution is delayed until This
 153:Src/mc_interface.c ****   * state is reached.
 154:Src/mc_interface.c ****   *
 155:Src/mc_interface.c ****   * Users can check the status of the command by calling the MCI_IsCommandAcknowledged()
 156:Src/mc_interface.c ****   * function.
 157:Src/mc_interface.c ****   *
 158:Src/mc_interface.c ****   * @sa MCI_ExecSpeedRamp
 159:Src/mc_interface.c ****   */
 160:Src/mc_interface.c **** __weak void MCI_ExecSpeedRamp_F(MCI_Handle_t *pHandle, const float_t FinalSpeed, uint16_t hDuration
 161:Src/mc_interface.c **** {
 302              		.loc 2 161 1
 303              		.cfi_startproc
 304              		@ args = 0, pretend = 0, frame = 24
 305              		@ frame_needed = 1, uses_anonymous_args = 0
 306 0000 80B5     		push	{r7, lr}
 307              	.LCFI17:
 308              		.cfi_def_cfa_offset 8
 309              		.cfi_offset 7, -8
 310              		.cfi_offset 14, -4
 311 0002 86B0     		sub	sp, sp, #24
 312              	.LCFI18:
 313              		.cfi_def_cfa_offset 32
 314 0004 00AF     		add	r7, sp, #0
 315              	.LCFI19:
 316              		.cfi_def_cfa_register 7
 317 0006 F860     		str	r0, [r7, #12]
 318 0008 87ED020A 		vstr.32	s0, [r7, #8]
 319 000c 0B46     		mov	r3, r1
 320 000e FB80     		strh	r3, [r7, #6]	@ movhi
 162:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
 163:Src/mc_interface.c ****   if (MC_NULL == pHandle)
 164:Src/mc_interface.c ****   {
 165:Src/mc_interface.c ****     /* Nothing to do */
 166:Src/mc_interface.c ****   }
 167:Src/mc_interface.c ****   else
 168:Src/mc_interface.c ****   {
 169:Src/mc_interface.c **** #endif
 170:Src/mc_interface.c ****     int16_t hFinalSpeed = (((int16_t)FinalSpeed * (int16_t)SPEED_UNIT) / (int16_t)U_RPM);
 321              		.loc 2 170 29
 322 0010 D7ED027A 		vldr.32	s15, [r7, #8]
 323 0014 FDEEE77A 		vcvt.s32.f32	s15, s15
 324 0018 17EE903A 		vmov	r3, s15	@ int
 325 001c 1BB2     		sxth	r3, r3
 326              		.loc 2 170 13
 327 001e 084A     		ldr	r2, .L7
 328 0020 82FB0312 		smull	r1, r2, r2, r3
 329 0024 DB17     		asrs	r3, r3, #31
 330 0026 D31A     		subs	r3, r2, r3
 331 0028 FB82     		strh	r3, [r7, #22]	@ movhi
 171:Src/mc_interface.c ****     MCI_ExecSpeedRamp(pHandle, hFinalSpeed, hDurationms);
 332              		.loc 2 171 5
 333 002a FA88     		ldrh	r2, [r7, #6]
 334 002c B7F91630 		ldrsh	r3, [r7, #22]
 335 0030 1946     		mov	r1, r3
 336 0032 F868     		ldr	r0, [r7, #12]
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 15


 337 0034 FFF7FEFF 		bl	MCI_ExecSpeedRamp
 172:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
 173:Src/mc_interface.c ****   }
 174:Src/mc_interface.c **** #endif
 175:Src/mc_interface.c **** }
 338              		.loc 2 175 1
 339 0038 00BF     		nop
 340 003a 1837     		adds	r7, r7, #24
 341              	.LCFI20:
 342              		.cfi_def_cfa_offset 8
 343 003c BD46     		mov	sp, r7
 344              	.LCFI21:
 345              		.cfi_def_cfa_register 13
 346              		@ sp needed
 347 003e 80BD     		pop	{r7, pc}
 348              	.L8:
 349              		.align	2
 350              	.L7:
 351 0040 ABAAAA2A 		.word	715827883
 352              		.cfi_endproc
 353              	.LFE1092:
 355              		.section	.text.MCI_ExecTorqueRamp,"ax",%progbits
 356              		.align	1
 357              		.weak	MCI_ExecTorqueRamp
 358              		.syntax unified
 359              		.thumb
 360              		.thumb_func
 362              	MCI_ExecTorqueRamp:
 363              	.LFB1093:
 176:Src/mc_interface.c **** 
 177:Src/mc_interface.c **** /**
 178:Src/mc_interface.c ****   * @brief  Programs a motor torque ramp
 179:Src/mc_interface.c ****   *
 180:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
 181:Src/mc_interface.c ****   * @param  hFinalTorque is the value of motor torque reference at the end of
 182:Src/mc_interface.c ****   *         the ramp. This value represents actually the $I_q$ current expressed in
 183:Src/mc_interface.c ****   *         digit.
 184:Src/mc_interface.c ****   *         To convert current expressed in Amps to current expressed in digit
 185:Src/mc_interface.c ****   *         is possible to use the formula:
 186:Src/mc_interface.c ****   *         Current (digit) = [Current(Amp) * 65536 * Rshunt * Aop] / Vdd micro.
 187:Src/mc_interface.c ****   * @param  hDurationms the duration of the ramp expressed in milliseconds. It
 188:Src/mc_interface.c ****   *         is possible to set 0 to perform an instantaneous change in the
 189:Src/mc_interface.c ****   *         value.
 190:Src/mc_interface.c ****   *
 191:Src/mc_interface.c ****   *  This command is executed immediately if the target motor's state machine is in
 192:Src/mc_interface.c ****   * the #RUN state. Otherwise, it is buffered and its execution is delayed until This
 193:Src/mc_interface.c ****   * state is reached.
 194:Src/mc_interface.c ****   *
 195:Src/mc_interface.c ****   * Users can check the status of the command by calling the MCI_IsCommandAcknowledged()
 196:Src/mc_interface.c ****   * function.
 197:Src/mc_interface.c ****   *
 198:Src/mc_interface.c ****   * @sa MCI_ExecTorqueRamp_F
 199:Src/mc_interface.c ****   */
 200:Src/mc_interface.c **** __weak void MCI_ExecTorqueRamp(MCI_Handle_t *pHandle, int16_t hFinalTorque, uint16_t hDurationms)
 201:Src/mc_interface.c **** {
 364              		.loc 2 201 1
 365              		.cfi_startproc
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 16


 366              		@ args = 0, pretend = 0, frame = 8
 367              		@ frame_needed = 1, uses_anonymous_args = 0
 368              		@ link register save eliminated.
 369 0000 80B4     		push	{r7}
 370              	.LCFI22:
 371              		.cfi_def_cfa_offset 4
 372              		.cfi_offset 7, -4
 373 0002 83B0     		sub	sp, sp, #12
 374              	.LCFI23:
 375              		.cfi_def_cfa_offset 16
 376 0004 00AF     		add	r7, sp, #0
 377              	.LCFI24:
 378              		.cfi_def_cfa_register 7
 379 0006 7860     		str	r0, [r7, #4]
 380 0008 0B46     		mov	r3, r1
 381 000a 7B80     		strh	r3, [r7, #2]	@ movhi
 382 000c 1346     		mov	r3, r2	@ movhi
 383 000e 3B80     		strh	r3, [r7]	@ movhi
 202:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
 203:Src/mc_interface.c ****   if (MC_NULL == pHandle)
 204:Src/mc_interface.c ****   {
 205:Src/mc_interface.c ****     /* Nothing to do */
 206:Src/mc_interface.c ****   }
 207:Src/mc_interface.c ****   else
 208:Src/mc_interface.c ****   {
 209:Src/mc_interface.c **** #endif
 210:Src/mc_interface.c ****     pHandle->lastCommand = MCI_CMD_EXECTORQUERAMP;
 384              		.loc 2 210 26
 385 0010 7B68     		ldr	r3, [r7, #4]
 386 0012 0222     		movs	r2, #2
 387 0014 1A75     		strb	r2, [r3, #20]
 211:Src/mc_interface.c ****     pHandle->hFinalTorque = hFinalTorque;
 388              		.loc 2 211 27
 389 0016 7B68     		ldr	r3, [r7, #4]
 390 0018 7A88     		ldrh	r2, [r7, #2]	@ movhi
 391 001a 1A83     		strh	r2, [r3, #24]	@ movhi
 212:Src/mc_interface.c ****     pHandle->hDurationms = hDurationms;
 392              		.loc 2 212 26
 393 001c 7B68     		ldr	r3, [r7, #4]
 394 001e 3A88     		ldrh	r2, [r7]	@ movhi
 395 0020 9A84     		strh	r2, [r3, #36]	@ movhi
 213:Src/mc_interface.c ****     pHandle->CommandState = MCI_COMMAND_NOT_ALREADY_EXECUTED;
 396              		.loc 2 213 27
 397 0022 7B68     		ldr	r3, [r7, #4]
 398 0024 0122     		movs	r2, #1
 399 0026 83F82C20 		strb	r2, [r3, #44]
 214:Src/mc_interface.c ****     pHandle->LastModalitySetByUser = MCM_TORQUE_MODE;
 400              		.loc 2 214 36
 401 002a 7B68     		ldr	r3, [r7, #4]
 402 002c 0422     		movs	r2, #4
 403 002e 83F82D20 		strb	r2, [r3, #45]
 215:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
 216:Src/mc_interface.c ****   }
 217:Src/mc_interface.c **** #endif
 218:Src/mc_interface.c **** }
 404              		.loc 2 218 1
 405 0032 00BF     		nop
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 17


 406 0034 0C37     		adds	r7, r7, #12
 407              	.LCFI25:
 408              		.cfi_def_cfa_offset 4
 409 0036 BD46     		mov	sp, r7
 410              	.LCFI26:
 411              		.cfi_def_cfa_register 13
 412              		@ sp needed
 413 0038 5DF8047B 		ldr	r7, [sp], #4
 414              	.LCFI27:
 415              		.cfi_restore 7
 416              		.cfi_def_cfa_offset 0
 417 003c 7047     		bx	lr
 418              		.cfi_endproc
 419              	.LFE1093:
 421              		.section	.text.MCI_ExecTorqueRamp_F,"ax",%progbits
 422              		.align	1
 423              		.weak	MCI_ExecTorqueRamp_F
 424              		.syntax unified
 425              		.thumb
 426              		.thumb_func
 428              	MCI_ExecTorqueRamp_F:
 429              	.LFB1094:
 219:Src/mc_interface.c **** 
 220:Src/mc_interface.c **** /**
 221:Src/mc_interface.c ****   * @brief  Programs a motor torque ramp
 222:Src/mc_interface.c ****   *
 223:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
 224:Src/mc_interface.c ****   * @param  FinalTorque is the value of motor torque reference at the end of
 225:Src/mc_interface.c ****   *         the ramp. This value represents actually the $I_q$ current expressed in
 226:Src/mc_interface.c ****   *         Ampere.
 227:Src/mc_interface.c ****   *         Here the formula for conversion from current in Ampere to digit:
 228:Src/mc_interface.c ****   *           I(s16) = [i(Amp) * 65536 * Rshunt * Aop] / Vdd_micro.
 229:Src/mc_interface.c ****   * @param  hDurationms the duration of the ramp expressed in milliseconds. It
 230:Src/mc_interface.c ****   *         is possible to set 0 to perform an instantaneous change in the
 231:Src/mc_interface.c ****   *         value.
 232:Src/mc_interface.c ****   *
 233:Src/mc_interface.c ****   *  This command is executed immediately if the target motor's state machine is in
 234:Src/mc_interface.c ****   * the #RUN state. Otherwise, it is buffered and its execution is delayed until This
 235:Src/mc_interface.c ****   * state is reached.
 236:Src/mc_interface.c ****   *
 237:Src/mc_interface.c ****   * Users can check the status of the command by calling the MCI_IsCommandAcknowledged()
 238:Src/mc_interface.c ****   * function.
 239:Src/mc_interface.c ****   *
 240:Src/mc_interface.c ****   * @sa MCI_ExecTorqueRamp
 241:Src/mc_interface.c ****   */
 242:Src/mc_interface.c **** __weak void MCI_ExecTorqueRamp_F(MCI_Handle_t *pHandle, const float_t FinalTorque, uint16_t hDurati
 243:Src/mc_interface.c **** {
 430              		.loc 2 243 1
 431              		.cfi_startproc
 432              		@ args = 0, pretend = 0, frame = 24
 433              		@ frame_needed = 1, uses_anonymous_args = 0
 434 0000 80B5     		push	{r7, lr}
 435              	.LCFI28:
 436              		.cfi_def_cfa_offset 8
 437              		.cfi_offset 7, -8
 438              		.cfi_offset 14, -4
 439 0002 86B0     		sub	sp, sp, #24
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 18


 440              	.LCFI29:
 441              		.cfi_def_cfa_offset 32
 442 0004 00AF     		add	r7, sp, #0
 443              	.LCFI30:
 444              		.cfi_def_cfa_register 7
 445 0006 F860     		str	r0, [r7, #12]
 446 0008 87ED020A 		vstr.32	s0, [r7, #8]
 447 000c 0B46     		mov	r3, r1
 448 000e FB80     		strh	r3, [r7, #6]	@ movhi
 244:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
 245:Src/mc_interface.c ****   if (MC_NULL == pHandle)
 246:Src/mc_interface.c ****   {
 247:Src/mc_interface.c ****     /* Nothing to do */
 248:Src/mc_interface.c ****   }
 249:Src/mc_interface.c ****   else
 250:Src/mc_interface.c ****   {
 251:Src/mc_interface.c **** #endif
 252:Src/mc_interface.c ****     int16_t hFinalTorque = ((int16_t)FinalTorque * (int16_t)CURRENT_CONV_FACTOR);
 449              		.loc 2 252 29
 450 0010 D7ED027A 		vldr.32	s15, [r7, #8]
 451 0014 FDEEE77A 		vcvt.s32.f32	s15, s15
 452 0018 17EE903A 		vmov	r3, s15	@ int
 453 001c 1BB2     		sxth	r3, r3
 454 001e 9BB2     		uxth	r3, r3
 455              		.loc 2 252 50
 456 0020 1A46     		mov	r2, r3	@ movhi
 457 0022 D200     		lsls	r2, r2, #3
 458 0024 1A44     		add	r2, r2, r3
 459 0026 1146     		mov	r1, r2	@ movhi
 460 0028 4901     		lsls	r1, r1, #5
 461 002a 8A1A     		subs	r2, r1, r2
 462 002c 5200     		lsls	r2, r2, #1
 463 002e D21A     		subs	r2, r2, r3
 464 0030 1146     		mov	r1, r2	@ movhi
 465 0032 C800     		lsls	r0, r1, #3
 466 0034 1146     		mov	r1, r2	@ movhi
 467 0036 0246     		mov	r2, r0	@ movhi
 468 0038 0A44     		add	r2, r2, r1
 469 003a 5200     		lsls	r2, r2, #1
 470 003c 1344     		add	r3, r3, r2
 471 003e 9BB2     		uxth	r3, r3
 472              		.loc 2 252 13
 473 0040 FB82     		strh	r3, [r7, #22]	@ movhi
 253:Src/mc_interface.c ****     MCI_ExecTorqueRamp(pHandle, hFinalTorque, hDurationms);
 474              		.loc 2 253 5
 475 0042 FA88     		ldrh	r2, [r7, #6]
 476 0044 B7F91630 		ldrsh	r3, [r7, #22]
 477 0048 1946     		mov	r1, r3
 478 004a F868     		ldr	r0, [r7, #12]
 479 004c FFF7FEFF 		bl	MCI_ExecTorqueRamp
 254:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
 255:Src/mc_interface.c ****   }
 256:Src/mc_interface.c **** #endif
 257:Src/mc_interface.c **** }
 480              		.loc 2 257 1
 481 0050 00BF     		nop
 482 0052 1837     		adds	r7, r7, #24
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 19


 483              	.LCFI31:
 484              		.cfi_def_cfa_offset 8
 485 0054 BD46     		mov	sp, r7
 486              	.LCFI32:
 487              		.cfi_def_cfa_register 13
 488              		@ sp needed
 489 0056 80BD     		pop	{r7, pc}
 490              		.cfi_endproc
 491              	.LFE1094:
 493              		.section	.text.MCI_SetCurrentReferences,"ax",%progbits
 494              		.align	1
 495              		.weak	MCI_SetCurrentReferences
 496              		.syntax unified
 497              		.thumb
 498              		.thumb_func
 500              	MCI_SetCurrentReferences:
 501              	.LFB1095:
 258:Src/mc_interface.c **** 
 259:Src/mc_interface.c **** /**
 260:Src/mc_interface.c ****   * @brief  Sets the motor current references $I_q$ and $I_d$ directly.
 261:Src/mc_interface.c ****   *
 262:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
 263:Src/mc_interface.c ****   * @param  Iqdref current references on qd reference frame in qd_t format.
 264:Src/mc_interface.c ****   *
 265:Src/mc_interface.c ****   *  This command is executed immediately if the target motor's state machine is in
 266:Src/mc_interface.c ****   * the #RUN state. Otherwise, it is buffered and its execution is delayed until This
 267:Src/mc_interface.c ****   * state is reached.
 268:Src/mc_interface.c ****   *
 269:Src/mc_interface.c ****   * Users can check the status of the command by calling the MCI_IsCommandAcknowledged()
 270:Src/mc_interface.c ****   * function.
 271:Src/mc_interface.c **** 
 272:Src/mc_interface.c ****   @sa MCI_SetCurrentReferences_F
 273:Src/mc_interface.c ****   */
 274:Src/mc_interface.c **** __weak void MCI_SetCurrentReferences(MCI_Handle_t *pHandle, qd_t Iqdref)
 275:Src/mc_interface.c **** {
 502              		.loc 2 275 1
 503              		.cfi_startproc
 504              		@ args = 0, pretend = 0, frame = 8
 505              		@ frame_needed = 1, uses_anonymous_args = 0
 506              		@ link register save eliminated.
 507 0000 80B4     		push	{r7}
 508              	.LCFI33:
 509              		.cfi_def_cfa_offset 4
 510              		.cfi_offset 7, -4
 511 0002 83B0     		sub	sp, sp, #12
 512              	.LCFI34:
 513              		.cfi_def_cfa_offset 16
 514 0004 00AF     		add	r7, sp, #0
 515              	.LCFI35:
 516              		.cfi_def_cfa_register 7
 517 0006 7860     		str	r0, [r7, #4]
 518 0008 3960     		str	r1, [r7]
 276:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
 277:Src/mc_interface.c ****   if (MC_NULL == pHandle)
 278:Src/mc_interface.c ****   {
 279:Src/mc_interface.c ****     /* Nothing to do */
 280:Src/mc_interface.c ****   }
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 20


 281:Src/mc_interface.c ****   else
 282:Src/mc_interface.c ****   {
 283:Src/mc_interface.c **** #endif
 284:Src/mc_interface.c **** 
 285:Src/mc_interface.c ****     pHandle->lastCommand = MCI_CMD_SETCURRENTREFERENCES;
 519              		.loc 2 285 26
 520 000a 7B68     		ldr	r3, [r7, #4]
 521 000c 0322     		movs	r2, #3
 522 000e 1A75     		strb	r2, [r3, #20]
 286:Src/mc_interface.c ****     pHandle->Iqdref.q = Iqdref.q;
 523              		.loc 2 286 31
 524 0010 B7F90020 		ldrsh	r2, [r7]
 525              		.loc 2 286 23
 526 0014 7B68     		ldr	r3, [r7, #4]
 527 0016 5A83     		strh	r2, [r3, #26]	@ movhi
 287:Src/mc_interface.c ****     pHandle->Iqdref.d = Iqdref.d;
 528              		.loc 2 287 31
 529 0018 B7F90220 		ldrsh	r2, [r7, #2]
 530              		.loc 2 287 23
 531 001c 7B68     		ldr	r3, [r7, #4]
 532 001e 9A83     		strh	r2, [r3, #28]	@ movhi
 288:Src/mc_interface.c ****     pHandle->CommandState = MCI_COMMAND_NOT_ALREADY_EXECUTED;
 533              		.loc 2 288 27
 534 0020 7B68     		ldr	r3, [r7, #4]
 535 0022 0122     		movs	r2, #1
 536 0024 83F82C20 		strb	r2, [r3, #44]
 289:Src/mc_interface.c ****     pHandle->LastModalitySetByUser = MCM_TORQUE_MODE;
 537              		.loc 2 289 36
 538 0028 7B68     		ldr	r3, [r7, #4]
 539 002a 0422     		movs	r2, #4
 540 002c 83F82D20 		strb	r2, [r3, #45]
 290:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
 291:Src/mc_interface.c ****   }
 292:Src/mc_interface.c **** #endif
 293:Src/mc_interface.c **** }
 541              		.loc 2 293 1
 542 0030 00BF     		nop
 543 0032 0C37     		adds	r7, r7, #12
 544              	.LCFI36:
 545              		.cfi_def_cfa_offset 4
 546 0034 BD46     		mov	sp, r7
 547              	.LCFI37:
 548              		.cfi_def_cfa_register 13
 549              		@ sp needed
 550 0036 5DF8047B 		ldr	r7, [sp], #4
 551              	.LCFI38:
 552              		.cfi_restore 7
 553              		.cfi_def_cfa_offset 0
 554 003a 7047     		bx	lr
 555              		.cfi_endproc
 556              	.LFE1095:
 558              		.section	.text.MCI_SetCurrentReferences_F,"ax",%progbits
 559              		.align	1
 560              		.weak	MCI_SetCurrentReferences_F
 561              		.syntax unified
 562              		.thumb
 563              		.thumb_func
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 21


 565              	MCI_SetCurrentReferences_F:
 566              	.LFB1096:
 294:Src/mc_interface.c **** 
 295:Src/mc_interface.c **** /**
 296:Src/mc_interface.c ****   * @brief  Sets the motor current references $I_q$ and $I_d$ directly.
 297:Src/mc_interface.c ****   *
 298:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
 299:Src/mc_interface.c ****   * @param  IqdRef current (A) references on qd reference frame in qd_f_t format.
 300:Src/mc_interface.c ****   *
 301:Src/mc_interface.c ****   *  This command is executed immediately if the target motor's state machine is in
 302:Src/mc_interface.c ****   * the #RUN state. Otherwise, it is buffered and its execution is delayed until This
 303:Src/mc_interface.c ****   * state is reached.
 304:Src/mc_interface.c ****   *
 305:Src/mc_interface.c ****   * Users can check the status of the command by calling the MCI_IsCommandAcknowledged()
 306:Src/mc_interface.c ****   * function.
 307:Src/mc_interface.c **** 
 308:Src/mc_interface.c ****   @sa MCI_SetCurrentReferences
 309:Src/mc_interface.c ****   */
 310:Src/mc_interface.c **** __weak void MCI_SetCurrentReferences_F(MCI_Handle_t *pHandle, qd_f_t IqdRef)
 311:Src/mc_interface.c **** {
 567              		.loc 2 311 1
 568              		.cfi_startproc
 569              		@ args = 0, pretend = 0, frame = 24
 570              		@ frame_needed = 1, uses_anonymous_args = 0
 571 0000 80B5     		push	{r7, lr}
 572              	.LCFI39:
 573              		.cfi_def_cfa_offset 8
 574              		.cfi_offset 7, -8
 575              		.cfi_offset 14, -4
 576 0002 86B0     		sub	sp, sp, #24
 577              	.LCFI40:
 578              		.cfi_def_cfa_offset 32
 579 0004 00AF     		add	r7, sp, #0
 580              	.LCFI41:
 581              		.cfi_def_cfa_register 7
 582 0006 F860     		str	r0, [r7, #12]
 583 0008 B0EE407A 		vmov.f32	s14, s0
 584 000c F0EE607A 		vmov.f32	s15, s1
 585 0010 87ED017A 		vstr.32	s14, [r7, #4]
 586 0014 C7ED027A 		vstr.32	s15, [r7, #8]
 312:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
 313:Src/mc_interface.c ****   if (MC_NULL == pHandle)
 314:Src/mc_interface.c ****   {
 315:Src/mc_interface.c ****     /* Nothing to do */
 316:Src/mc_interface.c ****   }
 317:Src/mc_interface.c ****   else
 318:Src/mc_interface.c ****   {
 319:Src/mc_interface.c **** #endif
 320:Src/mc_interface.c ****     qd_t iqDrefTemp;
 321:Src/mc_interface.c ****     iqDrefTemp.d = (int16_t)((int16_t)IqdRef.d * (int16_t)CURRENT_CONV_FACTOR);
 587              		.loc 2 321 45
 588 0018 D7ED027A 		vldr.32	s15, [r7, #8]
 589              		.loc 2 321 30
 590 001c FDEEE77A 		vcvt.s32.f32	s15, s15
 591 0020 17EE903A 		vmov	r3, s15	@ int
 592 0024 1BB2     		sxth	r3, r3
 593 0026 9BB2     		uxth	r3, r3
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 22


 594              		.loc 2 321 48
 595 0028 1A46     		mov	r2, r3	@ movhi
 596 002a D200     		lsls	r2, r2, #3
 597 002c 1A44     		add	r2, r2, r3
 598 002e 1146     		mov	r1, r2	@ movhi
 599 0030 4901     		lsls	r1, r1, #5
 600 0032 8A1A     		subs	r2, r1, r2
 601 0034 5200     		lsls	r2, r2, #1
 602 0036 D21A     		subs	r2, r2, r3
 603 0038 1146     		mov	r1, r2	@ movhi
 604 003a C800     		lsls	r0, r1, #3
 605 003c 1146     		mov	r1, r2	@ movhi
 606 003e 0246     		mov	r2, r0	@ movhi
 607 0040 0A44     		add	r2, r2, r1
 608 0042 5200     		lsls	r2, r2, #1
 609 0044 1344     		add	r3, r3, r2
 610 0046 9BB2     		uxth	r3, r3
 611              		.loc 2 321 20
 612 0048 1BB2     		sxth	r3, r3
 613              		.loc 2 321 18
 614 004a FB82     		strh	r3, [r7, #22]	@ movhi
 322:Src/mc_interface.c ****     iqDrefTemp.q = (int16_t)((int16_t)IqdRef.q * (int16_t)CURRENT_CONV_FACTOR);
 615              		.loc 2 322 45
 616 004c D7ED017A 		vldr.32	s15, [r7, #4]
 617              		.loc 2 322 30
 618 0050 FDEEE77A 		vcvt.s32.f32	s15, s15
 619 0054 17EE903A 		vmov	r3, s15	@ int
 620 0058 1BB2     		sxth	r3, r3
 621 005a 9BB2     		uxth	r3, r3
 622              		.loc 2 322 48
 623 005c 1A46     		mov	r2, r3	@ movhi
 624 005e D200     		lsls	r2, r2, #3
 625 0060 1A44     		add	r2, r2, r3
 626 0062 1146     		mov	r1, r2	@ movhi
 627 0064 4901     		lsls	r1, r1, #5
 628 0066 8A1A     		subs	r2, r1, r2
 629 0068 5200     		lsls	r2, r2, #1
 630 006a D21A     		subs	r2, r2, r3
 631 006c 1146     		mov	r1, r2	@ movhi
 632 006e C800     		lsls	r0, r1, #3
 633 0070 1146     		mov	r1, r2	@ movhi
 634 0072 0246     		mov	r2, r0	@ movhi
 635 0074 0A44     		add	r2, r2, r1
 636 0076 5200     		lsls	r2, r2, #1
 637 0078 1344     		add	r3, r3, r2
 638 007a 9BB2     		uxth	r3, r3
 639              		.loc 2 322 20
 640 007c 1BB2     		sxth	r3, r3
 641              		.loc 2 322 18
 642 007e BB82     		strh	r3, [r7, #20]	@ movhi
 323:Src/mc_interface.c ****     MCI_SetCurrentReferences(pHandle, iqDrefTemp);
 643              		.loc 2 323 5
 644 0080 7969     		ldr	r1, [r7, #20]
 645 0082 F868     		ldr	r0, [r7, #12]
 646 0084 FFF7FEFF 		bl	MCI_SetCurrentReferences
 324:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
 325:Src/mc_interface.c ****   }
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 23


 326:Src/mc_interface.c **** #endif
 327:Src/mc_interface.c **** }
 647              		.loc 2 327 1
 648 0088 00BF     		nop
 649 008a 1837     		adds	r7, r7, #24
 650              	.LCFI42:
 651              		.cfi_def_cfa_offset 8
 652 008c BD46     		mov	sp, r7
 653              	.LCFI43:
 654              		.cfi_def_cfa_register 13
 655              		@ sp needed
 656 008e 80BD     		pop	{r7, pc}
 657              		.cfi_endproc
 658              	.LFE1096:
 660              		.section	.text.MCI_ExecPositionCommand,"ax",%progbits
 661              		.align	1
 662              		.weak	MCI_ExecPositionCommand
 663              		.syntax unified
 664              		.thumb
 665              		.thumb_func
 667              	MCI_ExecPositionCommand:
 668              	.LFB1097:
 328:Src/mc_interface.c **** 
 329:Src/mc_interface.c **** /**
 330:Src/mc_interface.c ****   * @brief  Programs a motor position ramp
 331:Src/mc_interface.c ****   *
 332:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
 333:Src/mc_interface.c ****   * @param  FinalPosition The desired rotor position in radians.
 334:Src/mc_interface.c ****   * @param  Duration The duration of the movement to reach the final position, in seconds.
 335:Src/mc_interface.c ****   *
 336:Src/mc_interface.c ****   *  This command is executed immediately if the target motor's state machine is in
 337:Src/mc_interface.c ****   * the #RUN state. Otherwise, it is buffered and its execution is delayed until This
 338:Src/mc_interface.c ****   * state is reached.
 339:Src/mc_interface.c ****   *
 340:Src/mc_interface.c ****   * Users can check the status of the command by calling the MCI_IsCommandAcknowledged()
 341:Src/mc_interface.c ****   * function.
 342:Src/mc_interface.c ****   */
 343:Src/mc_interface.c **** __weak void MCI_ExecPositionCommand(MCI_Handle_t *pHandle, float_t FinalPosition, float_t Duration)
 344:Src/mc_interface.c **** {
 669              		.loc 2 344 1
 670              		.cfi_startproc
 671              		@ args = 0, pretend = 0, frame = 24
 672              		@ frame_needed = 1, uses_anonymous_args = 0
 673 0000 80B5     		push	{r7, lr}
 674              	.LCFI44:
 675              		.cfi_def_cfa_offset 8
 676              		.cfi_offset 7, -8
 677              		.cfi_offset 14, -4
 678 0002 86B0     		sub	sp, sp, #24
 679              	.LCFI45:
 680              		.cfi_def_cfa_offset 32
 681 0004 00AF     		add	r7, sp, #0
 682              	.LCFI46:
 683              		.cfi_def_cfa_register 7
 684 0006 F860     		str	r0, [r7, #12]
 685 0008 87ED020A 		vstr.32	s0, [r7, #8]
 686 000c C7ED010A 		vstr.32	s1, [r7, #4]
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 24


 345:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
 346:Src/mc_interface.c ****   if (MC_NULL == pHandle)
 347:Src/mc_interface.c ****   {
 348:Src/mc_interface.c ****     /* Nothing to do */
 349:Src/mc_interface.c ****   }
 350:Src/mc_interface.c ****   else
 351:Src/mc_interface.c ****   {
 352:Src/mc_interface.c **** #endif
 353:Src/mc_interface.c ****     pHandle->pFOCVars->bDriveInput = INTERNAL;
 687              		.loc 2 353 12
 688 0010 FB68     		ldr	r3, [r7, #12]
 689 0012 5B68     		ldr	r3, [r3, #4]
 690              		.loc 2 353 36
 691 0014 0022     		movs	r2, #0
 692 0016 83F82420 		strb	r2, [r3, #36]
 354:Src/mc_interface.c ****     float_t currentPositionRad = (float_t)(SPD_GetMecAngle(STC_GetSpeedSensor(pHandle->pSTC))) / RA
 693              		.loc 2 354 60
 694 001a FB68     		ldr	r3, [r7, #12]
 695 001c 1B68     		ldr	r3, [r3]
 696 001e 1846     		mov	r0, r3
 697 0020 FFF7FEFF 		bl	STC_GetSpeedSensor
 698 0024 0346     		mov	r3, r0
 699              		.loc 2 354 44
 700 0026 1846     		mov	r0, r3
 701 0028 FFF7FEFF 		bl	SPD_GetMecAngle
 702 002c 07EE900A 		vmov	s15, r0	@ int
 703              		.loc 2 354 34
 704 0030 B8EEE77A 		vcvt.f32.s32	s14, s15
 705              		.loc 2 354 13
 706 0034 DFED166A 		vldr.32	s13, .L19
 707 0038 C7EE267A 		vdiv.f32	s15, s14, s13
 708 003c C7ED057A 		vstr.32	s15, [r7, #20]
 355:Src/mc_interface.c ****     if (Duration > 0)
 709              		.loc 2 355 8
 710 0040 D7ED017A 		vldr.32	s15, [r7, #4]
 711 0044 F5EEC07A 		vcmpe.f32	s15, #0
 712 0048 F1EE10FA 		vmrs	APSR_nzcv, FPSCR
 713 004c 11DD     		ble	.L18
 356:Src/mc_interface.c ****     {
 357:Src/mc_interface.c ****       TC_MoveCommand(pHandle->pPosCtrl, currentPositionRad, FinalPosition - currentPositionRad, Dur
 714              		.loc 2 357 7
 715 004e FB68     		ldr	r3, [r7, #12]
 716 0050 1B69     		ldr	r3, [r3, #16]
 717 0052 97ED027A 		vldr.32	s14, [r7, #8]
 718 0056 D7ED057A 		vldr.32	s15, [r7, #20]
 719 005a 77EE677A 		vsub.f32	s15, s14, s15
 720 005e 97ED011A 		vldr.32	s2, [r7, #4]
 721 0062 F0EE670A 		vmov.f32	s1, s15
 722 0066 97ED050A 		vldr.32	s0, [r7, #20]
 723 006a 1846     		mov	r0, r3
 724 006c FFF7FEFF 		bl	TC_MoveCommand
 725 0070 06E0     		b	.L16
 726              	.L18:
 358:Src/mc_interface.c ****     }
 359:Src/mc_interface.c ****     else
 360:Src/mc_interface.c ****     {
 361:Src/mc_interface.c ****       TC_FollowCommand(pHandle->pPosCtrl, FinalPosition);
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 25


 727              		.loc 2 361 7
 728 0072 FB68     		ldr	r3, [r7, #12]
 729 0074 1B69     		ldr	r3, [r3, #16]
 730 0076 97ED020A 		vldr.32	s0, [r7, #8]
 731 007a 1846     		mov	r0, r3
 732 007c FFF7FEFF 		bl	TC_FollowCommand
 733              	.L16:
 362:Src/mc_interface.c ****     }
 363:Src/mc_interface.c **** 
 364:Src/mc_interface.c ****     pHandle->LastModalitySetByUser = MCM_TORQUE_MODE;
 734              		.loc 2 364 36
 735 0080 FB68     		ldr	r3, [r7, #12]
 736 0082 0422     		movs	r2, #4
 737 0084 83F82D20 		strb	r2, [r3, #45]
 365:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
 366:Src/mc_interface.c ****   }
 367:Src/mc_interface.c **** #endif
 368:Src/mc_interface.c **** }
 738              		.loc 2 368 1
 739 0088 00BF     		nop
 740 008a 1837     		adds	r7, r7, #24
 741              	.LCFI47:
 742              		.cfi_def_cfa_offset 8
 743 008c BD46     		mov	sp, r7
 744              	.LCFI48:
 745              		.cfi_def_cfa_register 13
 746              		@ sp needed
 747 008e 80BD     		pop	{r7, pc}
 748              	.L20:
 749              		.align	2
 750              	.L19:
 751 0090 83F92246 		.word	1176697219
 752              		.cfi_endproc
 753              	.LFE1097:
 755              		.section	.text.MCI_StartMotor,"ax",%progbits
 756              		.align	1
 757              		.weak	MCI_StartMotor
 758              		.syntax unified
 759              		.thumb
 760              		.thumb_func
 762              	MCI_StartMotor:
 763              	.LFB1098:
 369:Src/mc_interface.c **** 
 370:Src/mc_interface.c **** /**
 371:Src/mc_interface.c ****   * @brief  Initiates a motor startup procedure
 372:Src/mc_interface.c ****   *
 373:Src/mc_interface.c ****   * @param  pHandle Handle on the target motor interface structure
 374:Src/mc_interface.c ****   * @retval Returns true if the command is successfully executed;
 375:Src/mc_interface.c ****   *         returns false otherwise
 376:Src/mc_interface.c ****   *
 377:Src/mc_interface.c ****   *  If the state machine of target the motor is in #IDLE state the command is
 378:Src/mc_interface.c ****   * executed instantaneously otherwise it is discarded. Users can check
 379:Src/mc_interface.c ****   * the return value of the function to get its status. The state of the motor
 380:Src/mc_interface.c ****   * can be queried with the MCI_GetSTMState() function.
 381:Src/mc_interface.c ****   *
 382:Src/mc_interface.c ****   * Before calling MCI_StartMotor() it is mandatory to execute one of the
 383:Src/mc_interface.c ****   * following commands, in order to set a torque or a speed reference
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 26


 384:Src/mc_interface.c ****   * otherwise the behavior of the motor when it reaches the #RUN state will
 385:Src/mc_interface.c ****   * be unpredictable:
 386:Src/mc_interface.c ****   *  - MCI_ExecSpeedRamp
 387:Src/mc_interface.c ****   *  - MCI_ExecTorqueRamp
 388:Src/mc_interface.c ****   *  - MCI_SetCurrentReferences
 389:Src/mc_interface.c ****   *
 390:Src/mc_interface.c ****   * If the offsets of the current measurement circuitry offsets are not known yet,
 391:Src/mc_interface.c ****   * an offset calibration procedure is executed to measure them prior to acutally
 392:Src/mc_interface.c ****   * starting up the motor.
 393:Src/mc_interface.c ****   *
 394:Src/mc_interface.c ****   * @note The MCI_StartMotor command only triggers the execution of the start-up
 395:Src/mc_interface.c ****   * procedure (or eventually the offset calibration procedure) and returns
 396:Src/mc_interface.c ****   * immediately after. It is not blocking the execution of the application until
 397:Src/mc_interface.c ****   * the motor is indeed running in steady state. If the application needs to wait
 398:Src/mc_interface.c ****   * for the motor to be running in steady state, the application has to check the
 399:Src/mc_interface.c ****   * state machine of the motor and verify that the #RUN state has been reached.
 400:Src/mc_interface.c ****   * Note also that if the startup sequence fails the #RUN state may never be reached.
 401:Src/mc_interface.c ****   */
 402:Src/mc_interface.c **** __weak bool MCI_StartMotor(MCI_Handle_t *pHandle)
 403:Src/mc_interface.c **** {
 764              		.loc 2 403 1
 765              		.cfi_startproc
 766              		@ args = 0, pretend = 0, frame = 16
 767              		@ frame_needed = 1, uses_anonymous_args = 0
 768 0000 80B5     		push	{r7, lr}
 769              	.LCFI49:
 770              		.cfi_def_cfa_offset 8
 771              		.cfi_offset 7, -8
 772              		.cfi_offset 14, -4
 773 0002 84B0     		sub	sp, sp, #16
 774              	.LCFI50:
 775              		.cfi_def_cfa_offset 24
 776 0004 00AF     		add	r7, sp, #0
 777              	.LCFI51:
 778              		.cfi_def_cfa_register 7
 779 0006 7860     		str	r0, [r7, #4]
 404:Src/mc_interface.c ****   bool retVal = false;
 780              		.loc 2 404 8
 781 0008 0023     		movs	r3, #0
 782 000a FB73     		strb	r3, [r7, #15]
 405:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
 406:Src/mc_interface.c ****   if (MC_NULL == pHandle)
 407:Src/mc_interface.c ****   {
 408:Src/mc_interface.c ****     /* Nothing to do */
 409:Src/mc_interface.c ****   }
 410:Src/mc_interface.c ****   else
 411:Src/mc_interface.c ****   {
 412:Src/mc_interface.c **** #endif
 413:Src/mc_interface.c ****     if ((IDLE == MCI_GetSTMState(pHandle)) &&
 783              		.loc 2 413 18
 784 000c 7868     		ldr	r0, [r7, #4]
 785 000e FFF7FEFF 		bl	MCI_GetSTMState
 786 0012 0346     		mov	r3, r0
 787              		.loc 2 413 8
 788 0014 002B     		cmp	r3, #0
 789 0016 15D1     		bne	.L22
 414:Src/mc_interface.c ****         (MC_NO_FAULTS == MCI_GetOccurredFaults(pHandle)) &&
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 27


 790              		.loc 2 414 26 discriminator 1
 791 0018 7868     		ldr	r0, [r7, #4]
 792 001a FFF7FEFF 		bl	MCI_GetOccurredFaults
 793 001e 0346     		mov	r3, r0
 413:Src/mc_interface.c ****         (MC_NO_FAULTS == MCI_GetOccurredFaults(pHandle)) &&
 794              		.loc 2 413 44 discriminator 1
 795 0020 002B     		cmp	r3, #0
 796 0022 0FD1     		bne	.L22
 415:Src/mc_interface.c ****         (MC_NO_FAULTS == MCI_GetCurrentFaults(pHandle)))
 797              		.loc 2 415 26
 798 0024 7868     		ldr	r0, [r7, #4]
 799 0026 FFF7FEFF 		bl	MCI_GetCurrentFaults
 800 002a 0346     		mov	r3, r0
 414:Src/mc_interface.c ****         (MC_NO_FAULTS == MCI_GetOccurredFaults(pHandle)) &&
 801              		.loc 2 414 58
 802 002c 002B     		cmp	r3, #0
 803 002e 09D1     		bne	.L22
 416:Src/mc_interface.c ****     {
 417:Src/mc_interface.c ****       pHandle->DirectCommand = MCI_START;
 804              		.loc 2 417 30
 805 0030 7B68     		ldr	r3, [r7, #4]
 806 0032 0122     		movs	r2, #1
 807 0034 83F82620 		strb	r2, [r3, #38]
 418:Src/mc_interface.c ****       pHandle->CommandState = MCI_COMMAND_NOT_ALREADY_EXECUTED;
 808              		.loc 2 418 29
 809 0038 7B68     		ldr	r3, [r7, #4]
 810 003a 0122     		movs	r2, #1
 811 003c 83F82C20 		strb	r2, [r3, #44]
 419:Src/mc_interface.c ****       retVal = true;
 812              		.loc 2 419 14
 813 0040 0123     		movs	r3, #1
 814 0042 FB73     		strb	r3, [r7, #15]
 815              	.L22:
 420:Src/mc_interface.c ****     }
 421:Src/mc_interface.c ****     else
 422:Src/mc_interface.c ****     {
 423:Src/mc_interface.c ****       /* Reject the command as the condition are not met */
 424:Src/mc_interface.c ****     }
 425:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
 426:Src/mc_interface.c ****   }
 427:Src/mc_interface.c **** #endif
 428:Src/mc_interface.c ****   return (retVal);
 816              		.loc 2 428 10
 817 0044 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 429:Src/mc_interface.c **** }
 818              		.loc 2 429 1
 819 0046 1846     		mov	r0, r3
 820 0048 1037     		adds	r7, r7, #16
 821              	.LCFI52:
 822              		.cfi_def_cfa_offset 8
 823 004a BD46     		mov	sp, r7
 824              	.LCFI53:
 825              		.cfi_def_cfa_register 13
 826              		@ sp needed
 827 004c 80BD     		pop	{r7, pc}
 828              		.cfi_endproc
 829              	.LFE1098:
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 28


 831              		.section	.text.MCI_StartWithPolarizationMotor,"ax",%progbits
 832              		.align	1
 833              		.weak	MCI_StartWithPolarizationMotor
 834              		.syntax unified
 835              		.thumb
 836              		.thumb_func
 838              	MCI_StartWithPolarizationMotor:
 839              	.LFB1099:
 430:Src/mc_interface.c **** 
 431:Src/mc_interface.c **** /**
 432:Src/mc_interface.c ****   * @brief  Initiates a motor startup procedure preceded by an offset
 433:Src/mc_interface.c ****   *         calibration procedure
 434:Src/mc_interface.c ****   *
 435:Src/mc_interface.c ****   * @param  pHandle Handle on the target motor interface structure
 436:Src/mc_interface.c ****   * @retval Returns true if the command is successfully executed;
 437:Src/mc_interface.c ****   *         returns false otherwise
 438:Src/mc_interface.c ****   *
 439:Src/mc_interface.c ****   *  If the state machine of target the motor is in #IDLE state the command is
 440:Src/mc_interface.c ****   * executed instantaneously otherwise it is discarded. Users can check
 441:Src/mc_interface.c ****   * the return value of the function to get its status. The state of the motor
 442:Src/mc_interface.c ****   * can be queried with the MCI_GetSTMState() function.
 443:Src/mc_interface.c ****   *
 444:Src/mc_interface.c ****   * Before calling MCI_StartMotor() it is mandatory to execute one of the
 445:Src/mc_interface.c ****   * following commands, in order to set a torque or a speed reference
 446:Src/mc_interface.c ****   * otherwise the behavior of the motor when it reaches the #RUN state will
 447:Src/mc_interface.c ****   * be unpredictable:
 448:Src/mc_interface.c ****   *  - MCI_ExecSpeedRamp
 449:Src/mc_interface.c ****   *  - MCI_ExecTorqueRamp
 450:Src/mc_interface.c ****   *  - MCI_SetCurrentReferences
 451:Src/mc_interface.c ****   *
 452:Src/mc_interface.c ****   * Whether the current measurement circuitry offsets are known or not, an
 453:Src/mc_interface.c ****   * offset calibration procedure is executed to (re)measure them. Once it has
 454:Src/mc_interface.c ****   * completed, the start up procedure of the motor is executed.
 455:Src/mc_interface.c ****   *
 456:Src/mc_interface.c ****   * @note The MCI_StartMotor command only triggers the execution of the start-up
 457:Src/mc_interface.c ****   * procedure (or eventually the offset calibration procedure) and returns
 458:Src/mc_interface.c ****   * immediately after. It is not blocking the execution of the application until
 459:Src/mc_interface.c ****   * the motor is indeed running in steady state. If the application needs to wait
 460:Src/mc_interface.c ****   * for the motor to be running in steady state, the application has to check the
 461:Src/mc_interface.c ****   * state machine of the motor and verify that the #RUN state has been reached.
 462:Src/mc_interface.c ****   * Note also that if the startup sequence fails the #RUN state may never be reached.
 463:Src/mc_interface.c ****   */
 464:Src/mc_interface.c **** __weak bool MCI_StartWithPolarizationMotor(MCI_Handle_t* pHandle)
 465:Src/mc_interface.c **** {
 840              		.loc 2 465 1
 841              		.cfi_startproc
 842              		@ args = 0, pretend = 0, frame = 16
 843              		@ frame_needed = 1, uses_anonymous_args = 0
 844 0000 80B5     		push	{r7, lr}
 845              	.LCFI54:
 846              		.cfi_def_cfa_offset 8
 847              		.cfi_offset 7, -8
 848              		.cfi_offset 14, -4
 849 0002 84B0     		sub	sp, sp, #16
 850              	.LCFI55:
 851              		.cfi_def_cfa_offset 24
 852 0004 00AF     		add	r7, sp, #0
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 29


 853              	.LCFI56:
 854              		.cfi_def_cfa_register 7
 855 0006 7860     		str	r0, [r7, #4]
 466:Src/mc_interface.c ****   bool retVal = true;
 856              		.loc 2 466 8
 857 0008 0123     		movs	r3, #1
 858 000a FB73     		strb	r3, [r7, #15]
 467:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
 468:Src/mc_interface.c ****   if (MC_NULL == pHandle)
 469:Src/mc_interface.c ****   {
 470:Src/mc_interface.c ****     /* Nothing to do */
 471:Src/mc_interface.c ****   }
 472:Src/mc_interface.c ****   else
 473:Src/mc_interface.c ****   {
 474:Src/mc_interface.c **** #endif
 475:Src/mc_interface.c ****     if ((IDLE == MCI_GetSTMState(pHandle)) &&
 859              		.loc 2 475 18
 860 000c 7868     		ldr	r0, [r7, #4]
 861 000e FFF7FEFF 		bl	MCI_GetSTMState
 862 0012 0346     		mov	r3, r0
 863              		.loc 2 475 8
 864 0014 002B     		cmp	r3, #0
 865 0016 1AD1     		bne	.L25
 476:Src/mc_interface.c ****         (MC_NO_FAULTS == MCI_GetOccurredFaults(pHandle)) &&
 866              		.loc 2 476 26 discriminator 1
 867 0018 7868     		ldr	r0, [r7, #4]
 868 001a FFF7FEFF 		bl	MCI_GetOccurredFaults
 869 001e 0346     		mov	r3, r0
 475:Src/mc_interface.c ****         (MC_NO_FAULTS == MCI_GetOccurredFaults(pHandle)) &&
 870              		.loc 2 475 44 discriminator 1
 871 0020 002B     		cmp	r3, #0
 872 0022 14D1     		bne	.L25
 477:Src/mc_interface.c ****         (MC_NO_FAULTS == MCI_GetCurrentFaults(pHandle)))
 873              		.loc 2 477 26
 874 0024 7868     		ldr	r0, [r7, #4]
 875 0026 FFF7FEFF 		bl	MCI_GetCurrentFaults
 876 002a 0346     		mov	r3, r0
 476:Src/mc_interface.c ****         (MC_NO_FAULTS == MCI_GetOccurredFaults(pHandle)) &&
 877              		.loc 2 476 58
 878 002c 002B     		cmp	r3, #0
 879 002e 0ED1     		bne	.L25
 478:Src/mc_interface.c ****     {
 479:Src/mc_interface.c ****       pHandle->DirectCommand = MCI_START;
 880              		.loc 2 479 30
 881 0030 7B68     		ldr	r3, [r7, #4]
 882 0032 0122     		movs	r2, #1
 883 0034 83F82620 		strb	r2, [r3, #38]
 480:Src/mc_interface.c ****       pHandle->CommandState = MCI_COMMAND_NOT_ALREADY_EXECUTED;
 884              		.loc 2 480 29
 885 0038 7B68     		ldr	r3, [r7, #4]
 886 003a 0122     		movs	r2, #1
 887 003c 83F82C20 		strb	r2, [r3, #44]
 481:Src/mc_interface.c ****       pHandle->pPWM->offsetCalibStatus = false;
 888              		.loc 2 481 14
 889 0040 7B68     		ldr	r3, [r7, #4]
 890 0042 9B68     		ldr	r3, [r3, #8]
 891              		.loc 2 481 40
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 30


 892 0044 0022     		movs	r2, #0
 893 0046 83F88120 		strb	r2, [r3, #129]
 482:Src/mc_interface.c ****       retVal = false;
 894              		.loc 2 482 14
 895 004a 0023     		movs	r3, #0
 896 004c FB73     		strb	r3, [r7, #15]
 897              	.L25:
 483:Src/mc_interface.c ****   }
 484:Src/mc_interface.c ****   else
 485:Src/mc_interface.c ****   {
 486:Src/mc_interface.c ****     /* Reject the command as the condition are not met */
 487:Src/mc_interface.c ****   }
 488:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
 489:Src/mc_interface.c ****   }
 490:Src/mc_interface.c **** #endif
 491:Src/mc_interface.c ****   return (retVal);
 898              		.loc 2 491 10
 899 004e FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 492:Src/mc_interface.c **** }
 900              		.loc 2 492 1
 901 0050 1846     		mov	r0, r3
 902 0052 1037     		adds	r7, r7, #16
 903              	.LCFI57:
 904              		.cfi_def_cfa_offset 8
 905 0054 BD46     		mov	sp, r7
 906              	.LCFI58:
 907              		.cfi_def_cfa_register 13
 908              		@ sp needed
 909 0056 80BD     		pop	{r7, pc}
 910              		.cfi_endproc
 911              	.LFE1099:
 913              		.section	.text.MCI_StartOffsetMeasurments,"ax",%progbits
 914              		.align	1
 915              		.weak	MCI_StartOffsetMeasurments
 916              		.syntax unified
 917              		.thumb
 918              		.thumb_func
 920              	MCI_StartOffsetMeasurments:
 921              	.LFB1100:
 493:Src/mc_interface.c **** 
 494:Src/mc_interface.c **** /**
 495:Src/mc_interface.c ****   * @brief  This is a user command used to begin the phase offset calibration
 496:Src/mc_interface.c ****   *         procedure. If the state machine is in IDLE state the command is executed
 497:Src/mc_interface.c ****   *         instantaneously otherwise the command is discarded. User must take
 498:Src/mc_interface.c ****   *         care of this possibility by checking the return value.\n
 499:Src/mc_interface.c ****   *         <B>Note:</B> The MCI_StartOffsetMeasurments command is used to begin phase
 500:Src/mc_interface.c ****   *         offset calibration procedure moving the state machine from IDLE state to
 501:Src/mc_interface.c ****   *         OFFSET_CALIB. The command MCI_StartOffsetMeasurments is not blocking
 502:Src/mc_interface.c ****   *         the execution of project until the measurments are done; to do this, the user
 503:Src/mc_interface.c ****   *         have to check the state machine and verify that the IDLE state (or
 504:Src/mc_interface.c ****   *         any other state) has been reached.
 505:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
 506:Src/mc_interface.c ****   * @retval bool It returns true if the command is successfully executed
 507:Src/mc_interface.c ****   *         otherwise it return false.
 508:Src/mc_interface.c ****   */
 509:Src/mc_interface.c **** __weak bool MCI_StartOffsetMeasurments(MCI_Handle_t *pHandle)
 510:Src/mc_interface.c **** {
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 31


 922              		.loc 2 510 1
 923              		.cfi_startproc
 924              		@ args = 0, pretend = 0, frame = 16
 925              		@ frame_needed = 1, uses_anonymous_args = 0
 926 0000 80B5     		push	{r7, lr}
 927              	.LCFI59:
 928              		.cfi_def_cfa_offset 8
 929              		.cfi_offset 7, -8
 930              		.cfi_offset 14, -4
 931 0002 84B0     		sub	sp, sp, #16
 932              	.LCFI60:
 933              		.cfi_def_cfa_offset 24
 934 0004 00AF     		add	r7, sp, #0
 935              	.LCFI61:
 936              		.cfi_def_cfa_register 7
 937 0006 7860     		str	r0, [r7, #4]
 511:Src/mc_interface.c ****   bool retVal = false;
 938              		.loc 2 511 8
 939 0008 0023     		movs	r3, #0
 940 000a FB73     		strb	r3, [r7, #15]
 512:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
 513:Src/mc_interface.c ****   if (MC_NULL == pHandle)
 514:Src/mc_interface.c ****   {
 515:Src/mc_interface.c ****     /* Nothing to do */
 516:Src/mc_interface.c ****   }
 517:Src/mc_interface.c ****   else
 518:Src/mc_interface.c ****   {
 519:Src/mc_interface.c **** #endif
 520:Src/mc_interface.c ****     if ((IDLE == MCI_GetSTMState(pHandle)) &&
 941              		.loc 2 520 18
 942 000c 7868     		ldr	r0, [r7, #4]
 943 000e FFF7FEFF 		bl	MCI_GetSTMState
 944 0012 0346     		mov	r3, r0
 945              		.loc 2 520 8
 946 0014 002B     		cmp	r3, #0
 947 0016 16D1     		bne	.L28
 521:Src/mc_interface.c ****         (MC_NO_FAULTS == MCI_GetOccurredFaults(pHandle)) &&
 948              		.loc 2 521 26 discriminator 1
 949 0018 7868     		ldr	r0, [r7, #4]
 950 001a FFF7FEFF 		bl	MCI_GetOccurredFaults
 951 001e 0346     		mov	r3, r0
 520:Src/mc_interface.c ****         (MC_NO_FAULTS == MCI_GetOccurredFaults(pHandle)) &&
 952              		.loc 2 520 44 discriminator 1
 953 0020 002B     		cmp	r3, #0
 954 0022 10D1     		bne	.L28
 522:Src/mc_interface.c ****         (MC_NO_FAULTS == MCI_GetCurrentFaults(pHandle)))
 955              		.loc 2 522 26
 956 0024 7868     		ldr	r0, [r7, #4]
 957 0026 FFF7FEFF 		bl	MCI_GetCurrentFaults
 958 002a 0346     		mov	r3, r0
 521:Src/mc_interface.c ****         (MC_NO_FAULTS == MCI_GetOccurredFaults(pHandle)) &&
 959              		.loc 2 521 58
 960 002c 002B     		cmp	r3, #0
 961 002e 0AD1     		bne	.L28
 523:Src/mc_interface.c ****     {
 524:Src/mc_interface.c ****       pHandle->DirectCommand = MCI_MEASURE_OFFSETS;
 962              		.loc 2 524 30
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 32


 963 0030 7B68     		ldr	r3, [r7, #4]
 964 0032 0322     		movs	r2, #3
 965 0034 83F82620 		strb	r2, [r3, #38]
 525:Src/mc_interface.c ****       pHandle->pPWM->offsetCalibStatus = false;
 966              		.loc 2 525 14
 967 0038 7B68     		ldr	r3, [r7, #4]
 968 003a 9B68     		ldr	r3, [r3, #8]
 969              		.loc 2 525 40
 970 003c 0022     		movs	r2, #0
 971 003e 83F88120 		strb	r2, [r3, #129]
 526:Src/mc_interface.c ****       retVal = true;
 972              		.loc 2 526 14
 973 0042 0123     		movs	r3, #1
 974 0044 FB73     		strb	r3, [r7, #15]
 975              	.L28:
 527:Src/mc_interface.c ****     }
 528:Src/mc_interface.c ****     else
 529:Src/mc_interface.c ****     {
 530:Src/mc_interface.c ****       /* Reject the command as the condition are not met */
 531:Src/mc_interface.c ****     }
 532:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
 533:Src/mc_interface.c ****   }
 534:Src/mc_interface.c **** #endif
 535:Src/mc_interface.c ****   return (retVal);
 976              		.loc 2 535 10
 977 0046 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 536:Src/mc_interface.c **** }
 978              		.loc 2 536 1
 979 0048 1846     		mov	r0, r3
 980 004a 1037     		adds	r7, r7, #16
 981              	.LCFI62:
 982              		.cfi_def_cfa_offset 8
 983 004c BD46     		mov	sp, r7
 984              	.LCFI63:
 985              		.cfi_def_cfa_register 13
 986              		@ sp needed
 987 004e 80BD     		pop	{r7, pc}
 988              		.cfi_endproc
 989              	.LFE1100:
 991              		.section	.text.MCI_GetCalibratedOffsetsMotor,"ax",%progbits
 992              		.align	1
 993              		.weak	MCI_GetCalibratedOffsetsMotor
 994              		.syntax unified
 995              		.thumb
 996              		.thumb_func
 998              	MCI_GetCalibratedOffsetsMotor:
 999              	.LFB1101:
 537:Src/mc_interface.c **** 
 538:Src/mc_interface.c **** /**
 539:Src/mc_interface.c ****   * @brief  Gets the phase current measurement offset values
 540:Src/mc_interface.c ****   *
 541:Src/mc_interface.c ****   * The offset values are written in the PolarizationOffsets structure provided that they
 542:Src/mc_interface.c ****   * have been previously provided for the Motor Control subsystem or measured by it.
 543:Src/mc_interface.c ****   *
 544:Src/mc_interface.c ****   * If the offset have not previously been provided to the Motor Control subsystem or
 545:Src/mc_interface.c ****   * if it has not measured them the function returns false and nothing is written in the
 546:Src/mc_interface.c ****   * PolarizationOffsets structure.
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 33


 547:Src/mc_interface.c ****   *
 548:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
 549:Src/mc_interface.c ****   * @param  PolarizationOffsets Pointer on ploarization offset structure in which offsets will be w
 550:Src/mc_interface.c ****   * @retval returns true if the command is successfully executed; returns false otherwise.
 551:Src/mc_interface.c ****   */
 552:Src/mc_interface.c **** __weak bool MCI_GetCalibratedOffsetsMotor(MCI_Handle_t *pHandle, PolarizationOffsets_t *Polarizatio
 553:Src/mc_interface.c **** {
 1000              		.loc 2 553 1
 1001              		.cfi_startproc
 1002              		@ args = 0, pretend = 0, frame = 16
 1003              		@ frame_needed = 1, uses_anonymous_args = 0
 1004 0000 80B5     		push	{r7, lr}
 1005              	.LCFI64:
 1006              		.cfi_def_cfa_offset 8
 1007              		.cfi_offset 7, -8
 1008              		.cfi_offset 14, -4
 1009 0002 84B0     		sub	sp, sp, #16
 1010              	.LCFI65:
 1011              		.cfi_def_cfa_offset 24
 1012 0004 00AF     		add	r7, sp, #0
 1013              	.LCFI66:
 1014              		.cfi_def_cfa_register 7
 1015 0006 7860     		str	r0, [r7, #4]
 1016 0008 3960     		str	r1, [r7]
 554:Src/mc_interface.c ****   bool retVal = false;
 1017              		.loc 2 554 8
 1018 000a 0023     		movs	r3, #0
 1019 000c FB73     		strb	r3, [r7, #15]
 555:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
 556:Src/mc_interface.c ****   if (MC_NULL == pHandle)
 557:Src/mc_interface.c ****   {
 558:Src/mc_interface.c ****     /* Nothing to do */
 559:Src/mc_interface.c ****   }
 560:Src/mc_interface.c ****   else
 561:Src/mc_interface.c ****   {
 562:Src/mc_interface.c **** #endif
 563:Src/mc_interface.c ****     if (pHandle->pPWM->offsetCalibStatus == true)
 1020              		.loc 2 563 16
 1021 000e 7B68     		ldr	r3, [r7, #4]
 1022 0010 9B68     		ldr	r3, [r3, #8]
 1023              		.loc 2 563 22
 1024 0012 93F88130 		ldrb	r3, [r3, #129]	@ zero_extendqisi2
 1025              		.loc 2 563 8
 1026 0016 002B     		cmp	r3, #0
 1027 0018 07D0     		beq	.L31
 564:Src/mc_interface.c ****     {
 565:Src/mc_interface.c ****       PWMC_GetOffsetCalib(pHandle->pPWM, PolarizationOffsets);
 1028              		.loc 2 565 7
 1029 001a 7B68     		ldr	r3, [r7, #4]
 1030 001c 9B68     		ldr	r3, [r3, #8]
 1031 001e 3968     		ldr	r1, [r7]
 1032 0020 1846     		mov	r0, r3
 1033 0022 FFF7FEFF 		bl	PWMC_GetOffsetCalib
 566:Src/mc_interface.c ****       retVal = true;
 1034              		.loc 2 566 14
 1035 0026 0123     		movs	r3, #1
 1036 0028 FB73     		strb	r3, [r7, #15]
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 34


 1037              	.L31:
 567:Src/mc_interface.c ****     }
 568:Src/mc_interface.c ****     else
 569:Src/mc_interface.c ****     {
 570:Src/mc_interface.c ****       /* Reject the command as the condition are not met */
 571:Src/mc_interface.c ****     }
 572:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
 573:Src/mc_interface.c ****   }
 574:Src/mc_interface.c **** #endif
 575:Src/mc_interface.c **** 
 576:Src/mc_interface.c ****   return(retVal);
 1038              		.loc 2 576 9
 1039 002a FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 577:Src/mc_interface.c **** }
 1040              		.loc 2 577 1
 1041 002c 1846     		mov	r0, r3
 1042 002e 1037     		adds	r7, r7, #16
 1043              	.LCFI67:
 1044              		.cfi_def_cfa_offset 8
 1045 0030 BD46     		mov	sp, r7
 1046              	.LCFI68:
 1047              		.cfi_def_cfa_register 13
 1048              		@ sp needed
 1049 0032 80BD     		pop	{r7, pc}
 1050              		.cfi_endproc
 1051              	.LFE1101:
 1053              		.section	.text.MCI_SetCalibratedOffsetsMotor,"ax",%progbits
 1054              		.align	1
 1055              		.weak	MCI_SetCalibratedOffsetsMotor
 1056              		.syntax unified
 1057              		.thumb
 1058              		.thumb_func
 1060              	MCI_SetCalibratedOffsetsMotor:
 1061              	.LFB1102:
 578:Src/mc_interface.c **** 
 579:Src/mc_interface.c **** /**
 580:Src/mc_interface.c ****   * @brief  Sets the phase current measurement offset values
 581:Src/mc_interface.c ****   *
 582:Src/mc_interface.c ****   * If the state machine is in IDLE state the command is executed
 583:Src/mc_interface.c ****   * instantaneously otherwise the command is discarded. User must take
 584:Src/mc_interface.c ****   * care of this possibility by checking the return value.
 585:Src/mc_interface.c ****   *
 586:Src/mc_interface.c ****   * @note The MCI_SetCalibratedOffsetsMotor command is used to set the phase
 587:Src/mc_interface.c ****   *  offset values . The command MCI_SetCalibratedOffsetsMotor is not blocking
 588:Src/mc_interface.c ****   * the execution of project until the measurments are done; to do this, the user
 589:Src/mc_interface.c ****   * have to check the state machine and verify that the IDLE state (or
 590:Src/mc_interface.c ****   * any other state) has been reached.
 591:Src/mc_interface.c ****   *
 592:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
 593:Src/mc_interface.c ****   * @param  PolarizationOffsets Pointer on ploarization offset structure that contains phase A,
 594:Src/mc_interface.c ****   *         and C values.
 595:Src/mc_interface.c ****   * @retval Returns true if the command is successfully executed
 596:Src/mc_interface.c ****   *         otherwise it return false.
 597:Src/mc_interface.c ****   */
 598:Src/mc_interface.c **** __weak bool MCI_SetCalibratedOffsetsMotor(MCI_Handle_t *pHandle, PolarizationOffsets_t *Polarizatio
 599:Src/mc_interface.c **** {
 1062              		.loc 2 599 1
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 35


 1063              		.cfi_startproc
 1064              		@ args = 0, pretend = 0, frame = 16
 1065              		@ frame_needed = 1, uses_anonymous_args = 0
 1066 0000 80B5     		push	{r7, lr}
 1067              	.LCFI69:
 1068              		.cfi_def_cfa_offset 8
 1069              		.cfi_offset 7, -8
 1070              		.cfi_offset 14, -4
 1071 0002 84B0     		sub	sp, sp, #16
 1072              	.LCFI70:
 1073              		.cfi_def_cfa_offset 24
 1074 0004 00AF     		add	r7, sp, #0
 1075              	.LCFI71:
 1076              		.cfi_def_cfa_register 7
 1077 0006 7860     		str	r0, [r7, #4]
 1078 0008 3960     		str	r1, [r7]
 600:Src/mc_interface.c ****   bool retVal = false;
 1079              		.loc 2 600 8
 1080 000a 0023     		movs	r3, #0
 1081 000c FB73     		strb	r3, [r7, #15]
 601:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
 602:Src/mc_interface.c ****   if (MC_NULL == pHandle)
 603:Src/mc_interface.c ****   {
 604:Src/mc_interface.c ****     /* Nothing to do */
 605:Src/mc_interface.c ****   }
 606:Src/mc_interface.c ****   else
 607:Src/mc_interface.c ****   {
 608:Src/mc_interface.c **** #endif
 609:Src/mc_interface.c ****     if ((IDLE == MCI_GetSTMState(pHandle)) &&
 1082              		.loc 2 609 18
 1083 000e 7868     		ldr	r0, [r7, #4]
 1084 0010 FFF7FEFF 		bl	MCI_GetSTMState
 1085 0014 0346     		mov	r3, r0
 1086              		.loc 2 609 8
 1087 0016 002B     		cmp	r3, #0
 1088 0018 18D1     		bne	.L34
 610:Src/mc_interface.c ****         (MC_NO_FAULTS == MCI_GetOccurredFaults(pHandle)) &&
 1089              		.loc 2 610 26 discriminator 1
 1090 001a 7868     		ldr	r0, [r7, #4]
 1091 001c FFF7FEFF 		bl	MCI_GetOccurredFaults
 1092 0020 0346     		mov	r3, r0
 609:Src/mc_interface.c ****         (MC_NO_FAULTS == MCI_GetOccurredFaults(pHandle)) &&
 1093              		.loc 2 609 44 discriminator 1
 1094 0022 002B     		cmp	r3, #0
 1095 0024 12D1     		bne	.L34
 611:Src/mc_interface.c ****         (MC_NO_FAULTS == MCI_GetCurrentFaults(pHandle)))
 1096              		.loc 2 611 26
 1097 0026 7868     		ldr	r0, [r7, #4]
 1098 0028 FFF7FEFF 		bl	MCI_GetCurrentFaults
 1099 002c 0346     		mov	r3, r0
 610:Src/mc_interface.c ****         (MC_NO_FAULTS == MCI_GetOccurredFaults(pHandle)) &&
 1100              		.loc 2 610 58
 1101 002e 002B     		cmp	r3, #0
 1102 0030 0CD1     		bne	.L34
 612:Src/mc_interface.c ****     {
 613:Src/mc_interface.c ****       PWMC_SetOffsetCalib(pHandle->pPWM, PolarizationOffsets);
 1103              		.loc 2 613 7
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 36


 1104 0032 7B68     		ldr	r3, [r7, #4]
 1105 0034 9B68     		ldr	r3, [r3, #8]
 1106 0036 3968     		ldr	r1, [r7]
 1107 0038 1846     		mov	r0, r3
 1108 003a FFF7FEFF 		bl	PWMC_SetOffsetCalib
 614:Src/mc_interface.c ****       pHandle->pPWM->offsetCalibStatus = true;
 1109              		.loc 2 614 14
 1110 003e 7B68     		ldr	r3, [r7, #4]
 1111 0040 9B68     		ldr	r3, [r3, #8]
 1112              		.loc 2 614 40
 1113 0042 0122     		movs	r2, #1
 1114 0044 83F88120 		strb	r2, [r3, #129]
 615:Src/mc_interface.c ****       retVal = true;
 1115              		.loc 2 615 14
 1116 0048 0123     		movs	r3, #1
 1117 004a FB73     		strb	r3, [r7, #15]
 1118              	.L34:
 616:Src/mc_interface.c ****     }
 617:Src/mc_interface.c ****     else
 618:Src/mc_interface.c ****     {
 619:Src/mc_interface.c ****       /* Reject the command as the condition are not met */
 620:Src/mc_interface.c ****     }
 621:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
 622:Src/mc_interface.c ****   }
 623:Src/mc_interface.c **** #endif
 624:Src/mc_interface.c ****     return(retVal);
 1119              		.loc 2 624 11
 1120 004c FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 625:Src/mc_interface.c **** }
 1121              		.loc 2 625 1
 1122 004e 1846     		mov	r0, r3
 1123 0050 1037     		adds	r7, r7, #16
 1124              	.LCFI72:
 1125              		.cfi_def_cfa_offset 8
 1126 0052 BD46     		mov	sp, r7
 1127              	.LCFI73:
 1128              		.cfi_def_cfa_register 13
 1129              		@ sp needed
 1130 0054 80BD     		pop	{r7, pc}
 1131              		.cfi_endproc
 1132              	.LFE1102:
 1134              		.section	.text.MCI_StopMotor,"ax",%progbits
 1135              		.align	1
 1136              		.weak	MCI_StopMotor
 1137              		.syntax unified
 1138              		.thumb
 1139              		.thumb_func
 1141              	MCI_StopMotor:
 1142              	.LFB1103:
 626:Src/mc_interface.c **** 
 627:Src/mc_interface.c **** /**
 628:Src/mc_interface.c ****   * @brief Initiates the stop procedure for a motor
 629:Src/mc_interface.c ****   *
 630:Src/mc_interface.c ****   *  If the state machine is in any state but the #ICLWAIT, #IDLE, #FAULT_NOW and
 631:Src/mc_interface.c ****   * #FAULT_OVER states, the command is immediately executed. Otherwise, it is
 632:Src/mc_interface.c ****   * discarded. The Application can check the return value to know whether the
 633:Src/mc_interface.c ****   * command was executed or discarded.
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 37


 634:Src/mc_interface.c ****   *
 635:Src/mc_interface.c ****   * @note The MCI_StopMotor() command only triggers the stop motor procedure
 636:Src/mc_interface.c ****   * and then returns. It is not blocking the application until the motor is indeed
 637:Src/mc_interface.c ****   * stopped. To know if it has stopped, the application can query the motor's state
 638:Src/mc_interface.c ****   * machine and check if the #IDLE state has been reached.
 639:Src/mc_interface.c ****   *
 640:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
 641:Src/mc_interface.c ****   * @retval returns true if the command is successfully executed, false otherwise.
 642:Src/mc_interface.c ****   */
 643:Src/mc_interface.c **** __weak bool MCI_StopMotor(MCI_Handle_t *pHandle)
 644:Src/mc_interface.c **** {
 1143              		.loc 2 644 1
 1144              		.cfi_startproc
 1145              		@ args = 0, pretend = 0, frame = 16
 1146              		@ frame_needed = 1, uses_anonymous_args = 0
 1147 0000 80B5     		push	{r7, lr}
 1148              	.LCFI74:
 1149              		.cfi_def_cfa_offset 8
 1150              		.cfi_offset 7, -8
 1151              		.cfi_offset 14, -4
 1152 0002 84B0     		sub	sp, sp, #16
 1153              	.LCFI75:
 1154              		.cfi_def_cfa_offset 24
 1155 0004 00AF     		add	r7, sp, #0
 1156              	.LCFI76:
 1157              		.cfi_def_cfa_register 7
 1158 0006 7860     		str	r0, [r7, #4]
 645:Src/mc_interface.c ****   bool retVal = false;
 1159              		.loc 2 645 8
 1160 0008 0023     		movs	r3, #0
 1161 000a FB73     		strb	r3, [r7, #15]
 646:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
 647:Src/mc_interface.c ****   if (MC_NULL == pHandle)
 648:Src/mc_interface.c ****   {
 649:Src/mc_interface.c ****     /* Nothing to do */
 650:Src/mc_interface.c ****   }
 651:Src/mc_interface.c ****   else
 652:Src/mc_interface.c ****   {
 653:Src/mc_interface.c **** #endif
 654:Src/mc_interface.c ****     bool status;
 655:Src/mc_interface.c ****     MCI_State_t State;
 656:Src/mc_interface.c **** 
 657:Src/mc_interface.c ****     State = MCI_GetSTMState(pHandle);
 1162              		.loc 2 657 13
 1163 000c 7868     		ldr	r0, [r7, #4]
 1164 000e FFF7FEFF 		bl	MCI_GetSTMState
 1165 0012 0346     		mov	r3, r0
 1166 0014 7B73     		strb	r3, [r7, #13]
 658:Src/mc_interface.c ****     if ((IDLE == State) || (ICLWAIT == State))
 1167              		.loc 2 658 8
 1168 0016 7B7B     		ldrb	r3, [r7, #13]	@ zero_extendqisi2
 1169 0018 002B     		cmp	r3, #0
 1170 001a 02D0     		beq	.L37
 1171              		.loc 2 658 25 discriminator 1
 1172 001c 7B7B     		ldrb	r3, [r7, #13]	@ zero_extendqisi2
 1173 001e 0C2B     		cmp	r3, #12
 1174 0020 02D1     		bne	.L38
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 38


 1175              	.L37:
 659:Src/mc_interface.c ****     {
 660:Src/mc_interface.c ****       status = false;
 1176              		.loc 2 660 14
 1177 0022 0023     		movs	r3, #0
 1178 0024 BB73     		strb	r3, [r7, #14]
 1179 0026 01E0     		b	.L39
 1180              	.L38:
 661:Src/mc_interface.c ****     }
 662:Src/mc_interface.c ****     else
 663:Src/mc_interface.c ****     {
 664:Src/mc_interface.c ****       status = true;
 1181              		.loc 2 664 14
 1182 0028 0123     		movs	r3, #1
 1183 002a BB73     		strb	r3, [r7, #14]
 1184              	.L39:
 665:Src/mc_interface.c ****     }
 666:Src/mc_interface.c **** 
 667:Src/mc_interface.c ****     if ((MC_NO_FAULTS == MCI_GetOccurredFaults(pHandle)) &&
 1185              		.loc 2 667 26
 1186 002c 7868     		ldr	r0, [r7, #4]
 1187 002e FFF7FEFF 		bl	MCI_GetOccurredFaults
 1188 0032 0346     		mov	r3, r0
 1189              		.loc 2 667 8
 1190 0034 002B     		cmp	r3, #0
 1191 0036 0ED1     		bne	.L40
 668:Src/mc_interface.c ****         (MC_NO_FAULTS == MCI_GetCurrentFaults(pHandle)) &&
 1192              		.loc 2 668 26 discriminator 1
 1193 0038 7868     		ldr	r0, [r7, #4]
 1194 003a FFF7FEFF 		bl	MCI_GetCurrentFaults
 1195 003e 0346     		mov	r3, r0
 667:Src/mc_interface.c ****         (MC_NO_FAULTS == MCI_GetCurrentFaults(pHandle)) &&
 1196              		.loc 2 667 58 discriminator 1
 1197 0040 002B     		cmp	r3, #0
 1198 0042 08D1     		bne	.L40
 1199              		.loc 2 668 57
 1200 0044 BB7B     		ldrb	r3, [r7, #14]	@ zero_extendqisi2
 1201 0046 002B     		cmp	r3, #0
 1202 0048 05D0     		beq	.L40
 669:Src/mc_interface.c ****         (status == true))
 670:Src/mc_interface.c ****     {
 671:Src/mc_interface.c ****       pHandle->DirectCommand = MCI_STOP;
 1203              		.loc 2 671 30
 1204 004a 7B68     		ldr	r3, [r7, #4]
 1205 004c 0522     		movs	r2, #5
 1206 004e 83F82620 		strb	r2, [r3, #38]
 672:Src/mc_interface.c ****       retVal = true;
 1207              		.loc 2 672 14
 1208 0052 0123     		movs	r3, #1
 1209 0054 FB73     		strb	r3, [r7, #15]
 1210              	.L40:
 673:Src/mc_interface.c ****     }
 674:Src/mc_interface.c ****     else
 675:Src/mc_interface.c ****     {
 676:Src/mc_interface.c ****       /* Reject the command as the condition are not met */
 677:Src/mc_interface.c ****     }
 678:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 39


 679:Src/mc_interface.c ****   }
 680:Src/mc_interface.c **** #endif
 681:Src/mc_interface.c ****   return (retVal);
 1211              		.loc 2 681 10
 1212 0056 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 682:Src/mc_interface.c **** }
 1213              		.loc 2 682 1
 1214 0058 1846     		mov	r0, r3
 1215 005a 1037     		adds	r7, r7, #16
 1216              	.LCFI77:
 1217              		.cfi_def_cfa_offset 8
 1218 005c BD46     		mov	sp, r7
 1219              	.LCFI78:
 1220              		.cfi_def_cfa_register 13
 1221              		@ sp needed
 1222 005e 80BD     		pop	{r7, pc}
 1223              		.cfi_endproc
 1224              	.LFE1103:
 1226              		.section	.text.MCI_FaultAcknowledged,"ax",%progbits
 1227              		.align	1
 1228              		.weak	MCI_FaultAcknowledged
 1229              		.syntax unified
 1230              		.thumb
 1231              		.thumb_func
 1233              	MCI_FaultAcknowledged:
 1234              	.LFB1104:
 683:Src/mc_interface.c **** 
 684:Src/mc_interface.c **** /**
 685:Src/mc_interface.c ****  * @brief Acknowledges Motor Control faults that occurred on the target motor 1.
 686:Src/mc_interface.c ****  *
 687:Src/mc_interface.c ****  *  This function must be called before the motor can be started again when a fault
 688:Src/mc_interface.c ****  * condition has occured. It clears the faults status and resets the state machine
 689:Src/mc_interface.c ****  * of the target motor to the #IDLE state provided that there is no active fault
 690:Src/mc_interface.c ****  * condition anymore.
 691:Src/mc_interface.c ****  *
 692:Src/mc_interface.c ****  *  If the state machine of the target motor is in the #FAULT_OVER state, the function
 693:Src/mc_interface.c ****  * clears the list of past faults, transitions to the #IDLE state and returns true.
 694:Src/mc_interface.c ****  * Otherwise, it oes nothing and returns false.
 695:Src/mc_interface.c ****  *
 696:Src/mc_interface.c ****  * @param  pHandle Pointer on the target motor drive structure.
 697:Src/mc_interface.c ****  */
 698:Src/mc_interface.c **** __weak bool MCI_FaultAcknowledged(MCI_Handle_t *pHandle)
 699:Src/mc_interface.c **** {
 1235              		.loc 2 699 1
 1236              		.cfi_startproc
 1237              		@ args = 0, pretend = 0, frame = 16
 1238              		@ frame_needed = 1, uses_anonymous_args = 0
 1239 0000 80B5     		push	{r7, lr}
 1240              	.LCFI79:
 1241              		.cfi_def_cfa_offset 8
 1242              		.cfi_offset 7, -8
 1243              		.cfi_offset 14, -4
 1244 0002 84B0     		sub	sp, sp, #16
 1245              	.LCFI80:
 1246              		.cfi_def_cfa_offset 24
 1247 0004 00AF     		add	r7, sp, #0
 1248              	.LCFI81:
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 40


 1249              		.cfi_def_cfa_register 7
 1250 0006 7860     		str	r0, [r7, #4]
 700:Src/mc_interface.c ****   bool reVal = false;
 1251              		.loc 2 700 8
 1252 0008 0023     		movs	r3, #0
 1253 000a FB73     		strb	r3, [r7, #15]
 701:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
 702:Src/mc_interface.c ****   if (MC_NULL == pHandle)
 703:Src/mc_interface.c ****   {
 704:Src/mc_interface.c ****     /* Nothing to do */
 705:Src/mc_interface.c ****   }
 706:Src/mc_interface.c ****   else
 707:Src/mc_interface.c ****   {
 708:Src/mc_interface.c **** #endif
 709:Src/mc_interface.c ****     if ((FAULT_OVER == MCI_GetSTMState(pHandle)) && (MC_NO_FAULTS == MCI_GetCurrentFaults(pHandle))
 1254              		.loc 2 709 24
 1255 000c 7868     		ldr	r0, [r7, #4]
 1256 000e FFF7FEFF 		bl	MCI_GetSTMState
 1257 0012 0346     		mov	r3, r0
 1258              		.loc 2 709 8
 1259 0014 0B2B     		cmp	r3, #11
 1260 0016 0ED1     		bne	.L43
 1261              		.loc 2 709 70 discriminator 1
 1262 0018 7868     		ldr	r0, [r7, #4]
 1263 001a FFF7FEFF 		bl	MCI_GetCurrentFaults
 1264 001e 0346     		mov	r3, r0
 1265              		.loc 2 709 50 discriminator 1
 1266 0020 002B     		cmp	r3, #0
 1267 0022 08D1     		bne	.L43
 710:Src/mc_interface.c ****     {
 711:Src/mc_interface.c ****       pHandle->PastFaults = MC_NO_FAULTS;
 1268              		.loc 2 711 27
 1269 0024 7B68     		ldr	r3, [r7, #4]
 1270 0026 0022     		movs	r2, #0
 1271 0028 5A85     		strh	r2, [r3, #42]	@ movhi
 712:Src/mc_interface.c ****       pHandle->DirectCommand = MCI_ACK_FAULTS;
 1272              		.loc 2 712 30
 1273 002a 7B68     		ldr	r3, [r7, #4]
 1274 002c 0222     		movs	r2, #2
 1275 002e 83F82620 		strb	r2, [r3, #38]
 713:Src/mc_interface.c ****       reVal = true;
 1276              		.loc 2 713 13
 1277 0032 0123     		movs	r3, #1
 1278 0034 FB73     		strb	r3, [r7, #15]
 1279              	.L43:
 714:Src/mc_interface.c ****     }
 715:Src/mc_interface.c ****     else
 716:Src/mc_interface.c ****     {
 717:Src/mc_interface.c ****       /* Reject the command as the conditions are not met */
 718:Src/mc_interface.c ****     }
 719:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
 720:Src/mc_interface.c ****   }
 721:Src/mc_interface.c **** #endif
 722:Src/mc_interface.c ****   return (reVal);
 1280              		.loc 2 722 10
 1281 0036 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 723:Src/mc_interface.c **** }
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 41


 1282              		.loc 2 723 1
 1283 0038 1846     		mov	r0, r3
 1284 003a 1037     		adds	r7, r7, #16
 1285              	.LCFI82:
 1286              		.cfi_def_cfa_offset 8
 1287 003c BD46     		mov	sp, r7
 1288              	.LCFI83:
 1289              		.cfi_def_cfa_register 13
 1290              		@ sp needed
 1291 003e 80BD     		pop	{r7, pc}
 1292              		.cfi_endproc
 1293              	.LFE1104:
 1295              		.section	.text.MCI_FaultProcessing,"ax",%progbits
 1296              		.align	1
 1297              		.weak	MCI_FaultProcessing
 1298              		.syntax unified
 1299              		.thumb
 1300              		.thumb_func
 1302              	MCI_FaultProcessing:
 1303              	.LFB1105:
 724:Src/mc_interface.c **** 
 725:Src/mc_interface.c **** /**
 726:Src/mc_interface.c ****  * @brief It clocks both HW and SW faults processing and update the state
 727:Src/mc_interface.c ****  *        machine accordingly with hSetErrors, hResetErrors and present state.
 728:Src/mc_interface.c ****  *        Refer to State_t description for more information about fault states.
 729:Src/mc_interface.c ****  * @param pHandle pointer of type  STM_Handle_t
 730:Src/mc_interface.c ****  * @param hSetErrors Bit field reporting faults currently present
 731:Src/mc_interface.c ****  * @param hResetErrors Bit field reporting faults to be cleared
 732:Src/mc_interface.c ****  */
 733:Src/mc_interface.c **** __weak void MCI_FaultProcessing(MCI_Handle_t *pHandle, uint16_t hSetErrors, uint16_t hResetErrors)
 734:Src/mc_interface.c **** {
 1304              		.loc 2 734 1
 1305              		.cfi_startproc
 1306              		@ args = 0, pretend = 0, frame = 8
 1307              		@ frame_needed = 1, uses_anonymous_args = 0
 1308              		@ link register save eliminated.
 1309 0000 80B4     		push	{r7}
 1310              	.LCFI84:
 1311              		.cfi_def_cfa_offset 4
 1312              		.cfi_offset 7, -4
 1313 0002 83B0     		sub	sp, sp, #12
 1314              	.LCFI85:
 1315              		.cfi_def_cfa_offset 16
 1316 0004 00AF     		add	r7, sp, #0
 1317              	.LCFI86:
 1318              		.cfi_def_cfa_register 7
 1319 0006 7860     		str	r0, [r7, #4]
 1320 0008 0B46     		mov	r3, r1
 1321 000a 7B80     		strh	r3, [r7, #2]	@ movhi
 1322 000c 1346     		mov	r3, r2	@ movhi
 1323 000e 3B80     		strh	r3, [r7]	@ movhi
 735:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
 736:Src/mc_interface.c ****   if (MC_NULL == pHandle)
 737:Src/mc_interface.c ****   {
 738:Src/mc_interface.c ****     /* Nothing to do */
 739:Src/mc_interface.c ****   }
 740:Src/mc_interface.c ****   else
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 42


 741:Src/mc_interface.c ****   {
 742:Src/mc_interface.c **** #endif
 743:Src/mc_interface.c ****     /* Set current errors */
 744:Src/mc_interface.c ****     pHandle->CurrentFaults = (pHandle->CurrentFaults | hSetErrors ) & (~hResetErrors);
 1324              		.loc 2 744 38
 1325 0010 7B68     		ldr	r3, [r7, #4]
 1326 0012 1A8D     		ldrh	r2, [r3, #40]
 1327              		.loc 2 744 69
 1328 0014 7B88     		ldrh	r3, [r7, #2]	@ movhi
 1329 0016 1343     		orrs	r3, r3, r2
 1330 0018 9BB2     		uxth	r3, r3
 1331 001a 1AB2     		sxth	r2, r3
 1332 001c B7F90030 		ldrsh	r3, [r7]
 1333 0020 DB43     		mvns	r3, r3
 1334 0022 1BB2     		sxth	r3, r3
 1335 0024 1340     		ands	r3, r3, r2
 1336 0026 1BB2     		sxth	r3, r3
 1337 0028 9AB2     		uxth	r2, r3
 1338              		.loc 2 744 28
 1339 002a 7B68     		ldr	r3, [r7, #4]
 1340 002c 1A85     		strh	r2, [r3, #40]	@ movhi
 745:Src/mc_interface.c ****     pHandle->PastFaults |= hSetErrors;
 1341              		.loc 2 745 25
 1342 002e 7B68     		ldr	r3, [r7, #4]
 1343 0030 5A8D     		ldrh	r2, [r3, #42]
 1344 0032 7B88     		ldrh	r3, [r7, #2]	@ movhi
 1345 0034 1343     		orrs	r3, r3, r2
 1346 0036 9AB2     		uxth	r2, r3
 1347 0038 7B68     		ldr	r3, [r7, #4]
 1348 003a 5A85     		strh	r2, [r3, #42]	@ movhi
 746:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
 747:Src/mc_interface.c ****   }
 748:Src/mc_interface.c **** #endif
 749:Src/mc_interface.c **** }
 1349              		.loc 2 749 1
 1350 003c 00BF     		nop
 1351 003e 0C37     		adds	r7, r7, #12
 1352              	.LCFI87:
 1353              		.cfi_def_cfa_offset 4
 1354 0040 BD46     		mov	sp, r7
 1355              	.LCFI88:
 1356              		.cfi_def_cfa_register 13
 1357              		@ sp needed
 1358 0042 5DF8047B 		ldr	r7, [sp], #4
 1359              	.LCFI89:
 1360              		.cfi_restore 7
 1361              		.cfi_def_cfa_offset 0
 1362 0046 7047     		bx	lr
 1363              		.cfi_endproc
 1364              	.LFE1105:
 1366              		.section	.text.MCI_ExecBufferedCommands,"ax",%progbits
 1367              		.align	1
 1368              		.weak	MCI_ExecBufferedCommands
 1369              		.syntax unified
 1370              		.thumb
 1371              		.thumb_func
 1373              	MCI_ExecBufferedCommands:
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 43


 1374              	.LFB1106:
 750:Src/mc_interface.c **** 
 751:Src/mc_interface.c **** /**
 752:Src/mc_interface.c ****   * @brief  This is usually a method managed by task. It must be called
 753:Src/mc_interface.c ****   *         periodically in order to check the status of the related pSTM object
 754:Src/mc_interface.c ****   *         and eventually to execute the buffered command if the condition
 755:Src/mc_interface.c ****   *         occurs.
 756:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
 757:Src/mc_interface.c ****   */
 758:Src/mc_interface.c **** __weak void MCI_ExecBufferedCommands(MCI_Handle_t *pHandle)
 759:Src/mc_interface.c **** {
 1375              		.loc 2 759 1
 1376              		.cfi_startproc
 1377              		@ args = 0, pretend = 0, frame = 16
 1378              		@ frame_needed = 1, uses_anonymous_args = 0
 1379 0000 80B5     		push	{r7, lr}
 1380              	.LCFI90:
 1381              		.cfi_def_cfa_offset 8
 1382              		.cfi_offset 7, -8
 1383              		.cfi_offset 14, -4
 1384 0002 84B0     		sub	sp, sp, #16
 1385              	.LCFI91:
 1386              		.cfi_def_cfa_offset 24
 1387 0004 00AF     		add	r7, sp, #0
 1388              	.LCFI92:
 1389              		.cfi_def_cfa_register 7
 1390 0006 7860     		str	r0, [r7, #4]
 760:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
 761:Src/mc_interface.c ****   if (NULL == pHandle)
 762:Src/mc_interface.c ****   {
 763:Src/mc_interface.c ****     /* Nothing to do */
 764:Src/mc_interface.c ****   }
 765:Src/mc_interface.c ****   else
 766:Src/mc_interface.c ****   {
 767:Src/mc_interface.c **** #endif
 768:Src/mc_interface.c ****     if ( pHandle->CommandState == MCI_COMMAND_NOT_ALREADY_EXECUTED )
 1391              		.loc 2 768 17
 1392 0008 7B68     		ldr	r3, [r7, #4]
 1393 000a 93F82C30 		ldrb	r3, [r3, #44]	@ zero_extendqisi2
 1394              		.loc 2 768 8
 1395 000e 012B     		cmp	r3, #1
 1396 0010 58D1     		bne	.L54
 1397              	.LBB2:
 769:Src/mc_interface.c ****     {
 770:Src/mc_interface.c ****       bool commandHasBeenExecuted = false;
 1398              		.loc 2 770 12
 1399 0012 0023     		movs	r3, #0
 1400 0014 FB73     		strb	r3, [r7, #15]
 771:Src/mc_interface.c ****       switch (pHandle->lastCommand)
 1401              		.loc 2 771 22
 1402 0016 7B68     		ldr	r3, [r7, #4]
 1403 0018 1B7D     		ldrb	r3, [r3, #20]	@ zero_extendqisi2
 1404              		.loc 2 771 7
 1405 001a 032B     		cmp	r3, #3
 1406 001c 36D0     		beq	.L48
 1407 001e 032B     		cmp	r3, #3
 1408 0020 43DC     		bgt	.L55
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 44


 1409 0022 012B     		cmp	r3, #1
 1410 0024 02D0     		beq	.L50
 1411 0026 022B     		cmp	r3, #2
 1412 0028 18D0     		beq	.L51
 772:Src/mc_interface.c ****       {
 773:Src/mc_interface.c ****         case MCI_CMD_EXECSPEEDRAMP:
 774:Src/mc_interface.c ****         {
 775:Src/mc_interface.c ****           pHandle->pFOCVars->bDriveInput = INTERNAL;
 776:Src/mc_interface.c ****           STC_SetControlMode(pHandle->pSTC, MCM_SPEED_MODE);
 777:Src/mc_interface.c ****           commandHasBeenExecuted = STC_ExecRamp(pHandle->pSTC, pHandle->hFinalSpeed, pHandle->hDura
 778:Src/mc_interface.c ****           break;
 779:Src/mc_interface.c ****         }
 780:Src/mc_interface.c **** 
 781:Src/mc_interface.c ****         case MCI_CMD_EXECTORQUERAMP:
 782:Src/mc_interface.c ****         {
 783:Src/mc_interface.c ****           pHandle->pFOCVars->bDriveInput = INTERNAL;
 784:Src/mc_interface.c ****           STC_SetControlMode(pHandle->pSTC, MCM_TORQUE_MODE);
 785:Src/mc_interface.c ****           commandHasBeenExecuted = STC_ExecRamp(pHandle->pSTC, pHandle->hFinalTorque, pHandle->hDur
 786:Src/mc_interface.c ****           break;
 787:Src/mc_interface.c ****         }
 788:Src/mc_interface.c **** 
 789:Src/mc_interface.c ****         case MCI_CMD_SETCURRENTREFERENCES:
 790:Src/mc_interface.c ****         {
 791:Src/mc_interface.c ****           pHandle->pFOCVars->bDriveInput = EXTERNAL;
 792:Src/mc_interface.c ****           pHandle->pFOCVars->Iqdref = pHandle->Iqdref;
 793:Src/mc_interface.c ****           commandHasBeenExecuted = true;
 794:Src/mc_interface.c ****           break;
 795:Src/mc_interface.c ****         }
 796:Src/mc_interface.c **** 
 797:Src/mc_interface.c ****         default:
 798:Src/mc_interface.c ****           break;
 1413              		.loc 2 798 11
 1414 002a 3EE0     		b	.L55
 1415              	.L50:
 775:Src/mc_interface.c ****           STC_SetControlMode(pHandle->pSTC, MCM_SPEED_MODE);
 1416              		.loc 2 775 18
 1417 002c 7B68     		ldr	r3, [r7, #4]
 1418 002e 5B68     		ldr	r3, [r3, #4]
 775:Src/mc_interface.c ****           STC_SetControlMode(pHandle->pSTC, MCM_SPEED_MODE);
 1419              		.loc 2 775 42
 1420 0030 0022     		movs	r2, #0
 1421 0032 83F82420 		strb	r2, [r3, #36]
 776:Src/mc_interface.c ****           commandHasBeenExecuted = STC_ExecRamp(pHandle->pSTC, pHandle->hFinalSpeed, pHandle->hDura
 1422              		.loc 2 776 11
 1423 0036 7B68     		ldr	r3, [r7, #4]
 1424 0038 1B68     		ldr	r3, [r3]
 1425 003a 0321     		movs	r1, #3
 1426 003c 1846     		mov	r0, r3
 1427 003e FFF7FEFF 		bl	STC_SetControlMode
 777:Src/mc_interface.c ****           break;
 1428              		.loc 2 777 36
 1429 0042 7B68     		ldr	r3, [r7, #4]
 1430 0044 1868     		ldr	r0, [r3]
 1431 0046 7B68     		ldr	r3, [r7, #4]
 1432 0048 B3F91610 		ldrsh	r1, [r3, #22]
 777:Src/mc_interface.c ****           break;
 1433              		.loc 2 777 93
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 45


 1434 004c 7B68     		ldr	r3, [r7, #4]
 1435 004e 9B8C     		ldrh	r3, [r3, #36]
 777:Src/mc_interface.c ****           break;
 1436              		.loc 2 777 36
 1437 0050 1A46     		mov	r2, r3
 1438 0052 FFF7FEFF 		bl	STC_ExecRamp
 1439 0056 0346     		mov	r3, r0
 1440 0058 FB73     		strb	r3, [r7, #15]
 778:Src/mc_interface.c ****         }
 1441              		.loc 2 778 11
 1442 005a 27E0     		b	.L52
 1443              	.L51:
 783:Src/mc_interface.c ****           STC_SetControlMode(pHandle->pSTC, MCM_TORQUE_MODE);
 1444              		.loc 2 783 18
 1445 005c 7B68     		ldr	r3, [r7, #4]
 1446 005e 5B68     		ldr	r3, [r3, #4]
 783:Src/mc_interface.c ****           STC_SetControlMode(pHandle->pSTC, MCM_TORQUE_MODE);
 1447              		.loc 2 783 42
 1448 0060 0022     		movs	r2, #0
 1449 0062 83F82420 		strb	r2, [r3, #36]
 784:Src/mc_interface.c ****           commandHasBeenExecuted = STC_ExecRamp(pHandle->pSTC, pHandle->hFinalTorque, pHandle->hDur
 1450              		.loc 2 784 11
 1451 0066 7B68     		ldr	r3, [r7, #4]
 1452 0068 1B68     		ldr	r3, [r3]
 1453 006a 0421     		movs	r1, #4
 1454 006c 1846     		mov	r0, r3
 1455 006e FFF7FEFF 		bl	STC_SetControlMode
 785:Src/mc_interface.c ****           break;
 1456              		.loc 2 785 36
 1457 0072 7B68     		ldr	r3, [r7, #4]
 1458 0074 1868     		ldr	r0, [r3]
 1459 0076 7B68     		ldr	r3, [r7, #4]
 1460 0078 B3F91810 		ldrsh	r1, [r3, #24]
 785:Src/mc_interface.c ****           break;
 1461              		.loc 2 785 94
 1462 007c 7B68     		ldr	r3, [r7, #4]
 1463 007e 9B8C     		ldrh	r3, [r3, #36]
 785:Src/mc_interface.c ****           break;
 1464              		.loc 2 785 36
 1465 0080 1A46     		mov	r2, r3
 1466 0082 FFF7FEFF 		bl	STC_ExecRamp
 1467 0086 0346     		mov	r3, r0
 1468 0088 FB73     		strb	r3, [r7, #15]
 786:Src/mc_interface.c ****         }
 1469              		.loc 2 786 11
 1470 008a 0FE0     		b	.L52
 1471              	.L48:
 791:Src/mc_interface.c ****           pHandle->pFOCVars->Iqdref = pHandle->Iqdref;
 1472              		.loc 2 791 18
 1473 008c 7B68     		ldr	r3, [r7, #4]
 1474 008e 5B68     		ldr	r3, [r3, #4]
 791:Src/mc_interface.c ****           pHandle->pFOCVars->Iqdref = pHandle->Iqdref;
 1475              		.loc 2 791 42
 1476 0090 0122     		movs	r2, #1
 1477 0092 83F82420 		strb	r2, [r3, #36]
 792:Src/mc_interface.c ****           commandHasBeenExecuted = true;
 1478              		.loc 2 792 18
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 46


 1479 0096 7B68     		ldr	r3, [r7, #4]
 1480 0098 5B68     		ldr	r3, [r3, #4]
 792:Src/mc_interface.c ****           commandHasBeenExecuted = true;
 1481              		.loc 2 792 37
 1482 009a 7A68     		ldr	r2, [r7, #4]
 1483 009c 1033     		adds	r3, r3, #16
 1484 009e 1A32     		adds	r2, r2, #26
 1485 00a0 1268     		ldr	r2, [r2]	@ unaligned
 1486 00a2 1A60     		str	r2, [r3]	@ unaligned
 793:Src/mc_interface.c ****           break;
 1487              		.loc 2 793 34
 1488 00a4 0123     		movs	r3, #1
 1489 00a6 FB73     		strb	r3, [r7, #15]
 794:Src/mc_interface.c ****         }
 1490              		.loc 2 794 11
 1491 00a8 00E0     		b	.L52
 1492              	.L55:
 1493              		.loc 2 798 11
 1494 00aa 00BF     		nop
 1495              	.L52:
 799:Src/mc_interface.c ****       }
 800:Src/mc_interface.c **** 
 801:Src/mc_interface.c ****       if (commandHasBeenExecuted)
 1496              		.loc 2 801 10
 1497 00ac FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 1498 00ae 002B     		cmp	r3, #0
 1499 00b0 04D0     		beq	.L53
 802:Src/mc_interface.c ****       {
 803:Src/mc_interface.c ****         pHandle->CommandState = MCI_COMMAND_EXECUTED_SUCCESSFULLY;
 1500              		.loc 2 803 31
 1501 00b2 7B68     		ldr	r3, [r7, #4]
 1502 00b4 0222     		movs	r2, #2
 1503 00b6 83F82C20 		strb	r2, [r3, #44]
 1504              	.LBE2:
 804:Src/mc_interface.c ****       }
 805:Src/mc_interface.c ****       else
 806:Src/mc_interface.c ****       {
 807:Src/mc_interface.c ****         pHandle->CommandState = MCI_COMMAND_EXECUTED_UNSUCCESSFULLY;
 808:Src/mc_interface.c ****       }
 809:Src/mc_interface.c ****     }
 810:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
 811:Src/mc_interface.c ****   }
 812:Src/mc_interface.c **** #endif
 813:Src/mc_interface.c **** }
 1505              		.loc 2 813 1
 1506 00ba 03E0     		b	.L54
 1507              	.L53:
 1508              	.LBB3:
 807:Src/mc_interface.c ****       }
 1509              		.loc 2 807 31
 1510 00bc 7B68     		ldr	r3, [r7, #4]
 1511 00be 0322     		movs	r2, #3
 1512 00c0 83F82C20 		strb	r2, [r3, #44]
 1513              	.L54:
 1514              	.LBE3:
 1515              		.loc 2 813 1
 1516 00c4 00BF     		nop
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 47


 1517 00c6 1037     		adds	r7, r7, #16
 1518              	.LCFI93:
 1519              		.cfi_def_cfa_offset 8
 1520 00c8 BD46     		mov	sp, r7
 1521              	.LCFI94:
 1522              		.cfi_def_cfa_register 13
 1523              		@ sp needed
 1524 00ca 80BD     		pop	{r7, pc}
 1525              		.cfi_endproc
 1526              	.LFE1106:
 1528              		.section	.text.MCI_IsCommandAcknowledged,"ax",%progbits
 1529              		.align	1
 1530              		.weak	MCI_IsCommandAcknowledged
 1531              		.syntax unified
 1532              		.thumb
 1533              		.thumb_func
 1535              	MCI_IsCommandAcknowledged:
 1536              	.LFB1107:
 814:Src/mc_interface.c **** 
 815:Src/mc_interface.c **** /**
 816:Src/mc_interface.c ****   * @brief  Returns information about the state of the last buffered command.
 817:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
 818:Src/mc_interface.c ****   * @retval The state of the last buffered command
 819:Src/mc_interface.c ****   *
 820:Src/mc_interface.c ****   * The state returned by this function can be one of the following codes:
 821:Src/mc_interface.c ****   * - #MCI_BUFFER_EMPTY if no buffered command has been called.
 822:Src/mc_interface.c ****   * - #MCI_COMMAND_NOT_ALREADY_EXECUTED if the buffered command
 823:Src/mc_interface.c ****   * condition has not already occurred.
 824:Src/mc_interface.c ****   * - #MCI_COMMAND_EXECUTED_SUCCESSFULLY if the buffered command has
 825:Src/mc_interface.c ****   * been executed successfully. In this case calling this function resets
 826:Src/mc_interface.c ****   * the command state to #MCI_BUFFER_EMPTY.
 827:Src/mc_interface.c ****   * - #MCI_COMMAND_EXECUTED_UNSUCCESSFULLY if the buffered command has
 828:Src/mc_interface.c ****   * been executed unsuccessfully. In this case calling this function
 829:Src/mc_interface.c ****   * resets the command state to #MCI_BUFFER_EMPTY.
 830:Src/mc_interface.c ****   */
 831:Src/mc_interface.c **** __weak MCI_CommandState_t MCI_IsCommandAcknowledged(MCI_Handle_t *pHandle)
 832:Src/mc_interface.c **** {
 1537              		.loc 2 832 1
 1538              		.cfi_startproc
 1539              		@ args = 0, pretend = 0, frame = 16
 1540              		@ frame_needed = 1, uses_anonymous_args = 0
 1541              		@ link register save eliminated.
 1542 0000 80B4     		push	{r7}
 1543              	.LCFI95:
 1544              		.cfi_def_cfa_offset 4
 1545              		.cfi_offset 7, -4
 1546 0002 85B0     		sub	sp, sp, #20
 1547              	.LCFI96:
 1548              		.cfi_def_cfa_offset 24
 1549 0004 00AF     		add	r7, sp, #0
 1550              	.LCFI97:
 1551              		.cfi_def_cfa_register 7
 1552 0006 7860     		str	r0, [r7, #4]
 833:Src/mc_interface.c ****   MCI_CommandState_t retVal;
 834:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
 835:Src/mc_interface.c ****   if (MC_NULL == pHandle)
 836:Src/mc_interface.c ****   {
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 48


 837:Src/mc_interface.c ****     retVal = MCI_COMMAND_EXECUTED_UNSUCCESSFULLY;
 838:Src/mc_interface.c ****   }
 839:Src/mc_interface.c ****   else
 840:Src/mc_interface.c ****   {
 841:Src/mc_interface.c **** #endif
 842:Src/mc_interface.c ****     retVal = pHandle->CommandState;
 1553              		.loc 2 842 12
 1554 0008 7B68     		ldr	r3, [r7, #4]
 1555 000a 93F82C30 		ldrb	r3, [r3, #44]
 1556 000e FB73     		strb	r3, [r7, #15]
 843:Src/mc_interface.c **** 
 844:Src/mc_interface.c ****     if ((MCI_COMMAND_EXECUTED_SUCCESSFULLY == retVal) || (MCI_COMMAND_EXECUTED_UNSUCCESSFULLY == re
 1557              		.loc 2 844 8
 1558 0010 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 1559 0012 022B     		cmp	r3, #2
 1560 0014 02D0     		beq	.L57
 1561              		.loc 2 844 55 discriminator 1
 1562 0016 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 1563 0018 032B     		cmp	r3, #3
 1564 001a 03D1     		bne	.L58
 1565              	.L57:
 845:Src/mc_interface.c ****     {
 846:Src/mc_interface.c ****       pHandle->CommandState = MCI_BUFFER_EMPTY;
 1566              		.loc 2 846 29
 1567 001c 7B68     		ldr	r3, [r7, #4]
 1568 001e 0022     		movs	r2, #0
 1569 0020 83F82C20 		strb	r2, [r3, #44]
 1570              	.L58:
 847:Src/mc_interface.c ****     }
 848:Src/mc_interface.c ****     else
 849:Src/mc_interface.c ****     {
 850:Src/mc_interface.c ****       /* Nothing to do */
 851:Src/mc_interface.c ****     }
 852:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
 853:Src/mc_interface.c ****   }
 854:Src/mc_interface.c **** #endif
 855:Src/mc_interface.c ****   return (retVal);
 1571              		.loc 2 855 10
 1572 0024 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 856:Src/mc_interface.c **** }
 1573              		.loc 2 856 1
 1574 0026 1846     		mov	r0, r3
 1575 0028 1437     		adds	r7, r7, #20
 1576              	.LCFI98:
 1577              		.cfi_def_cfa_offset 4
 1578 002a BD46     		mov	sp, r7
 1579              	.LCFI99:
 1580              		.cfi_def_cfa_register 13
 1581              		@ sp needed
 1582 002c 5DF8047B 		ldr	r7, [sp], #4
 1583              	.LCFI100:
 1584              		.cfi_restore 7
 1585              		.cfi_def_cfa_offset 0
 1586 0030 7047     		bx	lr
 1587              		.cfi_endproc
 1588              	.LFE1107:
 1590              		.section	.text.MCI_GetSTMState,"ax",%progbits
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 49


 1591              		.align	1
 1592              		.weak	MCI_GetSTMState
 1593              		.syntax unified
 1594              		.thumb
 1595              		.thumb_func
 1597              	MCI_GetSTMState:
 1598              	.LFB1108:
 857:Src/mc_interface.c **** 
 858:Src/mc_interface.c **** /**
 859:Src/mc_interface.c ****   * @brief  It returns information about the state of the related pSTM object.
 860:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
 861:Src/mc_interface.c ****   * @retval State_t It returns the current state of the related pSTM object.
 862:Src/mc_interface.c ****   */
 863:Src/mc_interface.c **** __weak MCI_State_t MCI_GetSTMState(MCI_Handle_t *pHandle) //cstat !MISRAC2012-Rule-8.13
 864:Src/mc_interface.c **** {
 1599              		.loc 2 864 1
 1600              		.cfi_startproc
 1601              		@ args = 0, pretend = 0, frame = 8
 1602              		@ frame_needed = 1, uses_anonymous_args = 0
 1603              		@ link register save eliminated.
 1604 0000 80B4     		push	{r7}
 1605              	.LCFI101:
 1606              		.cfi_def_cfa_offset 4
 1607              		.cfi_offset 7, -4
 1608 0002 83B0     		sub	sp, sp, #12
 1609              	.LCFI102:
 1610              		.cfi_def_cfa_offset 16
 1611 0004 00AF     		add	r7, sp, #0
 1612              	.LCFI103:
 1613              		.cfi_def_cfa_register 7
 1614 0006 7860     		str	r0, [r7, #4]
 865:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
 866:Src/mc_interface.c ****   return ((MC_NULL == pHandle) ? FAULT_NOW : pHandle->State);
 867:Src/mc_interface.c **** #else
 868:Src/mc_interface.c ****   return (pHandle->State);
 1615              		.loc 2 868 18
 1616 0008 7B68     		ldr	r3, [r7, #4]
 1617 000a 93F82730 		ldrb	r3, [r3, #39]	@ zero_extendqisi2
 869:Src/mc_interface.c **** #endif
 870:Src/mc_interface.c **** }
 1618              		.loc 2 870 1
 1619 000e 1846     		mov	r0, r3
 1620 0010 0C37     		adds	r7, r7, #12
 1621              	.LCFI104:
 1622              		.cfi_def_cfa_offset 4
 1623 0012 BD46     		mov	sp, r7
 1624              	.LCFI105:
 1625              		.cfi_def_cfa_register 13
 1626              		@ sp needed
 1627 0014 5DF8047B 		ldr	r7, [sp], #4
 1628              	.LCFI106:
 1629              		.cfi_restore 7
 1630              		.cfi_def_cfa_offset 0
 1631 0018 7047     		bx	lr
 1632              		.cfi_endproc
 1633              	.LFE1108:
 1635              		.section	.text.MCI_GetCtrlPositionState,"ax",%progbits
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 50


 1636              		.align	1
 1637              		.weak	MCI_GetCtrlPositionState
 1638              		.syntax unified
 1639              		.thumb
 1640              		.thumb_func
 1642              	MCI_GetCtrlPositionState:
 1643              	.LFB1109:
 871:Src/mc_interface.c **** 
 872:Src/mc_interface.c **** /**
 873:Src/mc_interface.c ****   * @brief  It returns information about the state of the position control.
 874:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
 875:Src/mc_interface.c ****   * @retval State_t It returns the current state position control execution.
 876:Src/mc_interface.c ****   */
 877:Src/mc_interface.c **** __weak PosCtrlStatus_t MCI_GetCtrlPositionState(MCI_Handle_t *pHandle) //cstat !MISRAC2012-Rule-8.1
 878:Src/mc_interface.c **** {
 1644              		.loc 2 878 1
 1645              		.cfi_startproc
 1646              		@ args = 0, pretend = 0, frame = 8
 1647              		@ frame_needed = 1, uses_anonymous_args = 0
 1648 0000 80B5     		push	{r7, lr}
 1649              	.LCFI107:
 1650              		.cfi_def_cfa_offset 8
 1651              		.cfi_offset 7, -8
 1652              		.cfi_offset 14, -4
 1653 0002 82B0     		sub	sp, sp, #8
 1654              	.LCFI108:
 1655              		.cfi_def_cfa_offset 16
 1656 0004 00AF     		add	r7, sp, #0
 1657              	.LCFI109:
 1658              		.cfi_def_cfa_register 7
 1659 0006 7860     		str	r0, [r7, #4]
 879:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
 880:Src/mc_interface.c ****   return ((MC_NULL == pHandle) ? TC_FOLLOWING_ON_GOING : TC_GetControlPositionStatus(pHandle->pPosC
 881:Src/mc_interface.c **** #else
 882:Src/mc_interface.c ****   return (TC_GetControlPositionStatus(pHandle->pPosCtrl));
 1660              		.loc 2 882 11
 1661 0008 7B68     		ldr	r3, [r7, #4]
 1662 000a 1B69     		ldr	r3, [r3, #16]
 1663 000c 1846     		mov	r0, r3
 1664 000e FFF7FEFF 		bl	TC_GetControlPositionStatus
 1665 0012 0346     		mov	r3, r0
 883:Src/mc_interface.c **** #endif
 884:Src/mc_interface.c **** }
 1666              		.loc 2 884 1
 1667 0014 1846     		mov	r0, r3
 1668 0016 0837     		adds	r7, r7, #8
 1669              	.LCFI110:
 1670              		.cfi_def_cfa_offset 8
 1671 0018 BD46     		mov	sp, r7
 1672              	.LCFI111:
 1673              		.cfi_def_cfa_register 13
 1674              		@ sp needed
 1675 001a 80BD     		pop	{r7, pc}
 1676              		.cfi_endproc
 1677              	.LFE1109:
 1679              		.section	.text.MCI_GetAlignmentStatus,"ax",%progbits
 1680              		.align	1
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 51


 1681              		.weak	MCI_GetAlignmentStatus
 1682              		.syntax unified
 1683              		.thumb
 1684              		.thumb_func
 1686              	MCI_GetAlignmentStatus:
 1687              	.LFB1110:
 885:Src/mc_interface.c **** 
 886:Src/mc_interface.c **** /**
 887:Src/mc_interface.c ****   * @brief  It returns information about the rotor alignment procedure.
 888:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
 889:Src/mc_interface.c ****   * @retval State_t It returns the current state of the alignment.
 890:Src/mc_interface.c ****   */
 891:Src/mc_interface.c **** __weak AlignStatus_t MCI_GetAlignmentStatus(MCI_Handle_t *pHandle) //cstat !MISRAC2012-Rule-8.13
 892:Src/mc_interface.c **** {
 1688              		.loc 2 892 1
 1689              		.cfi_startproc
 1690              		@ args = 0, pretend = 0, frame = 8
 1691              		@ frame_needed = 1, uses_anonymous_args = 0
 1692 0000 80B5     		push	{r7, lr}
 1693              	.LCFI112:
 1694              		.cfi_def_cfa_offset 8
 1695              		.cfi_offset 7, -8
 1696              		.cfi_offset 14, -4
 1697 0002 82B0     		sub	sp, sp, #8
 1698              	.LCFI113:
 1699              		.cfi_def_cfa_offset 16
 1700 0004 00AF     		add	r7, sp, #0
 1701              	.LCFI114:
 1702              		.cfi_def_cfa_register 7
 1703 0006 7860     		str	r0, [r7, #4]
 893:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
 894:Src/mc_interface.c ****   return ((MC_NULL == pHandle) ? TC_ALIGNMENT_ERROR : TC_GetAlignmentStatus(pHandle->pPosCtrl));
 895:Src/mc_interface.c **** #else
 896:Src/mc_interface.c ****   return ((TC_GetAlignmentStatus(pHandle->pPosCtrl)));
 1704              		.loc 2 896 12
 1705 0008 7B68     		ldr	r3, [r7, #4]
 1706 000a 1B69     		ldr	r3, [r3, #16]
 1707 000c 1846     		mov	r0, r3
 1708 000e FFF7FEFF 		bl	TC_GetAlignmentStatus
 1709 0012 0346     		mov	r3, r0
 897:Src/mc_interface.c **** #endif
 898:Src/mc_interface.c **** }
 1710              		.loc 2 898 1
 1711 0014 1846     		mov	r0, r3
 1712 0016 0837     		adds	r7, r7, #8
 1713              	.LCFI115:
 1714              		.cfi_def_cfa_offset 8
 1715 0018 BD46     		mov	sp, r7
 1716              	.LCFI116:
 1717              		.cfi_def_cfa_register 13
 1718              		@ sp needed
 1719 001a 80BD     		pop	{r7, pc}
 1720              		.cfi_endproc
 1721              	.LFE1110:
 1723              		.section	.text.MCI_GetCurrentPosition,"ax",%progbits
 1724              		.align	1
 1725              		.weak	MCI_GetCurrentPosition
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 52


 1726              		.syntax unified
 1727              		.thumb
 1728              		.thumb_func
 1730              	MCI_GetCurrentPosition:
 1731              	.LFB1111:
 899:Src/mc_interface.c **** 
 900:Src/mc_interface.c **** /**
 901:Src/mc_interface.c ****   * @brief  It returns the current position of the rotor.
 902:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
 903:Src/mc_interface.c ****   * @retval float_t It returns the current mechanical angular position of the rotor.
 904:Src/mc_interface.c ****   */
 905:Src/mc_interface.c **** __weak float_t MCI_GetCurrentPosition(MCI_Handle_t *pHandle) //cstat !MISRAC2012-Rule-8.13
 906:Src/mc_interface.c **** {
 1732              		.loc 2 906 1
 1733              		.cfi_startproc
 1734              		@ args = 0, pretend = 0, frame = 8
 1735              		@ frame_needed = 1, uses_anonymous_args = 0
 1736 0000 80B5     		push	{r7, lr}
 1737              	.LCFI117:
 1738              		.cfi_def_cfa_offset 8
 1739              		.cfi_offset 7, -8
 1740              		.cfi_offset 14, -4
 1741 0002 82B0     		sub	sp, sp, #8
 1742              	.LCFI118:
 1743              		.cfi_def_cfa_offset 16
 1744 0004 00AF     		add	r7, sp, #0
 1745              	.LCFI119:
 1746              		.cfi_def_cfa_register 7
 1747 0006 7860     		str	r0, [r7, #4]
 907:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
 908:Src/mc_interface.c ****   return ((MC_NULL == pHandle) ? 0 : TC_GetCurrentPosition(pHandle->pPosCtrl));
 909:Src/mc_interface.c **** #else
 910:Src/mc_interface.c ****   return (TC_GetCurrentPosition(pHandle->pPosCtrl));
 1748              		.loc 2 910 11
 1749 0008 7B68     		ldr	r3, [r7, #4]
 1750 000a 1B69     		ldr	r3, [r3, #16]
 1751 000c 1846     		mov	r0, r3
 1752 000e FFF7FEFF 		bl	TC_GetCurrentPosition
 1753 0012 F0EE407A 		vmov.f32	s15, s0
 911:Src/mc_interface.c **** #endif
 912:Src/mc_interface.c **** }
 1754              		.loc 2 912 1
 1755 0016 B0EE670A 		vmov.f32	s0, s15
 1756 001a 0837     		adds	r7, r7, #8
 1757              	.LCFI120:
 1758              		.cfi_def_cfa_offset 8
 1759 001c BD46     		mov	sp, r7
 1760              	.LCFI121:
 1761              		.cfi_def_cfa_register 13
 1762              		@ sp needed
 1763 001e 80BD     		pop	{r7, pc}
 1764              		.cfi_endproc
 1765              	.LFE1111:
 1767              		.section	.text.MCI_GetTargetPosition,"ax",%progbits
 1768              		.align	1
 1769              		.weak	MCI_GetTargetPosition
 1770              		.syntax unified
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 53


 1771              		.thumb
 1772              		.thumb_func
 1774              	MCI_GetTargetPosition:
 1775              	.LFB1112:
 913:Src/mc_interface.c **** 
 914:Src/mc_interface.c **** /**
 915:Src/mc_interface.c ****   * @brief  It returns the final position asked to the motor.
 916:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
 917:Src/mc_interface.c ****   * @retval float_t It returns the target mechanical angular position of the rotor.
 918:Src/mc_interface.c ****   */
 919:Src/mc_interface.c **** __weak float_t MCI_GetTargetPosition(MCI_Handle_t *pHandle) //cstat !MISRAC2012-Rule-8.13
 920:Src/mc_interface.c **** {
 1776              		.loc 2 920 1
 1777              		.cfi_startproc
 1778              		@ args = 0, pretend = 0, frame = 8
 1779              		@ frame_needed = 1, uses_anonymous_args = 0
 1780 0000 80B5     		push	{r7, lr}
 1781              	.LCFI122:
 1782              		.cfi_def_cfa_offset 8
 1783              		.cfi_offset 7, -8
 1784              		.cfi_offset 14, -4
 1785 0002 82B0     		sub	sp, sp, #8
 1786              	.LCFI123:
 1787              		.cfi_def_cfa_offset 16
 1788 0004 00AF     		add	r7, sp, #0
 1789              	.LCFI124:
 1790              		.cfi_def_cfa_register 7
 1791 0006 7860     		str	r0, [r7, #4]
 921:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
 922:Src/mc_interface.c ****   return ((MC_NULL == pHandle) ? 0 : TC_GetTargetPosition(pHandle->pPosCtrl));
 923:Src/mc_interface.c **** #else
 924:Src/mc_interface.c ****   return (TC_GetTargetPosition(pHandle->pPosCtrl));
 1792              		.loc 2 924 11
 1793 0008 7B68     		ldr	r3, [r7, #4]
 1794 000a 1B69     		ldr	r3, [r3, #16]
 1795 000c 1846     		mov	r0, r3
 1796 000e FFF7FEFF 		bl	TC_GetTargetPosition
 1797 0012 F0EE407A 		vmov.f32	s15, s0
 925:Src/mc_interface.c **** #endif
 926:Src/mc_interface.c **** }
 1798              		.loc 2 926 1
 1799 0016 B0EE670A 		vmov.f32	s0, s15
 1800 001a 0837     		adds	r7, r7, #8
 1801              	.LCFI125:
 1802              		.cfi_def_cfa_offset 8
 1803 001c BD46     		mov	sp, r7
 1804              	.LCFI126:
 1805              		.cfi_def_cfa_register 13
 1806              		@ sp needed
 1807 001e 80BD     		pop	{r7, pc}
 1808              		.cfi_endproc
 1809              	.LFE1112:
 1811              		.section	.text.MCI_GetMoveDuration,"ax",%progbits
 1812              		.align	1
 1813              		.weak	MCI_GetMoveDuration
 1814              		.syntax unified
 1815              		.thumb
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 54


 1816              		.thumb_func
 1818              	MCI_GetMoveDuration:
 1819              	.LFB1113:
 927:Src/mc_interface.c **** 
 928:Src/mc_interface.c **** /**
 929:Src/mc_interface.c ****   * @brief  It returns the total movement duration to reach the final position.
 930:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
 931:Src/mc_interface.c ****   * @retval float_t It returns the movement duration allowed to reach the target position.
 932:Src/mc_interface.c ****   */
 933:Src/mc_interface.c **** __weak float_t MCI_GetMoveDuration(MCI_Handle_t *pHandle) //cstat !MISRAC2012-Rule-8.13
 934:Src/mc_interface.c **** {
 1820              		.loc 2 934 1
 1821              		.cfi_startproc
 1822              		@ args = 0, pretend = 0, frame = 8
 1823              		@ frame_needed = 1, uses_anonymous_args = 0
 1824 0000 80B5     		push	{r7, lr}
 1825              	.LCFI127:
 1826              		.cfi_def_cfa_offset 8
 1827              		.cfi_offset 7, -8
 1828              		.cfi_offset 14, -4
 1829 0002 82B0     		sub	sp, sp, #8
 1830              	.LCFI128:
 1831              		.cfi_def_cfa_offset 16
 1832 0004 00AF     		add	r7, sp, #0
 1833              	.LCFI129:
 1834              		.cfi_def_cfa_register 7
 1835 0006 7860     		str	r0, [r7, #4]
 935:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
 936:Src/mc_interface.c ****   return ((MC_NULL == pHandle) ? 0 : TC_GetMoveDuration(pHandle->pPosCtrl));
 937:Src/mc_interface.c **** #else
 938:Src/mc_interface.c ****   return (TC_GetMoveDuration(pHandle->pPosCtrl));
 1836              		.loc 2 938 11
 1837 0008 7B68     		ldr	r3, [r7, #4]
 1838 000a 1B69     		ldr	r3, [r3, #16]
 1839 000c 1846     		mov	r0, r3
 1840 000e FFF7FEFF 		bl	TC_GetMoveDuration
 1841 0012 F0EE407A 		vmov.f32	s15, s0
 939:Src/mc_interface.c **** #endif
 940:Src/mc_interface.c **** }
 1842              		.loc 2 940 1
 1843 0016 B0EE670A 		vmov.f32	s0, s15
 1844 001a 0837     		adds	r7, r7, #8
 1845              	.LCFI130:
 1846              		.cfi_def_cfa_offset 8
 1847 001c BD46     		mov	sp, r7
 1848              	.LCFI131:
 1849              		.cfi_def_cfa_register 13
 1850              		@ sp needed
 1851 001e 80BD     		pop	{r7, pc}
 1852              		.cfi_endproc
 1853              	.LFE1113:
 1855              		.section	.text.MCI_GetOccurredFaults,"ax",%progbits
 1856              		.align	1
 1857              		.weak	MCI_GetOccurredFaults
 1858              		.syntax unified
 1859              		.thumb
 1860              		.thumb_func
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 55


 1862              	MCI_GetOccurredFaults:
 1863              	.LFB1114:
 941:Src/mc_interface.c **** 
 942:Src/mc_interface.c **** /**
 943:Src/mc_interface.c ****   * @brief Returns the list of non-acknowledged faults that occured on the target motor
 944:Src/mc_interface.c ****   *
 945:Src/mc_interface.c ****   * This function returns a bitfield indicating the faults that occured since the state machine
 946:Src/mc_interface.c ****   * of the target motor has been moved into the #FAULT_NOW state.
 947:Src/mc_interface.c ****   *
 948:Src/mc_interface.c ****   * Possible error codes are listed in the @ref fault_codes "Fault codes" section.
 949:Src/mc_interface.c ****   *
 950:Src/mc_interface.c ****   * @param  pHandle Pointer on the target motor drive structure.
 951:Src/mc_interface.c ****   * @retval uint16_t  16 bit fields with information about the faults
 952:Src/mc_interface.c ****   *         historically occurred since the state machine has been moved into
 953:Src/mc_interface.c ****   */
 954:Src/mc_interface.c **** __weak uint16_t MCI_GetOccurredFaults(MCI_Handle_t *pHandle) //cstat !MISRAC2012-Rule-8.13
 955:Src/mc_interface.c **** {
 1864              		.loc 2 955 1
 1865              		.cfi_startproc
 1866              		@ args = 0, pretend = 0, frame = 8
 1867              		@ frame_needed = 1, uses_anonymous_args = 0
 1868              		@ link register save eliminated.
 1869 0000 80B4     		push	{r7}
 1870              	.LCFI132:
 1871              		.cfi_def_cfa_offset 4
 1872              		.cfi_offset 7, -4
 1873 0002 83B0     		sub	sp, sp, #12
 1874              	.LCFI133:
 1875              		.cfi_def_cfa_offset 16
 1876 0004 00AF     		add	r7, sp, #0
 1877              	.LCFI134:
 1878              		.cfi_def_cfa_register 7
 1879 0006 7860     		str	r0, [r7, #4]
 956:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
 957:Src/mc_interface.c ****   return ((MC_NULL == pHandle) ? MC_SW_ERROR : (uint16_t)pHandle->PastFaults);
 958:Src/mc_interface.c **** #else
 959:Src/mc_interface.c ****   return ((uint16_t)pHandle->PastFaults);
 1880              		.loc 2 959 11
 1881 0008 7B68     		ldr	r3, [r7, #4]
 1882 000a 5B8D     		ldrh	r3, [r3, #42]
 960:Src/mc_interface.c **** #endif
 961:Src/mc_interface.c **** }
 1883              		.loc 2 961 1
 1884 000c 1846     		mov	r0, r3
 1885 000e 0C37     		adds	r7, r7, #12
 1886              	.LCFI135:
 1887              		.cfi_def_cfa_offset 4
 1888 0010 BD46     		mov	sp, r7
 1889              	.LCFI136:
 1890              		.cfi_def_cfa_register 13
 1891              		@ sp needed
 1892 0012 5DF8047B 		ldr	r7, [sp], #4
 1893              	.LCFI137:
 1894              		.cfi_restore 7
 1895              		.cfi_def_cfa_offset 0
 1896 0016 7047     		bx	lr
 1897              		.cfi_endproc
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 56


 1898              	.LFE1114:
 1900              		.section	.text.MCI_GetCurrentFaults,"ax",%progbits
 1901              		.align	1
 1902              		.weak	MCI_GetCurrentFaults
 1903              		.syntax unified
 1904              		.thumb
 1905              		.thumb_func
 1907              	MCI_GetCurrentFaults:
 1908              	.LFB1115:
 962:Src/mc_interface.c **** 
 963:Src/mc_interface.c **** /**
 964:Src/mc_interface.c ****   * @brief Returns the list of faults that are currently active on the target motor
 965:Src/mc_interface.c ****   *
 966:Src/mc_interface.c ****   * This function returns a bitfield that indicates faults that occured on the Motor
 967:Src/mc_interface.c ****   * Control subsystem for the target motor and that are still active (the conditions
 968:Src/mc_interface.c ****   * that triggered the faults returned are still true).
 969:Src/mc_interface.c ****   *
 970:Src/mc_interface.c ****   * Possible error codes are listed in the @ref fault_codes "Fault codes" section.
 971:Src/mc_interface.c ****   *
 972:Src/mc_interface.c ****   * @param  pHandle Pointer on the target motor drive structure.
 973:Src/mc_interface.c ****   */
 974:Src/mc_interface.c **** __weak uint16_t MCI_GetCurrentFaults(MCI_Handle_t *pHandle) //cstat !MISRAC2012-Rule-8.13
 975:Src/mc_interface.c **** {
 1909              		.loc 2 975 1
 1910              		.cfi_startproc
 1911              		@ args = 0, pretend = 0, frame = 8
 1912              		@ frame_needed = 1, uses_anonymous_args = 0
 1913              		@ link register save eliminated.
 1914 0000 80B4     		push	{r7}
 1915              	.LCFI138:
 1916              		.cfi_def_cfa_offset 4
 1917              		.cfi_offset 7, -4
 1918 0002 83B0     		sub	sp, sp, #12
 1919              	.LCFI139:
 1920              		.cfi_def_cfa_offset 16
 1921 0004 00AF     		add	r7, sp, #0
 1922              	.LCFI140:
 1923              		.cfi_def_cfa_register 7
 1924 0006 7860     		str	r0, [r7, #4]
 976:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
 977:Src/mc_interface.c ****   return ((MC_NULL == pHandle) ? MC_SW_ERROR : (uint16_t)pHandle->CurrentFaults);
 978:Src/mc_interface.c **** #else
 979:Src/mc_interface.c ****   return ((uint16_t)pHandle->CurrentFaults);
 1925              		.loc 2 979 11
 1926 0008 7B68     		ldr	r3, [r7, #4]
 1927 000a 1B8D     		ldrh	r3, [r3, #40]
 980:Src/mc_interface.c **** #endif
 981:Src/mc_interface.c **** }
 1928              		.loc 2 981 1
 1929 000c 1846     		mov	r0, r3
 1930 000e 0C37     		adds	r7, r7, #12
 1931              	.LCFI141:
 1932              		.cfi_def_cfa_offset 4
 1933 0010 BD46     		mov	sp, r7
 1934              	.LCFI142:
 1935              		.cfi_def_cfa_register 13
 1936              		@ sp needed
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 57


 1937 0012 5DF8047B 		ldr	r7, [sp], #4
 1938              	.LCFI143:
 1939              		.cfi_restore 7
 1940              		.cfi_def_cfa_offset 0
 1941 0016 7047     		bx	lr
 1942              		.cfi_endproc
 1943              	.LFE1115:
 1945              		.section	.text.MCI_GetFaultState,"ax",%progbits
 1946              		.align	1
 1947              		.weak	MCI_GetFaultState
 1948              		.syntax unified
 1949              		.thumb
 1950              		.thumb_func
 1952              	MCI_GetFaultState:
 1953              	.LFB1116:
 982:Src/mc_interface.c **** 
 983:Src/mc_interface.c **** /**
 984:Src/mc_interface.c ****   * @brief Returns the lists of current and past faults that occurred on the target motor
 985:Src/mc_interface.c ****   *
 986:Src/mc_interface.c ****   *  This function returns two bitfields containing information about the faults currently
 987:Src/mc_interface.c ****   * present and the faults occurred since the state machine has been moved into the #FAULT_NOW
 988:Src/mc_interface.c ****   * state.
 989:Src/mc_interface.c ****   *
 990:Src/mc_interface.c ****   * These two bitfields are 16 bits wide each and are concatenated into the 32-bit data. The
 991:Src/mc_interface.c ****   * 16 most significant bits contains the status of the current faults while that of the
 992:Src/mc_interface.c ****   * past faults is in the 16 least significant bits.
 993:Src/mc_interface.c ****   *
 994:Src/mc_interface.c ****   * @sa MCI_GetOccurredFaults, MCI_GetCurrentFaults
 995:Src/mc_interface.c ****   *
 996:Src/mc_interface.c ****   * @param  pHandle Pointer on the target motor drive structure.
 997:Src/mc_interface.c ****   */
 998:Src/mc_interface.c **** __weak uint32_t MCI_GetFaultState(MCI_Handle_t *pHandle) //cstat !MISRAC2012-Rule-8.13
 999:Src/mc_interface.c **** {
 1954              		.loc 2 999 1
 1955              		.cfi_startproc
 1956              		@ args = 0, pretend = 0, frame = 16
 1957              		@ frame_needed = 1, uses_anonymous_args = 0
 1958              		@ link register save eliminated.
 1959 0000 80B4     		push	{r7}
 1960              	.LCFI144:
 1961              		.cfi_def_cfa_offset 4
 1962              		.cfi_offset 7, -4
 1963 0002 85B0     		sub	sp, sp, #20
 1964              	.LCFI145:
 1965              		.cfi_def_cfa_offset 24
 1966 0004 00AF     		add	r7, sp, #0
 1967              	.LCFI146:
 1968              		.cfi_def_cfa_register 7
 1969 0006 7860     		str	r0, [r7, #4]
1000:Src/mc_interface.c ****   uint32_t LocalFaultState;
1001:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
1002:Src/mc_interface.c ****   if (MC_NULL == pHandle)
1003:Src/mc_interface.c ****   {
1004:Src/mc_interface.c ****     LocalFaultState = MC_SW_ERROR | (MC_SW_ERROR << 16);
1005:Src/mc_interface.c ****   }
1006:Src/mc_interface.c ****   else
1007:Src/mc_interface.c ****   {
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 58


1008:Src/mc_interface.c **** #endif
1009:Src/mc_interface.c ****     LocalFaultState = (uint32_t)(pHandle->PastFaults);
 1970              		.loc 2 1009 41
 1971 0008 7B68     		ldr	r3, [r7, #4]
 1972 000a 5B8D     		ldrh	r3, [r3, #42]
 1973              		.loc 2 1009 21
 1974 000c FB60     		str	r3, [r7, #12]
1010:Src/mc_interface.c ****     LocalFaultState |= (uint32_t)(pHandle->CurrentFaults) << 16;
 1975              		.loc 2 1010 42
 1976 000e 7B68     		ldr	r3, [r7, #4]
 1977 0010 1B8D     		ldrh	r3, [r3, #40]
 1978              		.loc 2 1010 59
 1979 0012 1B04     		lsls	r3, r3, #16
 1980              		.loc 2 1010 21
 1981 0014 FA68     		ldr	r2, [r7, #12]
 1982 0016 1343     		orrs	r3, r3, r2
 1983 0018 FB60     		str	r3, [r7, #12]
1011:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
1012:Src/mc_interface.c ****   }
1013:Src/mc_interface.c **** #endif
1014:Src/mc_interface.c ****   return (LocalFaultState);
 1984              		.loc 2 1014 10
 1985 001a FB68     		ldr	r3, [r7, #12]
1015:Src/mc_interface.c **** }
 1986              		.loc 2 1015 1
 1987 001c 1846     		mov	r0, r3
 1988 001e 1437     		adds	r7, r7, #20
 1989              	.LCFI147:
 1990              		.cfi_def_cfa_offset 4
 1991 0020 BD46     		mov	sp, r7
 1992              	.LCFI148:
 1993              		.cfi_def_cfa_register 13
 1994              		@ sp needed
 1995 0022 5DF8047B 		ldr	r7, [sp], #4
 1996              	.LCFI149:
 1997              		.cfi_restore 7
 1998              		.cfi_def_cfa_offset 0
 1999 0026 7047     		bx	lr
 2000              		.cfi_endproc
 2001              	.LFE1116:
 2003              		.section	.text.MCI_GetControlMode,"ax",%progbits
 2004              		.align	1
 2005              		.weak	MCI_GetControlMode
 2006              		.syntax unified
 2007              		.thumb
 2008              		.thumb_func
 2010              	MCI_GetControlMode:
 2011              	.LFB1117:
1016:Src/mc_interface.c **** 
1017:Src/mc_interface.c **** /**
1018:Src/mc_interface.c ****   * @brief  It returns the modality of the speed and torque controller.
1019:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
1020:Src/mc_interface.c ****   * @retval MC_ControlMode_t It returns the modality of STC. It can be one of
1021:Src/mc_interface.c ****   *         these two values: MCM_TORQUE_MODE or MCM_SPEED_MODE.
1022:Src/mc_interface.c ****   */
1023:Src/mc_interface.c **** __weak MC_ControlMode_t MCI_GetControlMode(MCI_Handle_t *pHandle) //cstat !MISRAC2012-Rule-8.13
1024:Src/mc_interface.c **** {
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 59


 2012              		.loc 2 1024 1
 2013              		.cfi_startproc
 2014              		@ args = 0, pretend = 0, frame = 8
 2015              		@ frame_needed = 1, uses_anonymous_args = 0
 2016              		@ link register save eliminated.
 2017 0000 80B4     		push	{r7}
 2018              	.LCFI150:
 2019              		.cfi_def_cfa_offset 4
 2020              		.cfi_offset 7, -4
 2021 0002 83B0     		sub	sp, sp, #12
 2022              	.LCFI151:
 2023              		.cfi_def_cfa_offset 16
 2024 0004 00AF     		add	r7, sp, #0
 2025              	.LCFI152:
 2026              		.cfi_def_cfa_register 7
 2027 0006 7860     		str	r0, [r7, #4]
1025:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
1026:Src/mc_interface.c ****   return ((MC_NULL == pHandle) ? MCM_TORQUE_MODE : pHandle->LastModalitySetByUser);
1027:Src/mc_interface.c **** #else
1028:Src/mc_interface.c ****   return (pHandle->LastModalitySetByUser);
 2028              		.loc 2 1028 18
 2029 0008 7B68     		ldr	r3, [r7, #4]
 2030 000a 93F82D30 		ldrb	r3, [r3, #45]	@ zero_extendqisi2
1029:Src/mc_interface.c **** #endif
1030:Src/mc_interface.c **** }
 2031              		.loc 2 1030 1
 2032 000e 1846     		mov	r0, r3
 2033 0010 0C37     		adds	r7, r7, #12
 2034              	.LCFI153:
 2035              		.cfi_def_cfa_offset 4
 2036 0012 BD46     		mov	sp, r7
 2037              	.LCFI154:
 2038              		.cfi_def_cfa_register 13
 2039              		@ sp needed
 2040 0014 5DF8047B 		ldr	r7, [sp], #4
 2041              	.LCFI155:
 2042              		.cfi_restore 7
 2043              		.cfi_def_cfa_offset 0
 2044 0018 7047     		bx	lr
 2045              		.cfi_endproc
 2046              	.LFE1117:
 2048              		.section	.text.MCI_GetImposedMotorDirection,"ax",%progbits
 2049              		.align	1
 2050              		.weak	MCI_GetImposedMotorDirection
 2051              		.syntax unified
 2052              		.thumb
 2053              		.thumb_func
 2055              	MCI_GetImposedMotorDirection:
 2056              	.LFB1118:
1031:Src/mc_interface.c **** 
1032:Src/mc_interface.c **** /**
1033:Src/mc_interface.c ****   * @brief  It returns the motor direction imposed by the last command
1034:Src/mc_interface.c ****   *         (MCI_ExecSpeedRamp, MCI_ExecTorqueRamp or MCI_SetCurrentReferences).
1035:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
1036:Src/mc_interface.c ****   * @retval int16_t It returns 1 or -1 according the sign of hFinalSpeed,
1037:Src/mc_interface.c ****   *         hFinalTorque or Iqdref.q of the last command.
1038:Src/mc_interface.c ****   */
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 60


1039:Src/mc_interface.c **** __weak int16_t MCI_GetImposedMotorDirection(MCI_Handle_t *pHandle) //cstat !MISRAC2012-Rule-8.13
1040:Src/mc_interface.c **** {
 2057              		.loc 2 1040 1
 2058              		.cfi_startproc
 2059              		@ args = 0, pretend = 0, frame = 16
 2060              		@ frame_needed = 1, uses_anonymous_args = 0
 2061              		@ link register save eliminated.
 2062 0000 80B4     		push	{r7}
 2063              	.LCFI156:
 2064              		.cfi_def_cfa_offset 4
 2065              		.cfi_offset 7, -4
 2066 0002 85B0     		sub	sp, sp, #20
 2067              	.LCFI157:
 2068              		.cfi_def_cfa_offset 24
 2069 0004 00AF     		add	r7, sp, #0
 2070              	.LCFI158:
 2071              		.cfi_def_cfa_register 7
 2072 0006 7860     		str	r0, [r7, #4]
1041:Src/mc_interface.c ****   int16_t retVal = 1;
 2073              		.loc 2 1041 11
 2074 0008 0123     		movs	r3, #1
 2075 000a FB81     		strh	r3, [r7, #14]	@ movhi
1042:Src/mc_interface.c **** 
1043:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
1044:Src/mc_interface.c ****   if (MC_NULL == pHandle)
1045:Src/mc_interface.c ****   {
1046:Src/mc_interface.c ****     /* Nothing to do */
1047:Src/mc_interface.c ****   }
1048:Src/mc_interface.c ****   else
1049:Src/mc_interface.c ****   {
1050:Src/mc_interface.c **** #endif
1051:Src/mc_interface.c ****     switch (pHandle->lastCommand)
 2076              		.loc 2 1051 20
 2077 000c 7B68     		ldr	r3, [r7, #4]
 2078 000e 1B7D     		ldrb	r3, [r3, #20]	@ zero_extendqisi2
 2079              		.loc 2 1051 5
 2080 0010 032B     		cmp	r3, #3
 2081 0012 18D0     		beq	.L81
 2082 0014 032B     		cmp	r3, #3
 2083 0016 1FDC     		bgt	.L90
 2084 0018 012B     		cmp	r3, #1
 2085 001a 02D0     		beq	.L83
 2086 001c 022B     		cmp	r3, #2
 2087 001e 09D0     		beq	.L84
1052:Src/mc_interface.c ****     {
1053:Src/mc_interface.c ****       case MCI_CMD_EXECSPEEDRAMP:
1054:Src/mc_interface.c ****       {
1055:Src/mc_interface.c ****         if (pHandle->hFinalSpeed < 0)
1056:Src/mc_interface.c ****         {
1057:Src/mc_interface.c ****           retVal = -1;
1058:Src/mc_interface.c ****         }
1059:Src/mc_interface.c ****         else
1060:Src/mc_interface.c ****         {
1061:Src/mc_interface.c ****           /* Nothing to do */
1062:Src/mc_interface.c ****         }
1063:Src/mc_interface.c ****         break;
1064:Src/mc_interface.c ****       }
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 61


1065:Src/mc_interface.c **** 
1066:Src/mc_interface.c ****       case MCI_CMD_EXECTORQUERAMP:
1067:Src/mc_interface.c ****       {
1068:Src/mc_interface.c ****         if (pHandle->hFinalTorque < 0)
1069:Src/mc_interface.c ****         {
1070:Src/mc_interface.c ****           retVal = -1;
1071:Src/mc_interface.c ****         }
1072:Src/mc_interface.c ****         else
1073:Src/mc_interface.c ****         {
1074:Src/mc_interface.c ****           /* Nothing to do */
1075:Src/mc_interface.c ****         }
1076:Src/mc_interface.c ****         break;
1077:Src/mc_interface.c ****       }
1078:Src/mc_interface.c **** 
1079:Src/mc_interface.c ****       case MCI_CMD_SETCURRENTREFERENCES:
1080:Src/mc_interface.c ****       {
1081:Src/mc_interface.c ****         if (pHandle->Iqdref.q < 0)
1082:Src/mc_interface.c ****         {
1083:Src/mc_interface.c ****           retVal = -1;
1084:Src/mc_interface.c ****         }
1085:Src/mc_interface.c ****         else
1086:Src/mc_interface.c ****         {
1087:Src/mc_interface.c ****           /* Nothing to do */
1088:Src/mc_interface.c ****         }
1089:Src/mc_interface.c ****         break;
1090:Src/mc_interface.c ****        }
1091:Src/mc_interface.c ****       default:
1092:Src/mc_interface.c ****         break;
 2088              		.loc 2 1092 9
 2089 0020 1AE0     		b	.L90
 2090              	.L83:
1055:Src/mc_interface.c ****         {
 2091              		.loc 2 1055 20
 2092 0022 7B68     		ldr	r3, [r7, #4]
 2093 0024 B3F91630 		ldrsh	r3, [r3, #22]
1055:Src/mc_interface.c ****         {
 2094              		.loc 2 1055 12
 2095 0028 002B     		cmp	r3, #0
 2096 002a 17DA     		bge	.L91
1057:Src/mc_interface.c ****         }
 2097              		.loc 2 1057 18
 2098 002c 4FF6FF73 		movw	r3, #65535
 2099 0030 FB81     		strh	r3, [r7, #14]	@ movhi
1063:Src/mc_interface.c ****       }
 2100              		.loc 2 1063 9
 2101 0032 13E0     		b	.L91
 2102              	.L84:
1068:Src/mc_interface.c ****         {
 2103              		.loc 2 1068 20
 2104 0034 7B68     		ldr	r3, [r7, #4]
 2105 0036 B3F91830 		ldrsh	r3, [r3, #24]
1068:Src/mc_interface.c ****         {
 2106              		.loc 2 1068 12
 2107 003a 002B     		cmp	r3, #0
 2108 003c 10DA     		bge	.L92
1070:Src/mc_interface.c ****         }
 2109              		.loc 2 1070 18
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 62


 2110 003e 4FF6FF73 		movw	r3, #65535
 2111 0042 FB81     		strh	r3, [r7, #14]	@ movhi
1076:Src/mc_interface.c ****       }
 2112              		.loc 2 1076 9
 2113 0044 0CE0     		b	.L92
 2114              	.L81:
1081:Src/mc_interface.c ****         {
 2115              		.loc 2 1081 28
 2116 0046 7B68     		ldr	r3, [r7, #4]
 2117 0048 B3F91A30 		ldrsh	r3, [r3, #26]
1081:Src/mc_interface.c ****         {
 2118              		.loc 2 1081 12
 2119 004c 002B     		cmp	r3, #0
 2120 004e 09DA     		bge	.L93
1083:Src/mc_interface.c ****         }
 2121              		.loc 2 1083 18
 2122 0050 4FF6FF73 		movw	r3, #65535
 2123 0054 FB81     		strh	r3, [r7, #14]	@ movhi
1089:Src/mc_interface.c ****        }
 2124              		.loc 2 1089 9
 2125 0056 05E0     		b	.L93
 2126              	.L90:
 2127              		.loc 2 1092 9
 2128 0058 00BF     		nop
 2129 005a 04E0     		b	.L86
 2130              	.L91:
1063:Src/mc_interface.c ****       }
 2131              		.loc 2 1063 9
 2132 005c 00BF     		nop
 2133 005e 02E0     		b	.L86
 2134              	.L92:
1076:Src/mc_interface.c ****       }
 2135              		.loc 2 1076 9
 2136 0060 00BF     		nop
 2137 0062 00E0     		b	.L86
 2138              	.L93:
1089:Src/mc_interface.c ****        }
 2139              		.loc 2 1089 9
 2140 0064 00BF     		nop
 2141              	.L86:
1093:Src/mc_interface.c ****     }
1094:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
1095:Src/mc_interface.c ****   }
1096:Src/mc_interface.c **** #endif
1097:Src/mc_interface.c ****   return (retVal);
 2142              		.loc 2 1097 10
 2143 0066 B7F90E30 		ldrsh	r3, [r7, #14]
1098:Src/mc_interface.c **** }
 2144              		.loc 2 1098 1
 2145 006a 1846     		mov	r0, r3
 2146 006c 1437     		adds	r7, r7, #20
 2147              	.LCFI159:
 2148              		.cfi_def_cfa_offset 4
 2149 006e BD46     		mov	sp, r7
 2150              	.LCFI160:
 2151              		.cfi_def_cfa_register 13
 2152              		@ sp needed
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 63


 2153 0070 5DF8047B 		ldr	r7, [sp], #4
 2154              	.LCFI161:
 2155              		.cfi_restore 7
 2156              		.cfi_def_cfa_offset 0
 2157 0074 7047     		bx	lr
 2158              		.cfi_endproc
 2159              	.LFE1118:
 2161              		.section	.text.MCI_GetLastRampFinalSpeed,"ax",%progbits
 2162              		.align	1
 2163              		.weak	MCI_GetLastRampFinalSpeed
 2164              		.syntax unified
 2165              		.thumb
 2166              		.thumb_func
 2168              	MCI_GetLastRampFinalSpeed:
 2169              	.LFB1119:
1099:Src/mc_interface.c **** 
1100:Src/mc_interface.c **** /**
1101:Src/mc_interface.c ****   * @brief  It returns information about the last ramp final speed sent by the
1102:Src/mc_interface.c ****   *         user expressed in the unit defined by #SPEED_UNIT.
1103:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
1104:Src/mc_interface.c ****   * @retval int16_t last ramp final speed sent by the user expressed in
1105:Src/mc_interface.c ****   *         the unit defined by #SPEED_UNIT.
1106:Src/mc_interface.c ****   */
1107:Src/mc_interface.c **** __weak int16_t MCI_GetLastRampFinalSpeed(MCI_Handle_t *pHandle) //cstat !MISRAC2012-Rule-8.13
1108:Src/mc_interface.c **** {
 2170              		.loc 2 1108 1
 2171              		.cfi_startproc
 2172              		@ args = 0, pretend = 0, frame = 8
 2173              		@ frame_needed = 1, uses_anonymous_args = 0
 2174              		@ link register save eliminated.
 2175 0000 80B4     		push	{r7}
 2176              	.LCFI162:
 2177              		.cfi_def_cfa_offset 4
 2178              		.cfi_offset 7, -4
 2179 0002 83B0     		sub	sp, sp, #12
 2180              	.LCFI163:
 2181              		.cfi_def_cfa_offset 16
 2182 0004 00AF     		add	r7, sp, #0
 2183              	.LCFI164:
 2184              		.cfi_def_cfa_register 7
 2185 0006 7860     		str	r0, [r7, #4]
1109:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
1110:Src/mc_interface.c ****   int16_t retVal = 0;
1111:Src/mc_interface.c **** 
1112:Src/mc_interface.c ****   if (MC_NULL == pHandle)
1113:Src/mc_interface.c ****   {
1114:Src/mc_interface.c ****     /* Nothing to do */
1115:Src/mc_interface.c ****   }
1116:Src/mc_interface.c ****   else
1117:Src/mc_interface.c ****   {
1118:Src/mc_interface.c ****     retVal = pHandle->hFinalSpeed;
1119:Src/mc_interface.c ****   }
1120:Src/mc_interface.c ****   return (retVal);
1121:Src/mc_interface.c **** #else
1122:Src/mc_interface.c ****   return (pHandle->hFinalSpeed);
 2186              		.loc 2 1122 18
 2187 0008 7B68     		ldr	r3, [r7, #4]
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 64


 2188 000a B3F91630 		ldrsh	r3, [r3, #22]
1123:Src/mc_interface.c **** #endif
1124:Src/mc_interface.c **** }
 2189              		.loc 2 1124 1
 2190 000e 1846     		mov	r0, r3
 2191 0010 0C37     		adds	r7, r7, #12
 2192              	.LCFI165:
 2193              		.cfi_def_cfa_offset 4
 2194 0012 BD46     		mov	sp, r7
 2195              	.LCFI166:
 2196              		.cfi_def_cfa_register 13
 2197              		@ sp needed
 2198 0014 5DF8047B 		ldr	r7, [sp], #4
 2199              	.LCFI167:
 2200              		.cfi_restore 7
 2201              		.cfi_def_cfa_offset 0
 2202 0018 7047     		bx	lr
 2203              		.cfi_endproc
 2204              	.LFE1119:
 2206              		.section	.text.MCI_GetLastRampFinalTorque,"ax",%progbits
 2207              		.align	1
 2208              		.weak	MCI_GetLastRampFinalTorque
 2209              		.syntax unified
 2210              		.thumb
 2211              		.thumb_func
 2213              	MCI_GetLastRampFinalTorque:
 2214              	.LFB1120:
1125:Src/mc_interface.c **** 
1126:Src/mc_interface.c **** /**
1127:Src/mc_interface.c ****   * @brief  It returns information about the last ramp final torque sent by the
1128:Src/mc_interface.c ****   *         user .This value represents actually the Iq current expressed in
1129:Src/mc_interface.c ****   *         digit.
1130:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
1131:Src/mc_interface.c ****   * @retval int16_t last ramp final torque sent by the user expressed in digit
1132:Src/mc_interface.c ****   */
1133:Src/mc_interface.c **** __weak int16_t MCI_GetLastRampFinalTorque(MCI_Handle_t *pHandle) //cstat !MISRAC2012-Rule-8.13
1134:Src/mc_interface.c **** {
 2215              		.loc 2 1134 1
 2216              		.cfi_startproc
 2217              		@ args = 0, pretend = 0, frame = 8
 2218              		@ frame_needed = 1, uses_anonymous_args = 0
 2219              		@ link register save eliminated.
 2220 0000 80B4     		push	{r7}
 2221              	.LCFI168:
 2222              		.cfi_def_cfa_offset 4
 2223              		.cfi_offset 7, -4
 2224 0002 83B0     		sub	sp, sp, #12
 2225              	.LCFI169:
 2226              		.cfi_def_cfa_offset 16
 2227 0004 00AF     		add	r7, sp, #0
 2228              	.LCFI170:
 2229              		.cfi_def_cfa_register 7
 2230 0006 7860     		str	r0, [r7, #4]
1135:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
1136:Src/mc_interface.c ****   int16_t retVal = 0;
1137:Src/mc_interface.c **** 
1138:Src/mc_interface.c ****   if (MC_NULL == pHandle)
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 65


1139:Src/mc_interface.c ****   {
1140:Src/mc_interface.c ****     /* Nothing to do */
1141:Src/mc_interface.c ****   }
1142:Src/mc_interface.c ****   else
1143:Src/mc_interface.c ****   {
1144:Src/mc_interface.c ****     retVal = pHandle->hFinalTorque;
1145:Src/mc_interface.c ****   }
1146:Src/mc_interface.c ****   return (retVal);
1147:Src/mc_interface.c **** #else
1148:Src/mc_interface.c ****   return (pHandle->hFinalTorque);
 2231              		.loc 2 1148 18
 2232 0008 7B68     		ldr	r3, [r7, #4]
 2233 000a B3F91830 		ldrsh	r3, [r3, #24]
1149:Src/mc_interface.c **** #endif
1150:Src/mc_interface.c **** }
 2234              		.loc 2 1150 1
 2235 000e 1846     		mov	r0, r3
 2236 0010 0C37     		adds	r7, r7, #12
 2237              	.LCFI171:
 2238              		.cfi_def_cfa_offset 4
 2239 0012 BD46     		mov	sp, r7
 2240              	.LCFI172:
 2241              		.cfi_def_cfa_register 13
 2242              		@ sp needed
 2243 0014 5DF8047B 		ldr	r7, [sp], #4
 2244              	.LCFI173:
 2245              		.cfi_restore 7
 2246              		.cfi_def_cfa_offset 0
 2247 0018 7047     		bx	lr
 2248              		.cfi_endproc
 2249              	.LFE1120:
 2251              		.section	.text.MCI_GetLastRampFinalDuration,"ax",%progbits
 2252              		.align	1
 2253              		.weak	MCI_GetLastRampFinalDuration
 2254              		.syntax unified
 2255              		.thumb
 2256              		.thumb_func
 2258              	MCI_GetLastRampFinalDuration:
 2259              	.LFB1121:
1151:Src/mc_interface.c **** 
1152:Src/mc_interface.c **** /**
1153:Src/mc_interface.c ****   * @brief  It returns information about the last ramp Duration sent by the
1154:Src/mc_interface.c ****   *         user .
1155:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
1156:Src/mc_interface.c ****   * @retval uint16_t last ramp final torque sent by the user expressed in digit
1157:Src/mc_interface.c ****   */
1158:Src/mc_interface.c **** __weak uint16_t MCI_GetLastRampFinalDuration(MCI_Handle_t *pHandle) //cstat !MISRAC2012-Rule-8.13
1159:Src/mc_interface.c **** {
 2260              		.loc 2 1159 1
 2261              		.cfi_startproc
 2262              		@ args = 0, pretend = 0, frame = 8
 2263              		@ frame_needed = 1, uses_anonymous_args = 0
 2264              		@ link register save eliminated.
 2265 0000 80B4     		push	{r7}
 2266              	.LCFI174:
 2267              		.cfi_def_cfa_offset 4
 2268              		.cfi_offset 7, -4
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 66


 2269 0002 83B0     		sub	sp, sp, #12
 2270              	.LCFI175:
 2271              		.cfi_def_cfa_offset 16
 2272 0004 00AF     		add	r7, sp, #0
 2273              	.LCFI176:
 2274              		.cfi_def_cfa_register 7
 2275 0006 7860     		str	r0, [r7, #4]
1160:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
1161:Src/mc_interface.c ****   uint16_t retVal = 0;
1162:Src/mc_interface.c **** 
1163:Src/mc_interface.c ****   if (MC_NULL == pHandle)
1164:Src/mc_interface.c ****   {
1165:Src/mc_interface.c ****     /* Nothing to do */
1166:Src/mc_interface.c ****   }
1167:Src/mc_interface.c ****   else
1168:Src/mc_interface.c ****   {
1169:Src/mc_interface.c ****     retVal = pHandle->hDurationms;
1170:Src/mc_interface.c ****   }
1171:Src/mc_interface.c ****   return (retVal);
1172:Src/mc_interface.c **** #else
1173:Src/mc_interface.c ****   return (pHandle->hDurationms);
 2276              		.loc 2 1173 18
 2277 0008 7B68     		ldr	r3, [r7, #4]
 2278 000a 9B8C     		ldrh	r3, [r3, #36]
1174:Src/mc_interface.c **** #endif
1175:Src/mc_interface.c **** }
 2279              		.loc 2 1175 1
 2280 000c 1846     		mov	r0, r3
 2281 000e 0C37     		adds	r7, r7, #12
 2282              	.LCFI177:
 2283              		.cfi_def_cfa_offset 4
 2284 0010 BD46     		mov	sp, r7
 2285              	.LCFI178:
 2286              		.cfi_def_cfa_register 13
 2287              		@ sp needed
 2288 0012 5DF8047B 		ldr	r7, [sp], #4
 2289              	.LCFI179:
 2290              		.cfi_restore 7
 2291              		.cfi_def_cfa_offset 0
 2292 0016 7047     		bx	lr
 2293              		.cfi_endproc
 2294              	.LFE1121:
 2296              		.section	.text.MCI_GetLastRampFinalSpeed_F,"ax",%progbits
 2297              		.align	1
 2298              		.weak	MCI_GetLastRampFinalSpeed_F
 2299              		.syntax unified
 2300              		.thumb
 2301              		.thumb_func
 2303              	MCI_GetLastRampFinalSpeed_F:
 2304              	.LFB1122:
1176:Src/mc_interface.c **** 
1177:Src/mc_interface.c **** /**
1178:Src/mc_interface.c ****   * @brief  It returns last ramp final speed expressed in rpm.
1179:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
1180:Src/mc_interface.c ****   * @retval float_t last ramp final speed sent by the user expressed in rpm.
1181:Src/mc_interface.c ****   */
1182:Src/mc_interface.c **** __weak float_t MCI_GetLastRampFinalSpeed_F(MCI_Handle_t *pHandle) //cstat !MISRAC2012-Rule-8.13
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 67


1183:Src/mc_interface.c **** {
 2305              		.loc 2 1183 1
 2306              		.cfi_startproc
 2307              		@ args = 0, pretend = 0, frame = 16
 2308              		@ frame_needed = 1, uses_anonymous_args = 0
 2309              		@ link register save eliminated.
 2310 0000 80B4     		push	{r7}
 2311              	.LCFI180:
 2312              		.cfi_def_cfa_offset 4
 2313              		.cfi_offset 7, -4
 2314 0002 85B0     		sub	sp, sp, #20
 2315              	.LCFI181:
 2316              		.cfi_def_cfa_offset 24
 2317 0004 00AF     		add	r7, sp, #0
 2318              	.LCFI182:
 2319              		.cfi_def_cfa_register 7
 2320 0006 7860     		str	r0, [r7, #4]
1184:Src/mc_interface.c ****   float_t reVal = 0.0f;
 2321              		.loc 2 1184 11
 2322 0008 4FF00003 		mov	r3, #0
 2323 000c FB60     		str	r3, [r7, #12]	@ float
1185:Src/mc_interface.c **** 
1186:Src/mc_interface.c ****   if (MC_NULL == pHandle)
 2324              		.loc 2 1186 6
 2325 000e 7B68     		ldr	r3, [r7, #4]
 2326 0010 002B     		cmp	r3, #0
 2327 0012 10D0     		beq	.L101
1187:Src/mc_interface.c ****   {
1188:Src/mc_interface.c ****     /* Nothing to do */
1189:Src/mc_interface.c ****   }
1190:Src/mc_interface.c ****   else
1191:Src/mc_interface.c ****   {
1192:Src/mc_interface.c ****     reVal = (((float_t)pHandle->hFinalSpeed * (float_t)U_RPM) / (float_t)SPEED_UNIT);
 2328              		.loc 2 1192 31
 2329 0014 7B68     		ldr	r3, [r7, #4]
 2330 0016 B3F91630 		ldrsh	r3, [r3, #22]
 2331              		.loc 2 1192 15
 2332 001a 07EE903A 		vmov	s15, r3	@ int
 2333 001e F8EEE77A 		vcvt.f32.s32	s15, s15
 2334              		.loc 2 1192 45
 2335 0022 9FED0A7A 		vldr.32	s14, .L103
 2336 0026 27EE877A 		vmul.f32	s14, s15, s14
 2337              		.loc 2 1192 11
 2338 002a F2EE046A 		vmov.f32	s13, #1.0e+1
 2339 002e C7EE267A 		vdiv.f32	s15, s14, s13
 2340 0032 C7ED037A 		vstr.32	s15, [r7, #12]
 2341              	.L101:
1193:Src/mc_interface.c ****   }
1194:Src/mc_interface.c ****   return (reVal);
 2342              		.loc 2 1194 10
 2343 0036 FB68     		ldr	r3, [r7, #12]	@ float
 2344 0038 07EE903A 		vmov	s15, r3
1195:Src/mc_interface.c **** }
 2345              		.loc 2 1195 1
 2346 003c B0EE670A 		vmov.f32	s0, s15
 2347 0040 1437     		adds	r7, r7, #20
 2348              	.LCFI183:
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 68


 2349              		.cfi_def_cfa_offset 4
 2350 0042 BD46     		mov	sp, r7
 2351              	.LCFI184:
 2352              		.cfi_def_cfa_register 13
 2353              		@ sp needed
 2354 0044 5DF8047B 		ldr	r7, [sp], #4
 2355              	.LCFI185:
 2356              		.cfi_restore 7
 2357              		.cfi_def_cfa_offset 0
 2358 0048 7047     		bx	lr
 2359              	.L104:
 2360 004a 00BF     		.align	2
 2361              	.L103:
 2362 004c 00007042 		.word	1114636288
 2363              		.cfi_endproc
 2364              	.LFE1122:
 2366              		.section	.text.MCI_RampCompleted,"ax",%progbits
 2367              		.align	1
 2368              		.weak	MCI_RampCompleted
 2369              		.syntax unified
 2370              		.thumb
 2371              		.thumb_func
 2373              	MCI_RampCompleted:
 2374              	.LFB1123:
1196:Src/mc_interface.c **** 
1197:Src/mc_interface.c **** /**
1198:Src/mc_interface.c ****   * @brief  Check if the settled speed or torque ramp has been completed.
1199:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
1200:Src/mc_interface.c ****   * @retval bool It returns true if the ramp is completed, false otherwise.
1201:Src/mc_interface.c ****   */
1202:Src/mc_interface.c **** __weak bool MCI_RampCompleted(MCI_Handle_t *pHandle)
1203:Src/mc_interface.c **** {
 2375              		.loc 2 1203 1
 2376              		.cfi_startproc
 2377              		@ args = 0, pretend = 0, frame = 16
 2378              		@ frame_needed = 1, uses_anonymous_args = 0
 2379 0000 80B5     		push	{r7, lr}
 2380              	.LCFI186:
 2381              		.cfi_def_cfa_offset 8
 2382              		.cfi_offset 7, -8
 2383              		.cfi_offset 14, -4
 2384 0002 84B0     		sub	sp, sp, #16
 2385              	.LCFI187:
 2386              		.cfi_def_cfa_offset 24
 2387 0004 00AF     		add	r7, sp, #0
 2388              	.LCFI188:
 2389              		.cfi_def_cfa_register 7
 2390 0006 7860     		str	r0, [r7, #4]
1204:Src/mc_interface.c ****   bool retVal = false;
 2391              		.loc 2 1204 8
 2392 0008 0023     		movs	r3, #0
 2393 000a FB73     		strb	r3, [r7, #15]
1205:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
1206:Src/mc_interface.c ****   if (MC_NULL == pHandle)
1207:Src/mc_interface.c ****   {
1208:Src/mc_interface.c ****     /* Nothing to do */
1209:Src/mc_interface.c ****   }
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 69


1210:Src/mc_interface.c ****   else
1211:Src/mc_interface.c ****   {
1212:Src/mc_interface.c **** #endif
1213:Src/mc_interface.c ****     if (RUN == MCI_GetSTMState(pHandle))
 2394              		.loc 2 1213 16
 2395 000c 7868     		ldr	r0, [r7, #4]
 2396 000e FFF7FEFF 		bl	MCI_GetSTMState
 2397 0012 0346     		mov	r3, r0
 2398              		.loc 2 1213 8
 2399 0014 062B     		cmp	r3, #6
 2400 0016 06D1     		bne	.L106
1214:Src/mc_interface.c ****     {
1215:Src/mc_interface.c ****       retVal = STC_RampCompleted(pHandle->pSTC);
 2401              		.loc 2 1215 16
 2402 0018 7B68     		ldr	r3, [r7, #4]
 2403 001a 1B68     		ldr	r3, [r3]
 2404 001c 1846     		mov	r0, r3
 2405 001e FFF7FEFF 		bl	STC_RampCompleted
 2406 0022 0346     		mov	r3, r0
 2407 0024 FB73     		strb	r3, [r7, #15]
 2408              	.L106:
1216:Src/mc_interface.c ****     }
1217:Src/mc_interface.c ****     else
1218:Src/mc_interface.c ****     {
1219:Src/mc_interface.c ****       /* Nothing to do */
1220:Src/mc_interface.c ****     }
1221:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
1222:Src/mc_interface.c ****   }
1223:Src/mc_interface.c **** #endif
1224:Src/mc_interface.c ****   return (retVal);
 2409              		.loc 2 1224 10
 2410 0026 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
1225:Src/mc_interface.c **** }
 2411              		.loc 2 1225 1
 2412 0028 1846     		mov	r0, r3
 2413 002a 1037     		adds	r7, r7, #16
 2414              	.LCFI189:
 2415              		.cfi_def_cfa_offset 8
 2416 002c BD46     		mov	sp, r7
 2417              	.LCFI190:
 2418              		.cfi_def_cfa_register 13
 2419              		@ sp needed
 2420 002e 80BD     		pop	{r7, pc}
 2421              		.cfi_endproc
 2422              	.LFE1123:
 2424              		.section	.text.MCI_StopSpeedRamp,"ax",%progbits
 2425              		.align	1
 2426              		.weak	MCI_StopSpeedRamp
 2427              		.syntax unified
 2428              		.thumb
 2429              		.thumb_func
 2431              	MCI_StopSpeedRamp:
 2432              	.LFB1124:
1226:Src/mc_interface.c **** 
1227:Src/mc_interface.c **** /**
1228:Src/mc_interface.c ****   * @brief  Stop the execution of speed ramp.
1229:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 70


1230:Src/mc_interface.c ****   * @retval bool It returns true if the command is executed, false otherwise.
1231:Src/mc_interface.c ****   *
1232:Src/mc_interface.c ****   * @deprecated This function is deprecated and should not be used anymore. It will be
1233:Src/mc_interface.c ****   *             removed in a future version of the MCSDK. Use MCI_StopRamp() instead.
1234:Src/mc_interface.c ****   */
1235:Src/mc_interface.c **** __weak bool MCI_StopSpeedRamp(MCI_Handle_t *pHandle)
1236:Src/mc_interface.c **** {
 2433              		.loc 2 1236 1
 2434              		.cfi_startproc
 2435              		@ args = 0, pretend = 0, frame = 8
 2436              		@ frame_needed = 1, uses_anonymous_args = 0
 2437 0000 80B5     		push	{r7, lr}
 2438              	.LCFI191:
 2439              		.cfi_def_cfa_offset 8
 2440              		.cfi_offset 7, -8
 2441              		.cfi_offset 14, -4
 2442 0002 82B0     		sub	sp, sp, #8
 2443              	.LCFI192:
 2444              		.cfi_def_cfa_offset 16
 2445 0004 00AF     		add	r7, sp, #0
 2446              	.LCFI193:
 2447              		.cfi_def_cfa_register 7
 2448 0006 7860     		str	r0, [r7, #4]
1237:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
1238:Src/mc_interface.c ****   return ((MC_NULL == pHandle) ? false : STC_StopSpeedRamp(pHandle->pSTC));
1239:Src/mc_interface.c **** #else
1240:Src/mc_interface.c ****   return (STC_StopSpeedRamp(pHandle->pSTC));
 2449              		.loc 2 1240 11
 2450 0008 7B68     		ldr	r3, [r7, #4]
 2451 000a 1B68     		ldr	r3, [r3]
 2452 000c 1846     		mov	r0, r3
 2453 000e FFF7FEFF 		bl	STC_StopSpeedRamp
 2454 0012 0346     		mov	r3, r0
1241:Src/mc_interface.c **** #endif
1242:Src/mc_interface.c **** }
 2455              		.loc 2 1242 1
 2456 0014 1846     		mov	r0, r3
 2457 0016 0837     		adds	r7, r7, #8
 2458              	.LCFI194:
 2459              		.cfi_def_cfa_offset 8
 2460 0018 BD46     		mov	sp, r7
 2461              	.LCFI195:
 2462              		.cfi_def_cfa_register 13
 2463              		@ sp needed
 2464 001a 80BD     		pop	{r7, pc}
 2465              		.cfi_endproc
 2466              	.LFE1124:
 2468              		.section	.text.MCI_StopRamp,"ax",%progbits
 2469              		.align	1
 2470              		.weak	MCI_StopRamp
 2471              		.syntax unified
 2472              		.thumb
 2473              		.thumb_func
 2475              	MCI_StopRamp:
 2476              	.LFB1125:
1243:Src/mc_interface.c **** 
1244:Src/mc_interface.c **** /**
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 71


1245:Src/mc_interface.c ****   * @brief  Stop the execution of ongoing ramp.
1246:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
1247:Src/mc_interface.c ****   */
1248:Src/mc_interface.c **** __weak void MCI_StopRamp(MCI_Handle_t *pHandle)
1249:Src/mc_interface.c **** {
 2477              		.loc 2 1249 1
 2478              		.cfi_startproc
 2479              		@ args = 0, pretend = 0, frame = 8
 2480              		@ frame_needed = 1, uses_anonymous_args = 0
 2481 0000 80B5     		push	{r7, lr}
 2482              	.LCFI196:
 2483              		.cfi_def_cfa_offset 8
 2484              		.cfi_offset 7, -8
 2485              		.cfi_offset 14, -4
 2486 0002 82B0     		sub	sp, sp, #8
 2487              	.LCFI197:
 2488              		.cfi_def_cfa_offset 16
 2489 0004 00AF     		add	r7, sp, #0
 2490              	.LCFI198:
 2491              		.cfi_def_cfa_register 7
 2492 0006 7860     		str	r0, [r7, #4]
1250:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
1251:Src/mc_interface.c ****   if (MC_NULL == pHandle)
1252:Src/mc_interface.c ****   {
1253:Src/mc_interface.c ****     /* Nothing to do */
1254:Src/mc_interface.c ****   }
1255:Src/mc_interface.c ****   else
1256:Src/mc_interface.c ****   {
1257:Src/mc_interface.c **** #endif
1258:Src/mc_interface.c ****     STC_StopRamp(pHandle->pSTC);
 2493              		.loc 2 1258 5
 2494 0008 7B68     		ldr	r3, [r7, #4]
 2495 000a 1B68     		ldr	r3, [r3]
 2496 000c 1846     		mov	r0, r3
 2497 000e FFF7FEFF 		bl	STC_StopRamp
1259:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
1260:Src/mc_interface.c ****   }
1261:Src/mc_interface.c **** #endif
1262:Src/mc_interface.c **** }
 2498              		.loc 2 1262 1
 2499 0012 00BF     		nop
 2500 0014 0837     		adds	r7, r7, #8
 2501              	.LCFI199:
 2502              		.cfi_def_cfa_offset 8
 2503 0016 BD46     		mov	sp, r7
 2504              	.LCFI200:
 2505              		.cfi_def_cfa_register 13
 2506              		@ sp needed
 2507 0018 80BD     		pop	{r7, pc}
 2508              		.cfi_endproc
 2509              	.LFE1125:
 2511              		.section	.text.MCI_GetSpdSensorReliability,"ax",%progbits
 2512              		.align	1
 2513              		.weak	MCI_GetSpdSensorReliability
 2514              		.syntax unified
 2515              		.thumb
 2516              		.thumb_func
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 72


 2518              	MCI_GetSpdSensorReliability:
 2519              	.LFB1126:
1263:Src/mc_interface.c **** 
1264:Src/mc_interface.c **** /**
1265:Src/mc_interface.c ****   * @brief  It returns speed sensor reliability with reference to the sensor
1266:Src/mc_interface.c ****   *         actually used for reference frame transformation
1267:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
1268:Src/mc_interface.c ****   * @retval bool It returns true if the speed sensor utilized for reference
1269:Src/mc_interface.c ****   *         frame transformation and (in speed control mode) for speed
1270:Src/mc_interface.c ****   *         regulation is reliable, false otherwise
1271:Src/mc_interface.c ****   */
1272:Src/mc_interface.c **** __weak bool MCI_GetSpdSensorReliability(MCI_Handle_t *pHandle)
1273:Src/mc_interface.c **** {
 2520              		.loc 2 1273 1
 2521              		.cfi_startproc
 2522              		@ args = 0, pretend = 0, frame = 16
 2523              		@ frame_needed = 1, uses_anonymous_args = 0
 2524 0000 80B5     		push	{r7, lr}
 2525              	.LCFI201:
 2526              		.cfi_def_cfa_offset 8
 2527              		.cfi_offset 7, -8
 2528              		.cfi_offset 14, -4
 2529 0002 84B0     		sub	sp, sp, #16
 2530              	.LCFI202:
 2531              		.cfi_def_cfa_offset 24
 2532 0004 00AF     		add	r7, sp, #0
 2533              	.LCFI203:
 2534              		.cfi_def_cfa_register 7
 2535 0006 7860     		str	r0, [r7, #4]
1274:Src/mc_interface.c ****   bool status;
1275:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
1276:Src/mc_interface.c ****   if (MC_NULL == pHandle)
1277:Src/mc_interface.c ****   {
1278:Src/mc_interface.c ****     status = false;
1279:Src/mc_interface.c ****   }
1280:Src/mc_interface.c ****   else
1281:Src/mc_interface.c ****   {
1282:Src/mc_interface.c **** #endif
1283:Src/mc_interface.c ****     SpeednPosFdbk_Handle_t *SpeedSensor = STC_GetSpeedSensor(pHandle->pSTC);
 2536              		.loc 2 1283 43
 2537 0008 7B68     		ldr	r3, [r7, #4]
 2538 000a 1B68     		ldr	r3, [r3]
 2539 000c 1846     		mov	r0, r3
 2540 000e FFF7FEFF 		bl	STC_GetSpeedSensor
 2541 0012 F860     		str	r0, [r7, #12]
1284:Src/mc_interface.c ****     status = SPD_Check(SpeedSensor);
 2542              		.loc 2 1284 14
 2543 0014 F868     		ldr	r0, [r7, #12]
 2544 0016 FFF7FEFF 		bl	SPD_Check
 2545 001a 0346     		mov	r3, r0
 2546 001c FB72     		strb	r3, [r7, #11]
1285:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
1286:Src/mc_interface.c ****   }
1287:Src/mc_interface.c **** #endif
1288:Src/mc_interface.c **** 
1289:Src/mc_interface.c ****   return (status);
 2547              		.loc 2 1289 10
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 73


 2548 001e FB7A     		ldrb	r3, [r7, #11]	@ zero_extendqisi2
1290:Src/mc_interface.c **** }
 2549              		.loc 2 1290 1
 2550 0020 1846     		mov	r0, r3
 2551 0022 1037     		adds	r7, r7, #16
 2552              	.LCFI204:
 2553              		.cfi_def_cfa_offset 8
 2554 0024 BD46     		mov	sp, r7
 2555              	.LCFI205:
 2556              		.cfi_def_cfa_register 13
 2557              		@ sp needed
 2558 0026 80BD     		pop	{r7, pc}
 2559              		.cfi_endproc
 2560              	.LFE1126:
 2562              		.section	.text.MCI_GetAvrgMecSpeedUnit,"ax",%progbits
 2563              		.align	1
 2564              		.weak	MCI_GetAvrgMecSpeedUnit
 2565              		.syntax unified
 2566              		.thumb
 2567              		.thumb_func
 2569              	MCI_GetAvrgMecSpeedUnit:
 2570              	.LFB1127:
1291:Src/mc_interface.c **** 
1292:Src/mc_interface.c **** /**
1293:Src/mc_interface.c ****   * @brief  Returns the last computed average mechanical speed, expressed in
1294:Src/mc_interface.c ****   *         the unit defined by #SPEED_UNIT and related to the sensor actually
1295:Src/mc_interface.c ****   *         used by FOC algorithm
1296:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
1297:Src/mc_interface.c ****   */
1298:Src/mc_interface.c **** __weak int16_t MCI_GetAvrgMecSpeedUnit(MCI_Handle_t *pHandle)
1299:Src/mc_interface.c **** {
 2571              		.loc 2 1299 1
 2572              		.cfi_startproc
 2573              		@ args = 0, pretend = 0, frame = 16
 2574              		@ frame_needed = 1, uses_anonymous_args = 0
 2575 0000 80B5     		push	{r7, lr}
 2576              	.LCFI206:
 2577              		.cfi_def_cfa_offset 8
 2578              		.cfi_offset 7, -8
 2579              		.cfi_offset 14, -4
 2580 0002 84B0     		sub	sp, sp, #16
 2581              	.LCFI207:
 2582              		.cfi_def_cfa_offset 24
 2583 0004 00AF     		add	r7, sp, #0
 2584              	.LCFI208:
 2585              		.cfi_def_cfa_register 7
 2586 0006 7860     		str	r0, [r7, #4]
1300:Src/mc_interface.c ****   int16_t temp_speed;
1301:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
1302:Src/mc_interface.c ****   if (MC_NULL == pHandle)
1303:Src/mc_interface.c ****   {
1304:Src/mc_interface.c ****     temp_speed = 0;
1305:Src/mc_interface.c ****   }
1306:Src/mc_interface.c ****   else
1307:Src/mc_interface.c ****   {
1308:Src/mc_interface.c **** #endif
1309:Src/mc_interface.c ****     SpeednPosFdbk_Handle_t * SpeedSensor = STC_GetSpeedSensor(pHandle->pSTC);
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 74


 2587              		.loc 2 1309 44
 2588 0008 7B68     		ldr	r3, [r7, #4]
 2589 000a 1B68     		ldr	r3, [r3]
 2590 000c 1846     		mov	r0, r3
 2591 000e FFF7FEFF 		bl	STC_GetSpeedSensor
 2592 0012 F860     		str	r0, [r7, #12]
1310:Src/mc_interface.c ****     temp_speed = SPD_GetAvrgMecSpeedUnit(SpeedSensor);
 2593              		.loc 2 1310 18
 2594 0014 F868     		ldr	r0, [r7, #12]
 2595 0016 FFF7FEFF 		bl	SPD_GetAvrgMecSpeedUnit
 2596 001a 0346     		mov	r3, r0
 2597 001c 7B81     		strh	r3, [r7, #10]	@ movhi
1311:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
1312:Src/mc_interface.c ****   }
1313:Src/mc_interface.c **** #endif
1314:Src/mc_interface.c ****   return (temp_speed);
 2598              		.loc 2 1314 10
 2599 001e B7F90A30 		ldrsh	r3, [r7, #10]
1315:Src/mc_interface.c **** }
 2600              		.loc 2 1315 1
 2601 0022 1846     		mov	r0, r3
 2602 0024 1037     		adds	r7, r7, #16
 2603              	.LCFI209:
 2604              		.cfi_def_cfa_offset 8
 2605 0026 BD46     		mov	sp, r7
 2606              	.LCFI210:
 2607              		.cfi_def_cfa_register 13
 2608              		@ sp needed
 2609 0028 80BD     		pop	{r7, pc}
 2610              		.cfi_endproc
 2611              	.LFE1127:
 2613              		.section	.text.MCI_GetAvrgMecSpeed_F,"ax",%progbits
 2614              		.align	1
 2615              		.weak	MCI_GetAvrgMecSpeed_F
 2616              		.syntax unified
 2617              		.thumb
 2618              		.thumb_func
 2620              	MCI_GetAvrgMecSpeed_F:
 2621              	.LFB1128:
1316:Src/mc_interface.c **** 
1317:Src/mc_interface.c **** /**
1318:Src/mc_interface.c ****   * @brief  Returns the last computed average mechanical speed, expressed in rpm
1319:Src/mc_interface.c ****   *         and related to the sensor actually used by FOC algorithm.
1320:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
1321:Src/mc_interface.c ****   */
1322:Src/mc_interface.c **** __weak float_t MCI_GetAvrgMecSpeed_F(MCI_Handle_t *pHandle)
1323:Src/mc_interface.c **** {
 2622              		.loc 2 1323 1
 2623              		.cfi_startproc
 2624              		@ args = 0, pretend = 0, frame = 16
 2625              		@ frame_needed = 1, uses_anonymous_args = 0
 2626 0000 80B5     		push	{r7, lr}
 2627              	.LCFI211:
 2628              		.cfi_def_cfa_offset 8
 2629              		.cfi_offset 7, -8
 2630              		.cfi_offset 14, -4
 2631 0002 84B0     		sub	sp, sp, #16
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 75


 2632              	.LCFI212:
 2633              		.cfi_def_cfa_offset 24
 2634 0004 00AF     		add	r7, sp, #0
 2635              	.LCFI213:
 2636              		.cfi_def_cfa_register 7
 2637 0006 7860     		str	r0, [r7, #4]
1324:Src/mc_interface.c ****   float_t returnAvrgSpeed;
1325:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
1326:Src/mc_interface.c ****   if (MC_NULL == pHandle)
1327:Src/mc_interface.c ****   {
1328:Src/mc_interface.c ****     returnAvrgSpeed = 0.0f;
1329:Src/mc_interface.c ****   }
1330:Src/mc_interface.c ****   else
1331:Src/mc_interface.c ****   {
1332:Src/mc_interface.c **** #endif
1333:Src/mc_interface.c ****     SpeednPosFdbk_Handle_t *SpeedSensor = STC_GetSpeedSensor(pHandle->pSTC);
 2638              		.loc 2 1333 43
 2639 0008 7B68     		ldr	r3, [r7, #4]
 2640 000a 1B68     		ldr	r3, [r3]
 2641 000c 1846     		mov	r0, r3
 2642 000e FFF7FEFF 		bl	STC_GetSpeedSensor
 2643 0012 F860     		str	r0, [r7, #12]
1334:Src/mc_interface.c ****     returnAvrgSpeed = (((float_t)SPD_GetAvrgMecSpeedUnit(SpeedSensor) * (float_t)U_RPM) / (float_t)
 2644              		.loc 2 1334 34
 2645 0014 F868     		ldr	r0, [r7, #12]
 2646 0016 FFF7FEFF 		bl	SPD_GetAvrgMecSpeedUnit
 2647 001a 0346     		mov	r3, r0
 2648 001c 07EE903A 		vmov	s15, r3	@ int
 2649              		.loc 2 1334 25
 2650 0020 F8EEE77A 		vcvt.f32.s32	s15, s15
 2651              		.loc 2 1334 71
 2652 0024 9FED087A 		vldr.32	s14, .L117
 2653 0028 27EE877A 		vmul.f32	s14, s15, s14
 2654              		.loc 2 1334 21
 2655 002c F2EE046A 		vmov.f32	s13, #1.0e+1
 2656 0030 C7EE267A 		vdiv.f32	s15, s14, s13
 2657 0034 C7ED027A 		vstr.32	s15, [r7, #8]
1335:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
1336:Src/mc_interface.c ****   }
1337:Src/mc_interface.c **** #endif
1338:Src/mc_interface.c ****   return (returnAvrgSpeed);
 2658              		.loc 2 1338 10
 2659 0038 BB68     		ldr	r3, [r7, #8]	@ float
 2660 003a 07EE903A 		vmov	s15, r3
1339:Src/mc_interface.c **** }
 2661              		.loc 2 1339 1
 2662 003e B0EE670A 		vmov.f32	s0, s15
 2663 0042 1037     		adds	r7, r7, #16
 2664              	.LCFI214:
 2665              		.cfi_def_cfa_offset 8
 2666 0044 BD46     		mov	sp, r7
 2667              	.LCFI215:
 2668              		.cfi_def_cfa_register 13
 2669              		@ sp needed
 2670 0046 80BD     		pop	{r7, pc}
 2671              	.L118:
 2672              		.align	2
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 76


 2673              	.L117:
 2674 0048 00007042 		.word	1114636288
 2675              		.cfi_endproc
 2676              	.LFE1128:
 2678              		.section	.text.MCI_GetMecSpeedRefUnit,"ax",%progbits
 2679              		.align	1
 2680              		.weak	MCI_GetMecSpeedRefUnit
 2681              		.syntax unified
 2682              		.thumb
 2683              		.thumb_func
 2685              	MCI_GetMecSpeedRefUnit:
 2686              	.LFB1129:
1340:Src/mc_interface.c **** 
1341:Src/mc_interface.c **** /**
1342:Src/mc_interface.c ****   * @brief  Returns the current mechanical rotor speed reference expressed in the unit defined by #
1343:Src/mc_interface.c ****   *
1344:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
1345:Src/mc_interface.c ****   *
1346:Src/mc_interface.c ****   */
1347:Src/mc_interface.c **** __weak int16_t MCI_GetMecSpeedRefUnit(MCI_Handle_t *pHandle)
1348:Src/mc_interface.c **** {
 2687              		.loc 2 1348 1
 2688              		.cfi_startproc
 2689              		@ args = 0, pretend = 0, frame = 8
 2690              		@ frame_needed = 1, uses_anonymous_args = 0
 2691 0000 80B5     		push	{r7, lr}
 2692              	.LCFI216:
 2693              		.cfi_def_cfa_offset 8
 2694              		.cfi_offset 7, -8
 2695              		.cfi_offset 14, -4
 2696 0002 82B0     		sub	sp, sp, #8
 2697              	.LCFI217:
 2698              		.cfi_def_cfa_offset 16
 2699 0004 00AF     		add	r7, sp, #0
 2700              	.LCFI218:
 2701              		.cfi_def_cfa_register 7
 2702 0006 7860     		str	r0, [r7, #4]
1349:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
1350:Src/mc_interface.c ****   return ((MC_NULL == pHandle) ? 0 : STC_GetMecSpeedRefUnit(pHandle->pSTC));
1351:Src/mc_interface.c **** #else
1352:Src/mc_interface.c ****   return (STC_GetMecSpeedRefUnit(pHandle->pSTC));
 2703              		.loc 2 1352 11
 2704 0008 7B68     		ldr	r3, [r7, #4]
 2705 000a 1B68     		ldr	r3, [r3]
 2706 000c 1846     		mov	r0, r3
 2707 000e FFF7FEFF 		bl	STC_GetMecSpeedRefUnit
 2708 0012 0346     		mov	r3, r0
1353:Src/mc_interface.c **** #endif
1354:Src/mc_interface.c **** }
 2709              		.loc 2 1354 1
 2710 0014 1846     		mov	r0, r3
 2711 0016 0837     		adds	r7, r7, #8
 2712              	.LCFI219:
 2713              		.cfi_def_cfa_offset 8
 2714 0018 BD46     		mov	sp, r7
 2715              	.LCFI220:
 2716              		.cfi_def_cfa_register 13
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 77


 2717              		@ sp needed
 2718 001a 80BD     		pop	{r7, pc}
 2719              		.cfi_endproc
 2720              	.LFE1129:
 2722              		.section	.text.MCI_GetMecSpeedRef_F,"ax",%progbits
 2723              		.align	1
 2724              		.weak	MCI_GetMecSpeedRef_F
 2725              		.syntax unified
 2726              		.thumb
 2727              		.thumb_func
 2729              	MCI_GetMecSpeedRef_F:
 2730              	.LFB1130:
1355:Src/mc_interface.c **** 
1356:Src/mc_interface.c **** /**
1357:Src/mc_interface.c ****   * @brief  Returns the current mechanical rotor speed reference expressed in rpm.
1358:Src/mc_interface.c ****   *
1359:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
1360:Src/mc_interface.c ****   *
1361:Src/mc_interface.c ****   */
1362:Src/mc_interface.c **** __weak float_t MCI_GetMecSpeedRef_F(MCI_Handle_t *pHandle)
1363:Src/mc_interface.c **** {
 2731              		.loc 2 1363 1
 2732              		.cfi_startproc
 2733              		@ args = 0, pretend = 0, frame = 8
 2734              		@ frame_needed = 1, uses_anonymous_args = 0
 2735 0000 80B5     		push	{r7, lr}
 2736              	.LCFI221:
 2737              		.cfi_def_cfa_offset 8
 2738              		.cfi_offset 7, -8
 2739              		.cfi_offset 14, -4
 2740 0002 82B0     		sub	sp, sp, #8
 2741              	.LCFI222:
 2742              		.cfi_def_cfa_offset 16
 2743 0004 00AF     		add	r7, sp, #0
 2744              	.LCFI223:
 2745              		.cfi_def_cfa_register 7
 2746 0006 7860     		str	r0, [r7, #4]
1364:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
1365:Src/mc_interface.c ****   return ((MC_NULL == pHandle) ? 0.0f :
1366:Src/mc_interface.c ****           (((float_t)STC_GetMecSpeedRefUnit(pHandle->pSTC) * (float_t)U_RPM) / (float_t)SPEED_UNIT)
1367:Src/mc_interface.c **** #else
1368:Src/mc_interface.c ****   return ((((float_t)STC_GetMecSpeedRefUnit(pHandle->pSTC) * (float_t)U_RPM) / (float_t)SPEED_UNIT)
 2747              		.loc 2 1368 22
 2748 0008 7B68     		ldr	r3, [r7, #4]
 2749 000a 1B68     		ldr	r3, [r3]
 2750 000c 1846     		mov	r0, r3
 2751 000e FFF7FEFF 		bl	STC_GetMecSpeedRefUnit
 2752 0012 0346     		mov	r3, r0
 2753 0014 07EE903A 		vmov	s15, r3	@ int
 2754              		.loc 2 1368 13
 2755 0018 F8EEE77A 		vcvt.f32.s32	s15, s15
 2756              		.loc 2 1368 60
 2757 001c 9FED077A 		vldr.32	s14, .L123
 2758 0020 67EE877A 		vmul.f32	s15, s15, s14
 2759              		.loc 2 1368 78
 2760 0024 B2EE047A 		vmov.f32	s14, #1.0e+1
 2761 0028 C7EE876A 		vdiv.f32	s13, s15, s14
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 78


 2762 002c F0EE667A 		vmov.f32	s15, s13
1369:Src/mc_interface.c **** #endif
1370:Src/mc_interface.c **** }
 2763              		.loc 2 1370 1
 2764 0030 B0EE670A 		vmov.f32	s0, s15
 2765 0034 0837     		adds	r7, r7, #8
 2766              	.LCFI224:
 2767              		.cfi_def_cfa_offset 8
 2768 0036 BD46     		mov	sp, r7
 2769              	.LCFI225:
 2770              		.cfi_def_cfa_register 13
 2771              		@ sp needed
 2772 0038 80BD     		pop	{r7, pc}
 2773              	.L124:
 2774 003a 00BF     		.align	2
 2775              	.L123:
 2776 003c 00007042 		.word	1114636288
 2777              		.cfi_endproc
 2778              	.LFE1130:
 2780              		.section	.text.MCI_GetIab,"ax",%progbits
 2781              		.align	1
 2782              		.weak	MCI_GetIab
 2783              		.syntax unified
 2784              		.thumb
 2785              		.thumb_func
 2787              	MCI_GetIab:
 2788              	.LFB1131:
1371:Src/mc_interface.c **** 
1372:Src/mc_interface.c **** /**
1373:Src/mc_interface.c ****   * @brief  It returns stator current Iab in ab_t format
1374:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
1375:Src/mc_interface.c ****   * @retval ab_t Stator current Iab
1376:Src/mc_interface.c ****   */
1377:Src/mc_interface.c **** __weak ab_t MCI_GetIab(MCI_Handle_t *pHandle) //cstat !MISRAC2012-Rule-8.13
1378:Src/mc_interface.c **** {
 2789              		.loc 2 1378 1
 2790              		.cfi_startproc
 2791              		@ args = 0, pretend = 0, frame = 16
 2792              		@ frame_needed = 1, uses_anonymous_args = 0
 2793              		@ link register save eliminated.
 2794 0000 80B4     		push	{r7}
 2795              	.LCFI226:
 2796              		.cfi_def_cfa_offset 4
 2797              		.cfi_offset 7, -4
 2798 0002 85B0     		sub	sp, sp, #20
 2799              	.LCFI227:
 2800              		.cfi_def_cfa_offset 24
 2801 0004 00AF     		add	r7, sp, #0
 2802              	.LCFI228:
 2803              		.cfi_def_cfa_register 7
 2804 0006 7860     		str	r0, [r7, #4]
1379:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
1380:Src/mc_interface.c ****   ab_t tempVal;
1381:Src/mc_interface.c **** 
1382:Src/mc_interface.c ****   if (MC_NULL == pHandle)
1383:Src/mc_interface.c ****   {
1384:Src/mc_interface.c ****     tempVal.a = 0;
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 79


1385:Src/mc_interface.c ****     tempVal.b = 0;
1386:Src/mc_interface.c ****   }
1387:Src/mc_interface.c ****   else
1388:Src/mc_interface.c ****   {
1389:Src/mc_interface.c ****     tempVal = pHandle->pFOCVars->Iab;
1390:Src/mc_interface.c ****   }
1391:Src/mc_interface.c ****   return (tempVal);
1392:Src/mc_interface.c **** #else
1393:Src/mc_interface.c ****   return (pHandle->pFOCVars->Iab);
 2805              		.loc 2 1393 18
 2806 0008 7B68     		ldr	r3, [r7, #4]
 2807 000a 5A68     		ldr	r2, [r3, #4]
 2808              		.loc 2 1393 28
 2809 000c 07F10C03 		add	r3, r7, #12
 2810 0010 1068     		ldr	r0, [r2]	@ unaligned
 2811 0012 1860     		str	r0, [r3]
 2812 0014 0023     		movs	r3, #0
 2813 0016 BA89     		ldrh	r2, [r7, #12]
 2814 0018 62F30F03 		bfi	r3, r2, #0, #16
 2815 001c FA89     		ldrh	r2, [r7, #14]
 2816 001e 62F31F43 		bfi	r3, r2, #16, #16
1394:Src/mc_interface.c **** #endif
1395:Src/mc_interface.c **** }
 2817              		.loc 2 1395 1
 2818 0022 1846     		mov	r0, r3
 2819 0024 1437     		adds	r7, r7, #20
 2820              	.LCFI229:
 2821              		.cfi_def_cfa_offset 4
 2822 0026 BD46     		mov	sp, r7
 2823              	.LCFI230:
 2824              		.cfi_def_cfa_register 13
 2825              		@ sp needed
 2826 0028 5DF8047B 		ldr	r7, [sp], #4
 2827              	.LCFI231:
 2828              		.cfi_restore 7
 2829              		.cfi_def_cfa_offset 0
 2830 002c 7047     		bx	lr
 2831              		.cfi_endproc
 2832              	.LFE1131:
 2834              		.section	.text.MCI_GetIab_F,"ax",%progbits
 2835              		.align	1
 2836              		.weak	MCI_GetIab_F
 2837              		.syntax unified
 2838              		.thumb
 2839              		.thumb_func
 2841              	MCI_GetIab_F:
 2842              	.LFB1132:
1396:Src/mc_interface.c **** 
1397:Src/mc_interface.c **** __weak ab_f_t MCI_GetIab_F(MCI_Handle_t *pHandle) //cstat !MISRAC2012-Rule-8.13
1398:Src/mc_interface.c **** {
 2843              		.loc 2 1398 1
 2844              		.cfi_startproc
 2845              		@ args = 0, pretend = 0, frame = 32
 2846              		@ frame_needed = 1, uses_anonymous_args = 0
 2847              		@ link register save eliminated.
 2848 0000 80B4     		push	{r7}
 2849              	.LCFI232:
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 80


 2850              		.cfi_def_cfa_offset 4
 2851              		.cfi_offset 7, -4
 2852 0002 89B0     		sub	sp, sp, #36
 2853              	.LCFI233:
 2854              		.cfi_def_cfa_offset 40
 2855 0004 00AF     		add	r7, sp, #0
 2856              	.LCFI234:
 2857              		.cfi_def_cfa_register 7
 2858 0006 F860     		str	r0, [r7, #12]
1399:Src/mc_interface.c **** 
1400:Src/mc_interface.c ****   ab_f_t iab;
1401:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
1402:Src/mc_interface.c ****   if (MC_NULL == pHandle)
1403:Src/mc_interface.c ****   {
1404:Src/mc_interface.c ****     iab.a = 0.0f;
1405:Src/mc_interface.c ****     iab.b = 0.0f;
1406:Src/mc_interface.c ****   }
1407:Src/mc_interface.c ****   else
1408:Src/mc_interface.c ****   {
1409:Src/mc_interface.c **** #endif
1410:Src/mc_interface.c ****     iab.a = (float_t)((float_t)pHandle->pFOCVars->Iab.a * pHandle->pScale->current);
 2859              		.loc 2 1410 39
 2860 0008 FB68     		ldr	r3, [r7, #12]
 2861 000a 5B68     		ldr	r3, [r3, #4]
 2862              		.loc 2 1410 54
 2863 000c B3F90030 		ldrsh	r3, [r3]
 2864              		.loc 2 1410 23
 2865 0010 07EE903A 		vmov	s15, r3	@ int
 2866 0014 F8EEE77A 		vcvt.f32.s32	s15, s15
 2867              		.loc 2 1410 66
 2868 0018 FB68     		ldr	r3, [r7, #12]
 2869 001a 1B6A     		ldr	r3, [r3, #32]
 2870              		.loc 2 1410 74
 2871 001c 5B68     		ldr	r3, [r3, #4]	@ unaligned
 2872              		.loc 2 1410 13
 2873 001e 07EE103A 		vmov	s14, r3
 2874 0022 67EE877A 		vmul.f32	s15, s15, s14
 2875              		.loc 2 1410 11
 2876 0026 C7ED047A 		vstr.32	s15, [r7, #16]
1411:Src/mc_interface.c ****     iab.b = (float_t)((float_t)pHandle->pFOCVars->Iab.b * pHandle->pScale->current);
 2877              		.loc 2 1411 39
 2878 002a FB68     		ldr	r3, [r7, #12]
 2879 002c 5B68     		ldr	r3, [r3, #4]
 2880              		.loc 2 1411 54
 2881 002e B3F90230 		ldrsh	r3, [r3, #2]
 2882              		.loc 2 1411 23
 2883 0032 07EE903A 		vmov	s15, r3	@ int
 2884 0036 F8EEE77A 		vcvt.f32.s32	s15, s15
 2885              		.loc 2 1411 66
 2886 003a FB68     		ldr	r3, [r7, #12]
 2887 003c 1B6A     		ldr	r3, [r3, #32]
 2888              		.loc 2 1411 74
 2889 003e 5B68     		ldr	r3, [r3, #4]	@ unaligned
 2890              		.loc 2 1411 13
 2891 0040 07EE103A 		vmov	s14, r3
 2892 0044 67EE877A 		vmul.f32	s15, s15, s14
 2893              		.loc 2 1411 11
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 81


 2894 0048 C7ED057A 		vstr.32	s15, [r7, #20]
1412:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
1413:Src/mc_interface.c ****   }
1414:Src/mc_interface.c **** #endif
1415:Src/mc_interface.c ****   return (iab);
 2895              		.loc 2 1415 10
 2896 004c 07F11803 		add	r3, r7, #24
 2897 0050 07F11002 		add	r2, r7, #16
 2898 0054 92E80300 		ldm	r2, {r0, r1}
 2899 0058 83E80300 		stm	r3, {r0, r1}
 2900 005c BA69     		ldr	r2, [r7, #24]	@ float
 2901 005e FB69     		ldr	r3, [r7, #28]	@ float
 2902 0060 07EE102A 		vmov	s14, r2
 2903 0064 07EE903A 		vmov	s15, r3
1416:Src/mc_interface.c **** 
1417:Src/mc_interface.c **** }
 2904              		.loc 2 1417 1
 2905 0068 B0EE470A 		vmov.f32	s0, s14
 2906 006c F0EE670A 		vmov.f32	s1, s15
 2907 0070 2437     		adds	r7, r7, #36
 2908              	.LCFI235:
 2909              		.cfi_def_cfa_offset 4
 2910 0072 BD46     		mov	sp, r7
 2911              	.LCFI236:
 2912              		.cfi_def_cfa_register 13
 2913              		@ sp needed
 2914 0074 5DF8047B 		ldr	r7, [sp], #4
 2915              	.LCFI237:
 2916              		.cfi_restore 7
 2917              		.cfi_def_cfa_offset 0
 2918 0078 7047     		bx	lr
 2919              		.cfi_endproc
 2920              	.LFE1132:
 2922              		.section	.text.MCI_GetIalphabeta,"ax",%progbits
 2923              		.align	1
 2924              		.weak	MCI_GetIalphabeta
 2925              		.syntax unified
 2926              		.thumb
 2927              		.thumb_func
 2929              	MCI_GetIalphabeta:
 2930              	.LFB1133:
1418:Src/mc_interface.c **** 
1419:Src/mc_interface.c **** /**
1420:Src/mc_interface.c ****   * @brief  It returns stator current Ialphabeta in alphabeta_t format
1421:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
1422:Src/mc_interface.c ****   * @retval alphabeta_t Stator current Ialphabeta
1423:Src/mc_interface.c ****   */
1424:Src/mc_interface.c **** __weak alphabeta_t MCI_GetIalphabeta(MCI_Handle_t *pHandle) //cstat !MISRAC2012-Rule-8.13
1425:Src/mc_interface.c **** {
 2931              		.loc 2 1425 1
 2932              		.cfi_startproc
 2933              		@ args = 0, pretend = 0, frame = 16
 2934              		@ frame_needed = 1, uses_anonymous_args = 0
 2935              		@ link register save eliminated.
 2936 0000 80B4     		push	{r7}
 2937              	.LCFI238:
 2938              		.cfi_def_cfa_offset 4
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 82


 2939              		.cfi_offset 7, -4
 2940 0002 85B0     		sub	sp, sp, #20
 2941              	.LCFI239:
 2942              		.cfi_def_cfa_offset 24
 2943 0004 00AF     		add	r7, sp, #0
 2944              	.LCFI240:
 2945              		.cfi_def_cfa_register 7
 2946 0006 7860     		str	r0, [r7, #4]
1426:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
1427:Src/mc_interface.c ****   alphabeta_t tempVal;
1428:Src/mc_interface.c **** 
1429:Src/mc_interface.c ****   if (MC_NULL == pHandle)
1430:Src/mc_interface.c ****   {
1431:Src/mc_interface.c ****     tempVal.alpha = 0;
1432:Src/mc_interface.c ****     tempVal.beta = 0;
1433:Src/mc_interface.c ****   }
1434:Src/mc_interface.c ****   else
1435:Src/mc_interface.c ****   {
1436:Src/mc_interface.c ****     tempVal = pHandle->pFOCVars->Ialphabeta;
1437:Src/mc_interface.c ****   }
1438:Src/mc_interface.c ****   return (tempVal);
1439:Src/mc_interface.c **** #else
1440:Src/mc_interface.c ****   return (pHandle->pFOCVars->Ialphabeta);
 2947              		.loc 2 1440 18
 2948 0008 7B68     		ldr	r3, [r7, #4]
 2949 000a 5A68     		ldr	r2, [r3, #4]
 2950              		.loc 2 1440 28
 2951 000c 07F10C03 		add	r3, r7, #12
 2952 0010 0432     		adds	r2, r2, #4
 2953 0012 1068     		ldr	r0, [r2]	@ unaligned
 2954 0014 1860     		str	r0, [r3]
 2955 0016 0023     		movs	r3, #0
 2956 0018 BA89     		ldrh	r2, [r7, #12]
 2957 001a 62F30F03 		bfi	r3, r2, #0, #16
 2958 001e FA89     		ldrh	r2, [r7, #14]
 2959 0020 62F31F43 		bfi	r3, r2, #16, #16
1441:Src/mc_interface.c **** #endif
1442:Src/mc_interface.c **** }
 2960              		.loc 2 1442 1
 2961 0024 1846     		mov	r0, r3
 2962 0026 1437     		adds	r7, r7, #20
 2963              	.LCFI241:
 2964              		.cfi_def_cfa_offset 4
 2965 0028 BD46     		mov	sp, r7
 2966              	.LCFI242:
 2967              		.cfi_def_cfa_register 13
 2968              		@ sp needed
 2969 002a 5DF8047B 		ldr	r7, [sp], #4
 2970              	.LCFI243:
 2971              		.cfi_restore 7
 2972              		.cfi_def_cfa_offset 0
 2973 002e 7047     		bx	lr
 2974              		.cfi_endproc
 2975              	.LFE1133:
 2977              		.section	.text.MCI_GetIqd,"ax",%progbits
 2978              		.align	1
 2979              		.weak	MCI_GetIqd
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 83


 2980              		.syntax unified
 2981              		.thumb
 2982              		.thumb_func
 2984              	MCI_GetIqd:
 2985              	.LFB1134:
1443:Src/mc_interface.c **** 
1444:Src/mc_interface.c **** /**
1445:Src/mc_interface.c ****   * @brief  It returns stator current Iqd in qd_t format
1446:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
1447:Src/mc_interface.c ****   * @retval qd_t Stator current Iqd
1448:Src/mc_interface.c ****   */
1449:Src/mc_interface.c **** __weak qd_t MCI_GetIqd(MCI_Handle_t *pHandle) //cstat !MISRAC2012-Rule-8.13
1450:Src/mc_interface.c **** {
 2986              		.loc 2 1450 1
 2987              		.cfi_startproc
 2988              		@ args = 0, pretend = 0, frame = 16
 2989              		@ frame_needed = 1, uses_anonymous_args = 0
 2990              		@ link register save eliminated.
 2991 0000 80B4     		push	{r7}
 2992              	.LCFI244:
 2993              		.cfi_def_cfa_offset 4
 2994              		.cfi_offset 7, -4
 2995 0002 85B0     		sub	sp, sp, #20
 2996              	.LCFI245:
 2997              		.cfi_def_cfa_offset 24
 2998 0004 00AF     		add	r7, sp, #0
 2999              	.LCFI246:
 3000              		.cfi_def_cfa_register 7
 3001 0006 7860     		str	r0, [r7, #4]
1451:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
1452:Src/mc_interface.c ****   qd_t tempVal;
1453:Src/mc_interface.c **** 
1454:Src/mc_interface.c ****   if (MC_NULL == pHandle)
1455:Src/mc_interface.c ****   {
1456:Src/mc_interface.c ****     tempVal.q = 0;
1457:Src/mc_interface.c ****     tempVal.d = 0;
1458:Src/mc_interface.c ****   }
1459:Src/mc_interface.c ****   else
1460:Src/mc_interface.c ****   {
1461:Src/mc_interface.c ****     tempVal = pHandle->pFOCVars->Iqd;
1462:Src/mc_interface.c ****   }
1463:Src/mc_interface.c ****   return (tempVal);
1464:Src/mc_interface.c **** #else
1465:Src/mc_interface.c ****   return (pHandle->pFOCVars->Iqd);
 3002              		.loc 2 1465 18
 3003 0008 7B68     		ldr	r3, [r7, #4]
 3004 000a 5A68     		ldr	r2, [r3, #4]
 3005              		.loc 2 1465 28
 3006 000c 07F10C03 		add	r3, r7, #12
 3007 0010 0C32     		adds	r2, r2, #12
 3008 0012 1068     		ldr	r0, [r2]	@ unaligned
 3009 0014 1860     		str	r0, [r3]
 3010 0016 0023     		movs	r3, #0
 3011 0018 BA89     		ldrh	r2, [r7, #12]
 3012 001a 62F30F03 		bfi	r3, r2, #0, #16
 3013 001e FA89     		ldrh	r2, [r7, #14]
 3014 0020 62F31F43 		bfi	r3, r2, #16, #16
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 84


1466:Src/mc_interface.c **** #endif
1467:Src/mc_interface.c **** }
 3015              		.loc 2 1467 1
 3016 0024 1846     		mov	r0, r3
 3017 0026 1437     		adds	r7, r7, #20
 3018              	.LCFI247:
 3019              		.cfi_def_cfa_offset 4
 3020 0028 BD46     		mov	sp, r7
 3021              	.LCFI248:
 3022              		.cfi_def_cfa_register 13
 3023              		@ sp needed
 3024 002a 5DF8047B 		ldr	r7, [sp], #4
 3025              	.LCFI249:
 3026              		.cfi_restore 7
 3027              		.cfi_def_cfa_offset 0
 3028 002e 7047     		bx	lr
 3029              		.cfi_endproc
 3030              	.LFE1134:
 3032              		.section	.text.MCI_GetIqd_F,"ax",%progbits
 3033              		.align	1
 3034              		.weak	MCI_GetIqd_F
 3035              		.syntax unified
 3036              		.thumb
 3037              		.thumb_func
 3039              	MCI_GetIqd_F:
 3040              	.LFB1135:
1468:Src/mc_interface.c **** 
1469:Src/mc_interface.c **** /**
1470:Src/mc_interface.c ****   * @brief  It returns stator current Iqd in float_t format
1471:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
1472:Src/mc_interface.c ****   * @retval qd_f_t Stator current Iqd (in Ampere)
1473:Src/mc_interface.c ****   */
1474:Src/mc_interface.c **** __weak qd_f_t MCI_GetIqd_F(MCI_Handle_t *pHandle) //cstat !MISRAC2012-Rule-8.13
1475:Src/mc_interface.c **** {
 3041              		.loc 2 1475 1
 3042              		.cfi_startproc
 3043              		@ args = 0, pretend = 0, frame = 32
 3044              		@ frame_needed = 1, uses_anonymous_args = 0
 3045              		@ link register save eliminated.
 3046 0000 80B4     		push	{r7}
 3047              	.LCFI250:
 3048              		.cfi_def_cfa_offset 4
 3049              		.cfi_offset 7, -4
 3050 0002 89B0     		sub	sp, sp, #36
 3051              	.LCFI251:
 3052              		.cfi_def_cfa_offset 40
 3053 0004 00AF     		add	r7, sp, #0
 3054              	.LCFI252:
 3055              		.cfi_def_cfa_register 7
 3056 0006 F860     		str	r0, [r7, #12]
1476:Src/mc_interface.c ****   qd_f_t iqd;
1477:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
1478:Src/mc_interface.c ****   if (MC_NULL == pHandle)
1479:Src/mc_interface.c ****   {
1480:Src/mc_interface.c ****     iqd.d = 0.0f;
1481:Src/mc_interface.c ****     iqd.q = 0.0f;
1482:Src/mc_interface.c ****   }
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 85


1483:Src/mc_interface.c ****   else
1484:Src/mc_interface.c ****   {
1485:Src/mc_interface.c **** #endif
1486:Src/mc_interface.c ****   iqd.d = (float_t)((float_t)pHandle->pFOCVars->Iqd.d * pHandle->pScale->current);
 3057              		.loc 2 1486 37
 3058 0008 FB68     		ldr	r3, [r7, #12]
 3059 000a 5B68     		ldr	r3, [r3, #4]
 3060              		.loc 2 1486 52
 3061 000c B3F90E30 		ldrsh	r3, [r3, #14]
 3062              		.loc 2 1486 21
 3063 0010 07EE903A 		vmov	s15, r3	@ int
 3064 0014 F8EEE77A 		vcvt.f32.s32	s15, s15
 3065              		.loc 2 1486 64
 3066 0018 FB68     		ldr	r3, [r7, #12]
 3067 001a 1B6A     		ldr	r3, [r3, #32]
 3068              		.loc 2 1486 72
 3069 001c 5B68     		ldr	r3, [r3, #4]	@ unaligned
 3070              		.loc 2 1486 11
 3071 001e 07EE103A 		vmov	s14, r3
 3072 0022 67EE877A 		vmul.f32	s15, s15, s14
 3073              		.loc 2 1486 9
 3074 0026 C7ED057A 		vstr.32	s15, [r7, #20]
1487:Src/mc_interface.c ****   iqd.q = (float_t)((float_t)pHandle->pFOCVars->Iqd.q * pHandle->pScale->current);
 3075              		.loc 2 1487 37
 3076 002a FB68     		ldr	r3, [r7, #12]
 3077 002c 5B68     		ldr	r3, [r3, #4]
 3078              		.loc 2 1487 52
 3079 002e B3F90C30 		ldrsh	r3, [r3, #12]
 3080              		.loc 2 1487 21
 3081 0032 07EE903A 		vmov	s15, r3	@ int
 3082 0036 F8EEE77A 		vcvt.f32.s32	s15, s15
 3083              		.loc 2 1487 64
 3084 003a FB68     		ldr	r3, [r7, #12]
 3085 003c 1B6A     		ldr	r3, [r3, #32]
 3086              		.loc 2 1487 72
 3087 003e 5B68     		ldr	r3, [r3, #4]	@ unaligned
 3088              		.loc 2 1487 11
 3089 0040 07EE103A 		vmov	s14, r3
 3090 0044 67EE877A 		vmul.f32	s15, s15, s14
 3091              		.loc 2 1487 9
 3092 0048 C7ED047A 		vstr.32	s15, [r7, #16]
1488:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
1489:Src/mc_interface.c ****   }
1490:Src/mc_interface.c **** #endif
1491:Src/mc_interface.c ****   return (iqd);
 3093              		.loc 2 1491 10
 3094 004c 07F11803 		add	r3, r7, #24
 3095 0050 07F11002 		add	r2, r7, #16
 3096 0054 92E80300 		ldm	r2, {r0, r1}
 3097 0058 83E80300 		stm	r3, {r0, r1}
 3098 005c BA69     		ldr	r2, [r7, #24]	@ float
 3099 005e FB69     		ldr	r3, [r7, #28]	@ float
 3100 0060 07EE102A 		vmov	s14, r2
 3101 0064 07EE903A 		vmov	s15, r3
1492:Src/mc_interface.c **** }
 3102              		.loc 2 1492 1
 3103 0068 B0EE470A 		vmov.f32	s0, s14
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 86


 3104 006c F0EE670A 		vmov.f32	s1, s15
 3105 0070 2437     		adds	r7, r7, #36
 3106              	.LCFI253:
 3107              		.cfi_def_cfa_offset 4
 3108 0072 BD46     		mov	sp, r7
 3109              	.LCFI254:
 3110              		.cfi_def_cfa_register 13
 3111              		@ sp needed
 3112 0074 5DF8047B 		ldr	r7, [sp], #4
 3113              	.LCFI255:
 3114              		.cfi_restore 7
 3115              		.cfi_def_cfa_offset 0
 3116 0078 7047     		bx	lr
 3117              		.cfi_endproc
 3118              	.LFE1135:
 3120              		.section	.text.MCI_GetIqdHF,"ax",%progbits
 3121              		.align	1
 3122              		.weak	MCI_GetIqdHF
 3123              		.syntax unified
 3124              		.thumb
 3125              		.thumb_func
 3127              	MCI_GetIqdHF:
 3128              	.LFB1136:
1493:Src/mc_interface.c **** 
1494:Src/mc_interface.c **** /**
1495:Src/mc_interface.c ****   * @brief  It returns stator current IqdHF in qd_t format
1496:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
1497:Src/mc_interface.c ****   * @retval qd_t Stator current IqdHF if HFI is selected as main
1498:Src/mc_interface.c ****   *         sensor. Otherwise it returns { 0, 0}.
1499:Src/mc_interface.c ****   */
1500:Src/mc_interface.c **** __weak qd_t MCI_GetIqdHF(MCI_Handle_t *pHandle) //cstat !MISRAC2012-Rule-8.13
1501:Src/mc_interface.c **** {
 3129              		.loc 2 1501 1
 3130              		.cfi_startproc
 3131              		@ args = 0, pretend = 0, frame = 16
 3132              		@ frame_needed = 1, uses_anonymous_args = 0
 3133              		@ link register save eliminated.
 3134 0000 80B4     		push	{r7}
 3135              	.LCFI256:
 3136              		.cfi_def_cfa_offset 4
 3137              		.cfi_offset 7, -4
 3138 0002 85B0     		sub	sp, sp, #20
 3139              	.LCFI257:
 3140              		.cfi_def_cfa_offset 24
 3141 0004 00AF     		add	r7, sp, #0
 3142              	.LCFI258:
 3143              		.cfi_def_cfa_register 7
 3144 0006 7860     		str	r0, [r7, #4]
1502:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
1503:Src/mc_interface.c ****   qd_t tempVal;
1504:Src/mc_interface.c **** 
1505:Src/mc_interface.c ****   if (MC_NULL == pHandle)
1506:Src/mc_interface.c ****   {
1507:Src/mc_interface.c ****     tempVal.q = 0;
1508:Src/mc_interface.c ****     tempVal.d = 0;
1509:Src/mc_interface.c ****   }
1510:Src/mc_interface.c ****   else
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 87


1511:Src/mc_interface.c ****   {
1512:Src/mc_interface.c ****     tempVal = pHandle->pFOCVars->IqdHF;
1513:Src/mc_interface.c ****   }
1514:Src/mc_interface.c ****   return (tempVal);
1515:Src/mc_interface.c **** #else
1516:Src/mc_interface.c ****   return (pHandle->pFOCVars->IqdHF);
 3145              		.loc 2 1516 18
 3146 0008 7B68     		ldr	r3, [r7, #4]
 3147 000a 5A68     		ldr	r2, [r3, #4]
 3148              		.loc 2 1516 28
 3149 000c 07F10C03 		add	r3, r7, #12
 3150 0010 0832     		adds	r2, r2, #8
 3151 0012 1068     		ldr	r0, [r2]	@ unaligned
 3152 0014 1860     		str	r0, [r3]
 3153 0016 0023     		movs	r3, #0
 3154 0018 BA89     		ldrh	r2, [r7, #12]
 3155 001a 62F30F03 		bfi	r3, r2, #0, #16
 3156 001e FA89     		ldrh	r2, [r7, #14]
 3157 0020 62F31F43 		bfi	r3, r2, #16, #16
1517:Src/mc_interface.c **** #endif
1518:Src/mc_interface.c **** }
 3158              		.loc 2 1518 1
 3159 0024 1846     		mov	r0, r3
 3160 0026 1437     		adds	r7, r7, #20
 3161              	.LCFI259:
 3162              		.cfi_def_cfa_offset 4
 3163 0028 BD46     		mov	sp, r7
 3164              	.LCFI260:
 3165              		.cfi_def_cfa_register 13
 3166              		@ sp needed
 3167 002a 5DF8047B 		ldr	r7, [sp], #4
 3168              	.LCFI261:
 3169              		.cfi_restore 7
 3170              		.cfi_def_cfa_offset 0
 3171 002e 7047     		bx	lr
 3172              		.cfi_endproc
 3173              	.LFE1136:
 3175              		.section	.text.MCI_GetIqdref,"ax",%progbits
 3176              		.align	1
 3177              		.weak	MCI_GetIqdref
 3178              		.syntax unified
 3179              		.thumb
 3180              		.thumb_func
 3182              	MCI_GetIqdref:
 3183              	.LFB1137:
1519:Src/mc_interface.c **** 
1520:Src/mc_interface.c **** /**
1521:Src/mc_interface.c ****   * @brief  It returns stator current Iqdref in qd_t format
1522:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
1523:Src/mc_interface.c ****   * @retval qd_t Stator current Iqdref
1524:Src/mc_interface.c ****   */
1525:Src/mc_interface.c **** __weak qd_t MCI_GetIqdref(MCI_Handle_t *pHandle) //cstat !MISRAC2012-Rule-8.13
1526:Src/mc_interface.c **** {
 3184              		.loc 2 1526 1
 3185              		.cfi_startproc
 3186              		@ args = 0, pretend = 0, frame = 16
 3187              		@ frame_needed = 1, uses_anonymous_args = 0
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 88


 3188              		@ link register save eliminated.
 3189 0000 80B4     		push	{r7}
 3190              	.LCFI262:
 3191              		.cfi_def_cfa_offset 4
 3192              		.cfi_offset 7, -4
 3193 0002 85B0     		sub	sp, sp, #20
 3194              	.LCFI263:
 3195              		.cfi_def_cfa_offset 24
 3196 0004 00AF     		add	r7, sp, #0
 3197              	.LCFI264:
 3198              		.cfi_def_cfa_register 7
 3199 0006 7860     		str	r0, [r7, #4]
1527:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
1528:Src/mc_interface.c ****   qd_t tempVal;
1529:Src/mc_interface.c **** 
1530:Src/mc_interface.c ****   if (MC_NULL == pHandle)
1531:Src/mc_interface.c ****   {
1532:Src/mc_interface.c ****     tempVal.q = 0;
1533:Src/mc_interface.c ****     tempVal.d = 0;
1534:Src/mc_interface.c ****   }
1535:Src/mc_interface.c ****   else
1536:Src/mc_interface.c ****   {
1537:Src/mc_interface.c ****     tempVal = pHandle->pFOCVars->Iqdref;
1538:Src/mc_interface.c ****   }
1539:Src/mc_interface.c ****   return (tempVal);
1540:Src/mc_interface.c **** #else
1541:Src/mc_interface.c ****   return (pHandle->pFOCVars->Iqdref);
 3200              		.loc 2 1541 18
 3201 0008 7B68     		ldr	r3, [r7, #4]
 3202 000a 5A68     		ldr	r2, [r3, #4]
 3203              		.loc 2 1541 28
 3204 000c 07F10C03 		add	r3, r7, #12
 3205 0010 1032     		adds	r2, r2, #16
 3206 0012 1068     		ldr	r0, [r2]	@ unaligned
 3207 0014 1860     		str	r0, [r3]
 3208 0016 0023     		movs	r3, #0
 3209 0018 BA89     		ldrh	r2, [r7, #12]
 3210 001a 62F30F03 		bfi	r3, r2, #0, #16
 3211 001e FA89     		ldrh	r2, [r7, #14]
 3212 0020 62F31F43 		bfi	r3, r2, #16, #16
1542:Src/mc_interface.c **** #endif
1543:Src/mc_interface.c **** }
 3213              		.loc 2 1543 1
 3214 0024 1846     		mov	r0, r3
 3215 0026 1437     		adds	r7, r7, #20
 3216              	.LCFI265:
 3217              		.cfi_def_cfa_offset 4
 3218 0028 BD46     		mov	sp, r7
 3219              	.LCFI266:
 3220              		.cfi_def_cfa_register 13
 3221              		@ sp needed
 3222 002a 5DF8047B 		ldr	r7, [sp], #4
 3223              	.LCFI267:
 3224              		.cfi_restore 7
 3225              		.cfi_def_cfa_offset 0
 3226 002e 7047     		bx	lr
 3227              		.cfi_endproc
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 89


 3228              	.LFE1137:
 3230              		.section	.text.MCI_GetIqdref_F,"ax",%progbits
 3231              		.align	1
 3232              		.weak	MCI_GetIqdref_F
 3233              		.syntax unified
 3234              		.thumb
 3235              		.thumb_func
 3237              	MCI_GetIqdref_F:
 3238              	.LFB1138:
1544:Src/mc_interface.c **** 
1545:Src/mc_interface.c **** /**
1546:Src/mc_interface.c ****   * @brief  It returns stator current Iqdref in float_t format
1547:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
1548:Src/mc_interface.c ****   * @retval qd_f_t Stator current Iqdref (in Ampere)
1549:Src/mc_interface.c ****   */
1550:Src/mc_interface.c **** __weak qd_f_t MCI_GetIqdref_F(MCI_Handle_t *pHandle) //cstat !MISRAC2012-Rule-8.13
1551:Src/mc_interface.c **** {
 3239              		.loc 2 1551 1
 3240              		.cfi_startproc
 3241              		@ args = 0, pretend = 0, frame = 32
 3242              		@ frame_needed = 1, uses_anonymous_args = 0
 3243              		@ link register save eliminated.
 3244 0000 80B4     		push	{r7}
 3245              	.LCFI268:
 3246              		.cfi_def_cfa_offset 4
 3247              		.cfi_offset 7, -4
 3248 0002 89B0     		sub	sp, sp, #36
 3249              	.LCFI269:
 3250              		.cfi_def_cfa_offset 40
 3251 0004 00AF     		add	r7, sp, #0
 3252              	.LCFI270:
 3253              		.cfi_def_cfa_register 7
 3254 0006 F860     		str	r0, [r7, #12]
1552:Src/mc_interface.c ****   qd_f_t iqdref;
1553:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
1554:Src/mc_interface.c ****   if (MC_NULL == pHandle)
1555:Src/mc_interface.c ****   {
1556:Src/mc_interface.c ****     iqdref.d = 0.0f;
1557:Src/mc_interface.c ****     iqdref.q = 0.0f;
1558:Src/mc_interface.c ****   }
1559:Src/mc_interface.c ****   else
1560:Src/mc_interface.c ****   {
1561:Src/mc_interface.c **** #endif
1562:Src/mc_interface.c ****     iqdref.d = (float_t)((float_t)pHandle->pFOCVars->Iqdref.d * pHandle->pScale->current);
 3255              		.loc 2 1562 42
 3256 0008 FB68     		ldr	r3, [r7, #12]
 3257 000a 5B68     		ldr	r3, [r3, #4]
 3258              		.loc 2 1562 60
 3259 000c B3F91230 		ldrsh	r3, [r3, #18]
 3260              		.loc 2 1562 26
 3261 0010 07EE903A 		vmov	s15, r3	@ int
 3262 0014 F8EEE77A 		vcvt.f32.s32	s15, s15
 3263              		.loc 2 1562 72
 3264 0018 FB68     		ldr	r3, [r7, #12]
 3265 001a 1B6A     		ldr	r3, [r3, #32]
 3266              		.loc 2 1562 80
 3267 001c 5B68     		ldr	r3, [r3, #4]	@ unaligned
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 90


 3268              		.loc 2 1562 16
 3269 001e 07EE103A 		vmov	s14, r3
 3270 0022 67EE877A 		vmul.f32	s15, s15, s14
 3271              		.loc 2 1562 14
 3272 0026 C7ED057A 		vstr.32	s15, [r7, #20]
1563:Src/mc_interface.c ****     iqdref.q = (float_t)((float_t)pHandle->pFOCVars->Iqdref.q * pHandle->pScale->current);
 3273              		.loc 2 1563 42
 3274 002a FB68     		ldr	r3, [r7, #12]
 3275 002c 5B68     		ldr	r3, [r3, #4]
 3276              		.loc 2 1563 60
 3277 002e B3F91030 		ldrsh	r3, [r3, #16]
 3278              		.loc 2 1563 26
 3279 0032 07EE903A 		vmov	s15, r3	@ int
 3280 0036 F8EEE77A 		vcvt.f32.s32	s15, s15
 3281              		.loc 2 1563 72
 3282 003a FB68     		ldr	r3, [r7, #12]
 3283 003c 1B6A     		ldr	r3, [r3, #32]
 3284              		.loc 2 1563 80
 3285 003e 5B68     		ldr	r3, [r3, #4]	@ unaligned
 3286              		.loc 2 1563 16
 3287 0040 07EE103A 		vmov	s14, r3
 3288 0044 67EE877A 		vmul.f32	s15, s15, s14
 3289              		.loc 2 1563 14
 3290 0048 C7ED047A 		vstr.32	s15, [r7, #16]
1564:Src/mc_interface.c ****  #ifdef NULL_PTR_CHECK_MC_INT
1565:Src/mc_interface.c ****   }
1566:Src/mc_interface.c **** #endif
1567:Src/mc_interface.c ****   return (iqdref);
 3291              		.loc 2 1567 10
 3292 004c 07F11803 		add	r3, r7, #24
 3293 0050 07F11002 		add	r2, r7, #16
 3294 0054 92E80300 		ldm	r2, {r0, r1}
 3295 0058 83E80300 		stm	r3, {r0, r1}
 3296 005c BA69     		ldr	r2, [r7, #24]	@ float
 3297 005e FB69     		ldr	r3, [r7, #28]	@ float
 3298 0060 07EE102A 		vmov	s14, r2
 3299 0064 07EE903A 		vmov	s15, r3
1568:Src/mc_interface.c **** }
 3300              		.loc 2 1568 1
 3301 0068 B0EE470A 		vmov.f32	s0, s14
 3302 006c F0EE670A 		vmov.f32	s1, s15
 3303 0070 2437     		adds	r7, r7, #36
 3304              	.LCFI271:
 3305              		.cfi_def_cfa_offset 4
 3306 0072 BD46     		mov	sp, r7
 3307              	.LCFI272:
 3308              		.cfi_def_cfa_register 13
 3309              		@ sp needed
 3310 0074 5DF8047B 		ldr	r7, [sp], #4
 3311              	.LCFI273:
 3312              		.cfi_restore 7
 3313              		.cfi_def_cfa_offset 0
 3314 0078 7047     		bx	lr
 3315              		.cfi_endproc
 3316              	.LFE1138:
 3318              		.section	.text.MCI_GetVqd,"ax",%progbits
 3319              		.align	1
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 91


 3320              		.weak	MCI_GetVqd
 3321              		.syntax unified
 3322              		.thumb
 3323              		.thumb_func
 3325              	MCI_GetVqd:
 3326              	.LFB1139:
1569:Src/mc_interface.c **** 
1570:Src/mc_interface.c **** /**
1571:Src/mc_interface.c ****   * @brief  It returns stator current Vqd in qd_t format
1572:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
1573:Src/mc_interface.c ****   * @retval qd_t Stator current Vqd
1574:Src/mc_interface.c ****   */
1575:Src/mc_interface.c **** __weak qd_t MCI_GetVqd(MCI_Handle_t *pHandle) //cstat !MISRAC2012-Rule-8.13
1576:Src/mc_interface.c **** {
 3327              		.loc 2 1576 1
 3328              		.cfi_startproc
 3329              		@ args = 0, pretend = 0, frame = 16
 3330              		@ frame_needed = 1, uses_anonymous_args = 0
 3331              		@ link register save eliminated.
 3332 0000 80B4     		push	{r7}
 3333              	.LCFI274:
 3334              		.cfi_def_cfa_offset 4
 3335              		.cfi_offset 7, -4
 3336 0002 85B0     		sub	sp, sp, #20
 3337              	.LCFI275:
 3338              		.cfi_def_cfa_offset 24
 3339 0004 00AF     		add	r7, sp, #0
 3340              	.LCFI276:
 3341              		.cfi_def_cfa_register 7
 3342 0006 7860     		str	r0, [r7, #4]
1577:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
1578:Src/mc_interface.c ****   qd_t tempVal;
1579:Src/mc_interface.c **** 
1580:Src/mc_interface.c ****   if (MC_NULL == pHandle)
1581:Src/mc_interface.c ****   {
1582:Src/mc_interface.c ****     tempVal.q = 0;
1583:Src/mc_interface.c ****     tempVal.d = 0;
1584:Src/mc_interface.c ****   }
1585:Src/mc_interface.c ****   else
1586:Src/mc_interface.c ****   {
1587:Src/mc_interface.c ****     tempVal = pHandle->pFOCVars->Vqd;
1588:Src/mc_interface.c ****   }
1589:Src/mc_interface.c ****   return (tempVal);
1590:Src/mc_interface.c **** #else
1591:Src/mc_interface.c ****   return (pHandle->pFOCVars->Vqd);
 3343              		.loc 2 1591 18
 3344 0008 7B68     		ldr	r3, [r7, #4]
 3345 000a 5A68     		ldr	r2, [r3, #4]
 3346              		.loc 2 1591 28
 3347 000c 07F10C03 		add	r3, r7, #12
 3348 0010 1632     		adds	r2, r2, #22
 3349 0012 1068     		ldr	r0, [r2]	@ unaligned
 3350 0014 1860     		str	r0, [r3]
 3351 0016 0023     		movs	r3, #0
 3352 0018 BA89     		ldrh	r2, [r7, #12]
 3353 001a 62F30F03 		bfi	r3, r2, #0, #16
 3354 001e FA89     		ldrh	r2, [r7, #14]
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 92


 3355 0020 62F31F43 		bfi	r3, r2, #16, #16
1592:Src/mc_interface.c **** #endif
1593:Src/mc_interface.c **** }
 3356              		.loc 2 1593 1
 3357 0024 1846     		mov	r0, r3
 3358 0026 1437     		adds	r7, r7, #20
 3359              	.LCFI277:
 3360              		.cfi_def_cfa_offset 4
 3361 0028 BD46     		mov	sp, r7
 3362              	.LCFI278:
 3363              		.cfi_def_cfa_register 13
 3364              		@ sp needed
 3365 002a 5DF8047B 		ldr	r7, [sp], #4
 3366              	.LCFI279:
 3367              		.cfi_restore 7
 3368              		.cfi_def_cfa_offset 0
 3369 002e 7047     		bx	lr
 3370              		.cfi_endproc
 3371              	.LFE1139:
 3373              		.section	.text.MCI_GetValphabeta,"ax",%progbits
 3374              		.align	1
 3375              		.weak	MCI_GetValphabeta
 3376              		.syntax unified
 3377              		.thumb
 3378              		.thumb_func
 3380              	MCI_GetValphabeta:
 3381              	.LFB1140:
1594:Src/mc_interface.c **** 
1595:Src/mc_interface.c **** /**
1596:Src/mc_interface.c ****   * @brief  It returns stator current Valphabeta in alphabeta_t format
1597:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
1598:Src/mc_interface.c ****   * @retval alphabeta_t Stator current Valphabeta
1599:Src/mc_interface.c ****   */
1600:Src/mc_interface.c **** __weak alphabeta_t MCI_GetValphabeta(MCI_Handle_t *pHandle) //cstat !MISRAC2012-Rule-8.13
1601:Src/mc_interface.c **** {
 3382              		.loc 2 1601 1
 3383              		.cfi_startproc
 3384              		@ args = 0, pretend = 0, frame = 16
 3385              		@ frame_needed = 1, uses_anonymous_args = 0
 3386              		@ link register save eliminated.
 3387 0000 80B4     		push	{r7}
 3388              	.LCFI280:
 3389              		.cfi_def_cfa_offset 4
 3390              		.cfi_offset 7, -4
 3391 0002 85B0     		sub	sp, sp, #20
 3392              	.LCFI281:
 3393              		.cfi_def_cfa_offset 24
 3394 0004 00AF     		add	r7, sp, #0
 3395              	.LCFI282:
 3396              		.cfi_def_cfa_register 7
 3397 0006 7860     		str	r0, [r7, #4]
1602:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
1603:Src/mc_interface.c ****   alphabeta_t tempVal;
1604:Src/mc_interface.c **** 
1605:Src/mc_interface.c ****   if (MC_NULL == pHandle)
1606:Src/mc_interface.c ****   {
1607:Src/mc_interface.c ****     tempVal.alpha = 0;
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 93


1608:Src/mc_interface.c ****     tempVal.beta = 0;
1609:Src/mc_interface.c ****   }
1610:Src/mc_interface.c ****   else
1611:Src/mc_interface.c ****   {
1612:Src/mc_interface.c ****     tempVal = pHandle->pFOCVars->Valphabeta;
1613:Src/mc_interface.c ****   }
1614:Src/mc_interface.c ****   return (tempVal);
1615:Src/mc_interface.c **** #else
1616:Src/mc_interface.c ****   return (pHandle->pFOCVars->Valphabeta);
 3398              		.loc 2 1616 18
 3399 0008 7B68     		ldr	r3, [r7, #4]
 3400 000a 5A68     		ldr	r2, [r3, #4]
 3401              		.loc 2 1616 28
 3402 000c 07F10C03 		add	r3, r7, #12
 3403 0010 1A32     		adds	r2, r2, #26
 3404 0012 1068     		ldr	r0, [r2]	@ unaligned
 3405 0014 1860     		str	r0, [r3]
 3406 0016 0023     		movs	r3, #0
 3407 0018 BA89     		ldrh	r2, [r7, #12]
 3408 001a 62F30F03 		bfi	r3, r2, #0, #16
 3409 001e FA89     		ldrh	r2, [r7, #14]
 3410 0020 62F31F43 		bfi	r3, r2, #16, #16
1617:Src/mc_interface.c **** #endif
1618:Src/mc_interface.c **** }
 3411              		.loc 2 1618 1
 3412 0024 1846     		mov	r0, r3
 3413 0026 1437     		adds	r7, r7, #20
 3414              	.LCFI283:
 3415              		.cfi_def_cfa_offset 4
 3416 0028 BD46     		mov	sp, r7
 3417              	.LCFI284:
 3418              		.cfi_def_cfa_register 13
 3419              		@ sp needed
 3420 002a 5DF8047B 		ldr	r7, [sp], #4
 3421              	.LCFI285:
 3422              		.cfi_restore 7
 3423              		.cfi_def_cfa_offset 0
 3424 002e 7047     		bx	lr
 3425              		.cfi_endproc
 3426              	.LFE1140:
 3428              		.section	.text.MCI_GetElAngledpp,"ax",%progbits
 3429              		.align	1
 3430              		.weak	MCI_GetElAngledpp
 3431              		.syntax unified
 3432              		.thumb
 3433              		.thumb_func
 3435              	MCI_GetElAngledpp:
 3436              	.LFB1141:
1619:Src/mc_interface.c **** 
1620:Src/mc_interface.c **** /**
1621:Src/mc_interface.c ****   * @brief  It returns the rotor electrical angle actually used for reference
1622:Src/mc_interface.c ****   *         frame transformation
1623:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
1624:Src/mc_interface.c ****   * @retval int16_t Rotor electrical angle in dpp format
1625:Src/mc_interface.c ****   */
1626:Src/mc_interface.c **** __weak int16_t MCI_GetElAngledpp(MCI_Handle_t *pHandle) //cstat !MISRAC2012-Rule-8.13
1627:Src/mc_interface.c **** {
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 94


 3437              		.loc 2 1627 1
 3438              		.cfi_startproc
 3439              		@ args = 0, pretend = 0, frame = 8
 3440              		@ frame_needed = 1, uses_anonymous_args = 0
 3441              		@ link register save eliminated.
 3442 0000 80B4     		push	{r7}
 3443              	.LCFI286:
 3444              		.cfi_def_cfa_offset 4
 3445              		.cfi_offset 7, -4
 3446 0002 83B0     		sub	sp, sp, #12
 3447              	.LCFI287:
 3448              		.cfi_def_cfa_offset 16
 3449 0004 00AF     		add	r7, sp, #0
 3450              	.LCFI288:
 3451              		.cfi_def_cfa_register 7
 3452 0006 7860     		str	r0, [r7, #4]
1628:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
1629:Src/mc_interface.c ****   return ((MC_NULL == pHandle) ? 0 : pHandle->pFOCVars->hElAngle);
1630:Src/mc_interface.c **** #else
1631:Src/mc_interface.c ****   return (pHandle->pFOCVars->hElAngle);
 3453              		.loc 2 1631 18
 3454 0008 7B68     		ldr	r3, [r7, #4]
 3455 000a 5B68     		ldr	r3, [r3, #4]
 3456              		.loc 2 1631 28
 3457 000c B3F92030 		ldrsh	r3, [r3, #32]
1632:Src/mc_interface.c **** #endif
1633:Src/mc_interface.c **** }
 3458              		.loc 2 1633 1
 3459 0010 1846     		mov	r0, r3
 3460 0012 0C37     		adds	r7, r7, #12
 3461              	.LCFI289:
 3462              		.cfi_def_cfa_offset 4
 3463 0014 BD46     		mov	sp, r7
 3464              	.LCFI290:
 3465              		.cfi_def_cfa_register 13
 3466              		@ sp needed
 3467 0016 5DF8047B 		ldr	r7, [sp], #4
 3468              	.LCFI291:
 3469              		.cfi_restore 7
 3470              		.cfi_def_cfa_offset 0
 3471 001a 7047     		bx	lr
 3472              		.cfi_endproc
 3473              	.LFE1141:
 3475              		.section	.text.MCI_GetTeref,"ax",%progbits
 3476              		.align	1
 3477              		.weak	MCI_GetTeref
 3478              		.syntax unified
 3479              		.thumb
 3480              		.thumb_func
 3482              	MCI_GetTeref:
 3483              	.LFB1142:
1634:Src/mc_interface.c **** 
1635:Src/mc_interface.c **** /**
1636:Src/mc_interface.c ****   * @brief  It returns the reference electrical torque, fed to derived class for
1637:Src/mc_interface.c ****   *         Iqref and Idref computation
1638:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
1639:Src/mc_interface.c ****   * @retval int16_t Teref
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 95


1640:Src/mc_interface.c ****   */
1641:Src/mc_interface.c **** __weak int16_t MCI_GetTeref(MCI_Handle_t *pHandle) //cstat !MISRAC2012-Rule-8.13
1642:Src/mc_interface.c **** {
 3484              		.loc 2 1642 1
 3485              		.cfi_startproc
 3486              		@ args = 0, pretend = 0, frame = 8
 3487              		@ frame_needed = 1, uses_anonymous_args = 0
 3488              		@ link register save eliminated.
 3489 0000 80B4     		push	{r7}
 3490              	.LCFI292:
 3491              		.cfi_def_cfa_offset 4
 3492              		.cfi_offset 7, -4
 3493 0002 83B0     		sub	sp, sp, #12
 3494              	.LCFI293:
 3495              		.cfi_def_cfa_offset 16
 3496 0004 00AF     		add	r7, sp, #0
 3497              	.LCFI294:
 3498              		.cfi_def_cfa_register 7
 3499 0006 7860     		str	r0, [r7, #4]
1643:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
1644:Src/mc_interface.c ****   return ((MC_NULL == pHandle) ? 0 : pHandle->pFOCVars->hTeref);
1645:Src/mc_interface.c **** #else
1646:Src/mc_interface.c ****   return (pHandle->pFOCVars->hTeref);
 3500              		.loc 2 1646 18
 3501 0008 7B68     		ldr	r3, [r7, #4]
 3502 000a 5B68     		ldr	r3, [r3, #4]
 3503              		.loc 2 1646 28
 3504 000c B3F91E30 		ldrsh	r3, [r3, #30]
1647:Src/mc_interface.c **** #endif
1648:Src/mc_interface.c **** }
 3505              		.loc 2 1648 1
 3506 0010 1846     		mov	r0, r3
 3507 0012 0C37     		adds	r7, r7, #12
 3508              	.LCFI295:
 3509              		.cfi_def_cfa_offset 4
 3510 0014 BD46     		mov	sp, r7
 3511              	.LCFI296:
 3512              		.cfi_def_cfa_register 13
 3513              		@ sp needed
 3514 0016 5DF8047B 		ldr	r7, [sp], #4
 3515              	.LCFI297:
 3516              		.cfi_restore 7
 3517              		.cfi_def_cfa_offset 0
 3518 001a 7047     		bx	lr
 3519              		.cfi_endproc
 3520              	.LFE1142:
 3522              		.section	.text.MCI_GetTeref_F,"ax",%progbits
 3523              		.align	1
 3524              		.weak	MCI_GetTeref_F
 3525              		.syntax unified
 3526              		.thumb
 3527              		.thumb_func
 3529              	MCI_GetTeref_F:
 3530              	.LFB1143:
1649:Src/mc_interface.c **** 
1650:Src/mc_interface.c **** /**
1651:Src/mc_interface.c ****   * @brief  It returns the reference electrical torque.
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 96


1652:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
1653:Src/mc_interface.c ****   * @retval float_t Teref
1654:Src/mc_interface.c ****   */
1655:Src/mc_interface.c **** __weak float_t MCI_GetTeref_F(MCI_Handle_t *pHandle) //cstat !MISRAC2012-Rule-8.13
1656:Src/mc_interface.c **** {
 3531              		.loc 2 1656 1
 3532              		.cfi_startproc
 3533              		@ args = 0, pretend = 0, frame = 8
 3534              		@ frame_needed = 1, uses_anonymous_args = 0
 3535              		@ link register save eliminated.
 3536 0000 80B4     		push	{r7}
 3537              	.LCFI298:
 3538              		.cfi_def_cfa_offset 4
 3539              		.cfi_offset 7, -4
 3540 0002 83B0     		sub	sp, sp, #12
 3541              	.LCFI299:
 3542              		.cfi_def_cfa_offset 16
 3543 0004 00AF     		add	r7, sp, #0
 3544              	.LCFI300:
 3545              		.cfi_def_cfa_register 7
 3546 0006 7860     		str	r0, [r7, #4]
1657:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
1658:Src/mc_interface.c ****   return ((MC_NULL == pHandle) ? 0.0f : ((float_t)pHandle->pFOCVars->hTeref * (float_t)pHandle->pSc
1659:Src/mc_interface.c **** #else
1660:Src/mc_interface.c ****   return ((float_t)(pHandle->pFOCVars->hTeref * pHandle->pScale->current));
 3547              		.loc 2 1660 28
 3548 0008 7B68     		ldr	r3, [r7, #4]
 3549 000a 5B68     		ldr	r3, [r3, #4]
 3550              		.loc 2 1660 38
 3551 000c B3F91E30 		ldrsh	r3, [r3, #30]
 3552              		.loc 2 1660 11
 3553 0010 07EE903A 		vmov	s15, r3	@ int
 3554 0014 F8EEE77A 		vcvt.f32.s32	s15, s15
 3555              		.loc 2 1660 56
 3556 0018 7B68     		ldr	r3, [r7, #4]
 3557 001a 1B6A     		ldr	r3, [r3, #32]
 3558              		.loc 2 1660 64
 3559 001c 5B68     		ldr	r3, [r3, #4]	@ unaligned
 3560              		.loc 2 1660 11
 3561 001e 07EE103A 		vmov	s14, r3
 3562 0022 67EE877A 		vmul.f32	s15, s15, s14
1661:Src/mc_interface.c **** #endif
1662:Src/mc_interface.c **** }
 3563              		.loc 2 1662 1
 3564 0026 B0EE670A 		vmov.f32	s0, s15
 3565 002a 0C37     		adds	r7, r7, #12
 3566              	.LCFI301:
 3567              		.cfi_def_cfa_offset 4
 3568 002c BD46     		mov	sp, r7
 3569              	.LCFI302:
 3570              		.cfi_def_cfa_register 13
 3571              		@ sp needed
 3572 002e 5DF8047B 		ldr	r7, [sp], #4
 3573              	.LCFI303:
 3574              		.cfi_restore 7
 3575              		.cfi_def_cfa_offset 0
 3576 0032 7047     		bx	lr
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 97


 3577              		.cfi_endproc
 3578              	.LFE1143:
 3580              		.section	.text.MCI_GetPhaseCurrentAmplitude,"ax",%progbits
 3581              		.align	1
 3582              		.weak	MCI_GetPhaseCurrentAmplitude
 3583              		.syntax unified
 3584              		.thumb
 3585              		.thumb_func
 3587              	MCI_GetPhaseCurrentAmplitude:
 3588              	.LFB1144:
1663:Src/mc_interface.c **** 
1664:Src/mc_interface.c **** /**
1665:Src/mc_interface.c ****   * @brief  It returns the motor phase current amplitude (0-to-peak) in s16A
1666:Src/mc_interface.c ****   *         To convert s16A into Ampere following formula must be used:
1667:Src/mc_interface.c ****   *         Current(Amp) = [Current(s16A) * Vdd micro] / [65536 * Rshunt * Aop]
1668:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
1669:Src/mc_interface.c ****   * @retval int16_t Motor phase current (0-to-peak) in s16A
1670:Src/mc_interface.c ****   */
1671:Src/mc_interface.c **** __weak int16_t MCI_GetPhaseCurrentAmplitude(MCI_Handle_t *pHandle) //cstat !MISRAC2012-Rule-8.13
1672:Src/mc_interface.c **** {
 3589              		.loc 2 1672 1
 3590              		.cfi_startproc
 3591              		@ args = 0, pretend = 0, frame = 16
 3592              		@ frame_needed = 1, uses_anonymous_args = 0
 3593 0000 80B5     		push	{r7, lr}
 3594              	.LCFI304:
 3595              		.cfi_def_cfa_offset 8
 3596              		.cfi_offset 7, -8
 3597              		.cfi_offset 14, -4
 3598 0002 84B0     		sub	sp, sp, #16
 3599              	.LCFI305:
 3600              		.cfi_def_cfa_offset 24
 3601 0004 00AF     		add	r7, sp, #0
 3602              	.LCFI306:
 3603              		.cfi_def_cfa_register 7
 3604 0006 7860     		str	r0, [r7, #4]
1673:Src/mc_interface.c ****   alphabeta_t Local_Curr;
1674:Src/mc_interface.c ****   int16_t wAux;
1675:Src/mc_interface.c **** 
1676:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
1677:Src/mc_interface.c ****   if (MC_NULL == pHandle)
1678:Src/mc_interface.c ****   {
1679:Src/mc_interface.c ****     wAux = 0;
1680:Src/mc_interface.c ****   }
1681:Src/mc_interface.c ****   else
1682:Src/mc_interface.c ****   {
1683:Src/mc_interface.c **** #endif
1684:Src/mc_interface.c ****   Local_Curr = pHandle->pFOCVars->Ialphabeta;
 3605              		.loc 2 1684 23
 3606 0008 7B68     		ldr	r3, [r7, #4]
 3607 000a 5A68     		ldr	r2, [r3, #4]
 3608              		.loc 2 1684 14
 3609 000c 07F10803 		add	r3, r7, #8
 3610 0010 0432     		adds	r2, r2, #4
 3611 0012 1068     		ldr	r0, [r2]	@ unaligned
 3612 0014 1860     		str	r0, [r3]
1685:Src/mc_interface.c ****   wAux = MCM_Modulus(Local_Curr.alpha, Local_Curr.beta);
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 98


 3613              		.loc 2 1685 10
 3614 0016 B7F90830 		ldrsh	r3, [r7, #8]
 3615 001a B7F90A20 		ldrsh	r2, [r7, #10]
 3616 001e 1146     		mov	r1, r2
 3617 0020 1846     		mov	r0, r3
 3618 0022 FFF7FEFF 		bl	MCM_Modulus
 3619 0026 0346     		mov	r3, r0
 3620 0028 FB81     		strh	r3, [r7, #14]	@ movhi
1686:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
1687:Src/mc_interface.c ****   }
1688:Src/mc_interface.c **** #endif
1689:Src/mc_interface.c **** 
1690:Src/mc_interface.c ****   return (wAux);
 3621              		.loc 2 1690 10
 3622 002a B7F90E30 		ldrsh	r3, [r7, #14]
1691:Src/mc_interface.c **** }
 3623              		.loc 2 1691 1
 3624 002e 1846     		mov	r0, r3
 3625 0030 1037     		adds	r7, r7, #16
 3626              	.LCFI307:
 3627              		.cfi_def_cfa_offset 8
 3628 0032 BD46     		mov	sp, r7
 3629              	.LCFI308:
 3630              		.cfi_def_cfa_register 13
 3631              		@ sp needed
 3632 0034 80BD     		pop	{r7, pc}
 3633              		.cfi_endproc
 3634              	.LFE1144:
 3636              		.section	.text.MCI_GetPhaseVoltageAmplitude,"ax",%progbits
 3637              		.align	1
 3638              		.weak	MCI_GetPhaseVoltageAmplitude
 3639              		.syntax unified
 3640              		.thumb
 3641              		.thumb_func
 3643              	MCI_GetPhaseVoltageAmplitude:
 3644              	.LFB1145:
1692:Src/mc_interface.c **** 
1693:Src/mc_interface.c **** /**
1694:Src/mc_interface.c ****   * @brief  It returns the applied motor phase voltage amplitude (0-to-peak) in
1695:Src/mc_interface.c ****   *         s16V. To convert s16V into Volts following formula must be used:
1696:Src/mc_interface.c ****   *         PhaseVoltage(V) = [PhaseVoltage(s16A) * Vbus(V)] /[sqrt(3) *32767]
1697:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
1698:Src/mc_interface.c ****   * @retval int16_t Motor phase voltage (0-to-peak) in s16V
1699:Src/mc_interface.c ****   */
1700:Src/mc_interface.c **** __weak int16_t MCI_GetPhaseVoltageAmplitude(MCI_Handle_t *pHandle) //cstat !MISRAC2012-Rule-8.13
1701:Src/mc_interface.c **** {
 3645              		.loc 2 1701 1
 3646              		.cfi_startproc
 3647              		@ args = 0, pretend = 0, frame = 24
 3648              		@ frame_needed = 1, uses_anonymous_args = 0
 3649 0000 80B5     		push	{r7, lr}
 3650              	.LCFI309:
 3651              		.cfi_def_cfa_offset 8
 3652              		.cfi_offset 7, -8
 3653              		.cfi_offset 14, -4
 3654 0002 86B0     		sub	sp, sp, #24
 3655              	.LCFI310:
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 99


 3656              		.cfi_def_cfa_offset 32
 3657 0004 00AF     		add	r7, sp, #0
 3658              	.LCFI311:
 3659              		.cfi_def_cfa_register 7
 3660 0006 7860     		str	r0, [r7, #4]
1702:Src/mc_interface.c ****   int16_t temp_wAux;
1703:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
1704:Src/mc_interface.c ****   if (MC_NULL == pHandle)
1705:Src/mc_interface.c ****   {
1706:Src/mc_interface.c ****     temp_wAux = 0;
1707:Src/mc_interface.c ****   }
1708:Src/mc_interface.c ****   else
1709:Src/mc_interface.c ****   {
1710:Src/mc_interface.c **** #endif
1711:Src/mc_interface.c ****     alphabeta_t Local_Voltage;
1712:Src/mc_interface.c ****     int32_t wAux1;
1713:Src/mc_interface.c ****     int32_t wAux2;
1714:Src/mc_interface.c **** 
1715:Src/mc_interface.c ****     Local_Voltage = pHandle->pFOCVars->Valphabeta;
 3661              		.loc 2 1715 28
 3662 0008 7B68     		ldr	r3, [r7, #4]
 3663 000a 5A68     		ldr	r2, [r3, #4]
 3664              		.loc 2 1715 19
 3665 000c 07F10803 		add	r3, r7, #8
 3666 0010 1A32     		adds	r2, r2, #26
 3667 0012 1068     		ldr	r0, [r2]	@ unaligned
 3668 0014 1860     		str	r0, [r3]
1716:Src/mc_interface.c ****     wAux1 = (int32_t)(Local_Voltage.alpha) * Local_Voltage.alpha;
 3669              		.loc 2 1716 36
 3670 0016 B7F90830 		ldrsh	r3, [r7, #8]
 3671              		.loc 2 1716 59
 3672 001a B7F90820 		ldrsh	r2, [r7, #8]
 3673              		.loc 2 1716 11
 3674 001e 02FB03F3 		mul	r3, r2, r3
 3675 0022 7B61     		str	r3, [r7, #20]
1717:Src/mc_interface.c ****     wAux2 = (int32_t)(Local_Voltage.beta) * Local_Voltage.beta;
 3676              		.loc 2 1717 36
 3677 0024 B7F90A30 		ldrsh	r3, [r7, #10]
 3678              		.loc 2 1717 58
 3679 0028 B7F90A20 		ldrsh	r2, [r7, #10]
 3680              		.loc 2 1717 11
 3681 002c 02FB03F3 		mul	r3, r2, r3
 3682 0030 3B61     		str	r3, [r7, #16]
1718:Src/mc_interface.c **** 
1719:Src/mc_interface.c ****     wAux1 += wAux2;
 3683              		.loc 2 1719 11
 3684 0032 7A69     		ldr	r2, [r7, #20]
 3685 0034 3B69     		ldr	r3, [r7, #16]
 3686 0036 1344     		add	r3, r3, r2
 3687 0038 7B61     		str	r3, [r7, #20]
1720:Src/mc_interface.c ****     wAux1 = MCM_Sqrt(wAux1);
 3688              		.loc 2 1720 13
 3689 003a 7869     		ldr	r0, [r7, #20]
 3690 003c FFF7FEFF 		bl	MCM_Sqrt
 3691 0040 7861     		str	r0, [r7, #20]
1721:Src/mc_interface.c **** 
1722:Src/mc_interface.c ****     if (wAux1 > INT16_MAX)
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 100


 3692              		.loc 2 1722 8
 3693 0042 7B69     		ldr	r3, [r7, #20]
 3694 0044 B3F5004F 		cmp	r3, #32768
 3695 0048 02DB     		blt	.L154
1723:Src/mc_interface.c ****     {
1724:Src/mc_interface.c ****       wAux1 = (int32_t)INT16_MAX;
 3696              		.loc 2 1724 13
 3697 004a 47F6FF73 		movw	r3, #32767
 3698 004e 7B61     		str	r3, [r7, #20]
 3699              	.L154:
1725:Src/mc_interface.c ****     }
1726:Src/mc_interface.c ****     temp_wAux = (int16_t)wAux1;
 3700              		.loc 2 1726 15
 3701 0050 7B69     		ldr	r3, [r7, #20]
 3702 0052 FB81     		strh	r3, [r7, #14]	@ movhi
1727:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
1728:Src/mc_interface.c ****   }
1729:Src/mc_interface.c **** #endif
1730:Src/mc_interface.c ****   return (temp_wAux);
 3703              		.loc 2 1730 10
 3704 0054 B7F90E30 		ldrsh	r3, [r7, #14]
1731:Src/mc_interface.c **** }
 3705              		.loc 2 1731 1
 3706 0058 1846     		mov	r0, r3
 3707 005a 1837     		adds	r7, r7, #24
 3708              	.LCFI312:
 3709              		.cfi_def_cfa_offset 8
 3710 005c BD46     		mov	sp, r7
 3711              	.LCFI313:
 3712              		.cfi_def_cfa_register 13
 3713              		@ sp needed
 3714 005e 80BD     		pop	{r7, pc}
 3715              		.cfi_endproc
 3716              	.LFE1145:
 3718              		.section	.text.MCI_Clear_Iqdref,"ax",%progbits
 3719              		.align	1
 3720              		.weak	MCI_Clear_Iqdref
 3721              		.syntax unified
 3722              		.thumb
 3723              		.thumb_func
 3725              	MCI_Clear_Iqdref:
 3726              	.LFB1146:
1732:Src/mc_interface.c **** 
1733:Src/mc_interface.c **** /**
1734:Src/mc_interface.c ****   * @brief  It re-initializes Iqdref variables with their default values.
1735:Src/mc_interface.c ****   * @param  pHandle Pointer on the component instance to work on.
1736:Src/mc_interface.c ****   */
1737:Src/mc_interface.c **** __weak void MCI_Clear_Iqdref(MCI_Handle_t *pHandle)
1738:Src/mc_interface.c **** {
 3727              		.loc 2 1738 1
 3728              		.cfi_startproc
 3729              		@ args = 0, pretend = 0, frame = 8
 3730              		@ frame_needed = 1, uses_anonymous_args = 0
 3731 0000 90B5     		push	{r4, r7, lr}
 3732              	.LCFI314:
 3733              		.cfi_def_cfa_offset 12
 3734              		.cfi_offset 4, -12
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 101


 3735              		.cfi_offset 7, -8
 3736              		.cfi_offset 14, -4
 3737 0002 83B0     		sub	sp, sp, #12
 3738              	.LCFI315:
 3739              		.cfi_def_cfa_offset 24
 3740 0004 00AF     		add	r7, sp, #0
 3741              	.LCFI316:
 3742              		.cfi_def_cfa_register 7
 3743 0006 7860     		str	r0, [r7, #4]
1739:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
1740:Src/mc_interface.c ****   if (MC_NULL == pHandle)
1741:Src/mc_interface.c ****   {
1742:Src/mc_interface.c ****     /* Nothing to do */
1743:Src/mc_interface.c ****   }
1744:Src/mc_interface.c ****   else
1745:Src/mc_interface.c ****   {
1746:Src/mc_interface.c **** #endif
1747:Src/mc_interface.c ****     pHandle->pFOCVars->Iqdref = STC_GetDefaultIqdref(pHandle->pSTC);
 3744              		.loc 2 1747 33
 3745 0008 7B68     		ldr	r3, [r7, #4]
 3746 000a 1A68     		ldr	r2, [r3]
 3747              		.loc 2 1747 12
 3748 000c 7B68     		ldr	r3, [r7, #4]
 3749 000e 5C68     		ldr	r4, [r3, #4]
 3750              		.loc 2 1747 33
 3751 0010 1046     		mov	r0, r2
 3752 0012 FFF7FEFF 		bl	STC_GetDefaultIqdref
 3753 0016 0346     		mov	r3, r0
 3754 0018 1A46     		mov	r2, r3	@ movhi
 3755 001a 2282     		strh	r2, [r4, #16]	@ movhi
 3756 001c C3F30F43 		ubfx	r3, r3, #16, #16
 3757 0020 6382     		strh	r3, [r4, #18]	@ movhi
1748:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
1749:Src/mc_interface.c ****   }
1750:Src/mc_interface.c **** #endif
1751:Src/mc_interface.c **** }
 3758              		.loc 2 1751 1
 3759 0022 00BF     		nop
 3760 0024 0C37     		adds	r7, r7, #12
 3761              	.LCFI317:
 3762              		.cfi_def_cfa_offset 12
 3763 0026 BD46     		mov	sp, r7
 3764              	.LCFI318:
 3765              		.cfi_def_cfa_register 13
 3766              		@ sp needed
 3767 0028 90BD     		pop	{r4, r7, pc}
 3768              		.cfi_endproc
 3769              	.LFE1146:
 3771              		.section	.text.MCI_Clear_PerfMeasure,"ax",%progbits
 3772              		.align	1
 3773              		.weak	MCI_Clear_PerfMeasure
 3774              		.syntax unified
 3775              		.thumb
 3776              		.thumb_func
 3778              	MCI_Clear_PerfMeasure:
 3779              	.LFB1147:
1752:Src/mc_interface.c **** __weak void MCI_Clear_PerfMeasure(MCI_Handle_t *pHandle, uint8_t bMotor)
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 102


1753:Src/mc_interface.c **** {
 3780              		.loc 2 1753 1
 3781              		.cfi_startproc
 3782              		@ args = 0, pretend = 0, frame = 8
 3783              		@ frame_needed = 1, uses_anonymous_args = 0
 3784 0000 80B5     		push	{r7, lr}
 3785              	.LCFI319:
 3786              		.cfi_def_cfa_offset 8
 3787              		.cfi_offset 7, -8
 3788              		.cfi_offset 14, -4
 3789 0002 82B0     		sub	sp, sp, #8
 3790              	.LCFI320:
 3791              		.cfi_def_cfa_offset 16
 3792 0004 00AF     		add	r7, sp, #0
 3793              	.LCFI321:
 3794              		.cfi_def_cfa_register 7
 3795 0006 7860     		str	r0, [r7, #4]
 3796 0008 0B46     		mov	r3, r1
 3797 000a FB70     		strb	r3, [r7, #3]
1754:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
1755:Src/mc_interface.c ****   if (MC_NULL == pHandle)
1756:Src/mc_interface.c ****   {
1757:Src/mc_interface.c ****     /* Nothing to do */
1758:Src/mc_interface.c ****   }
1759:Src/mc_interface.c ****   else
1760:Src/mc_interface.c ****   {
1761:Src/mc_interface.c **** #endif
1762:Src/mc_interface.c ****     MC_Perf_Clear(pHandle->pPerfMeasure,bMotor);
 3798              		.loc 2 1762 5
 3799 000c 7B68     		ldr	r3, [r7, #4]
 3800 000e DB68     		ldr	r3, [r3, #12]
 3801 0010 FA78     		ldrb	r2, [r7, #3]	@ zero_extendqisi2
 3802 0012 1146     		mov	r1, r2
 3803 0014 1846     		mov	r0, r3
 3804 0016 FFF7FEFF 		bl	MC_Perf_Clear
1763:Src/mc_interface.c **** #ifdef NULL_PTR_CHECK_MC_INT
1764:Src/mc_interface.c ****   }
1765:Src/mc_interface.c **** #endif
1766:Src/mc_interface.c **** }
 3805              		.loc 2 1766 1
 3806 001a 00BF     		nop
 3807 001c 0837     		adds	r7, r7, #8
 3808              	.LCFI322:
 3809              		.cfi_def_cfa_offset 8
 3810 001e BD46     		mov	sp, r7
 3811              	.LCFI323:
 3812              		.cfi_def_cfa_register 13
 3813              		@ sp needed
 3814 0020 80BD     		pop	{r7, pc}
 3815              		.cfi_endproc
 3816              	.LFE1147:
 3818              		.text
 3819              	.Letext0:
 3820              		.file 3 "c:\\programdata\\chocolatey\\lib\\gcc-arm-embedded\\tools\\gcc-arm-none-eabi-10.3-2021.10
 3821              		.file 4 "c:\\programdata\\chocolatey\\lib\\gcc-arm-embedded\\tools\\gcc-arm-none-eabi-10.3-2021.10
 3822              		.file 5 "Drivers/CMSIS/Device/ST/STM32L4xx/Include/stm32l476xx.h"
 3823              		.file 6 "Drivers/STM32L4xx_HAL_Driver/Inc/stm32l4xx_ll_tim.h"
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 103


 3824              		.file 7 "Drivers/STM32L4xx_HAL_Driver/Inc/stm32l4xx_ll_dma.h"
 3825              		.file 8 "Inc/mc_type.h"
 3826              		.file 9 "MCSDK_v6.2.1-Full/MotorControl/MCSDK/MCLib/Any/Inc/pid_regulator.h"
 3827              		.file 10 "MCSDK_v6.2.1-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_pos_fdbk.h"
 3828              		.file 11 "MCSDK_v6.2.1-Full/MotorControl/MCSDK/MCLib/Any/Inc/speed_torq_ctrl.h"
 3829              		.file 12 "Inc/pwm_curr_fdbk.h"
 3830              		.file 13 "Inc/mc_perf.h"
 3831              		.file 14 "MCSDK_v6.2.1-Full/MotorControl/MCSDK/MCLib/Any/Inc/encoder_speed_pos_fdbk.h"
 3832              		.file 15 "MCSDK_v6.2.1-Full/MotorControl/MCSDK/MCLib/Any/Inc/trajectory_ctrl.h"
 3833              		.file 16 "Inc/mc_interface.h"
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 104


DEFINED SYMBOLS
                            *ABS*:00000000 mc_interface.c
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:20     .rodata.OFFSET_TAB_CCMRx:00000000 $d
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:23     .rodata.OFFSET_TAB_CCMRx:00000000 OFFSET_TAB_CCMRx
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:26     .rodata.SHIFT_TAB_OCxx:00000000 $d
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:29     .rodata.SHIFT_TAB_OCxx:00000000 SHIFT_TAB_OCxx
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:32     .rodata.SHIFT_TAB_ICxx:00000000 $d
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:35     .rodata.SHIFT_TAB_ICxx:00000000 SHIFT_TAB_ICxx
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:38     .rodata.SHIFT_TAB_CCxP:00000000 $d
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:41     .rodata.SHIFT_TAB_CCxP:00000000 SHIFT_TAB_CCxP
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:44     .rodata.SHIFT_TAB_OISx:00000000 $d
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:47     .rodata.SHIFT_TAB_OISx:00000000 SHIFT_TAB_OISx
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:50     .rodata.CHANNEL_OFFSET_TAB:00000000 $d
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:53     .rodata.CHANNEL_OFFSET_TAB:00000000 CHANNEL_OFFSET_TAB
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:56     .text.MCM_Modulus:00000000 $t
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:61     .text.MCM_Modulus:00000000 MCM_Modulus
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:130    .text.MCI_Init:00000000 $t
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:136    .text.MCI_Init:00000000 MCI_Init
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:228    .text.MCI_ExecSpeedRamp:00000000 $t
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:234    .text.MCI_ExecSpeedRamp:00000000 MCI_ExecSpeedRamp
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:294    .text.MCI_ExecSpeedRamp_F:00000000 $t
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:300    .text.MCI_ExecSpeedRamp_F:00000000 MCI_ExecSpeedRamp_F
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:351    .text.MCI_ExecSpeedRamp_F:00000040 $d
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:356    .text.MCI_ExecTorqueRamp:00000000 $t
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:362    .text.MCI_ExecTorqueRamp:00000000 MCI_ExecTorqueRamp
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:422    .text.MCI_ExecTorqueRamp_F:00000000 $t
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:428    .text.MCI_ExecTorqueRamp_F:00000000 MCI_ExecTorqueRamp_F
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:494    .text.MCI_SetCurrentReferences:00000000 $t
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:500    .text.MCI_SetCurrentReferences:00000000 MCI_SetCurrentReferences
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:559    .text.MCI_SetCurrentReferences_F:00000000 $t
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:565    .text.MCI_SetCurrentReferences_F:00000000 MCI_SetCurrentReferences_F
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:661    .text.MCI_ExecPositionCommand:00000000 $t
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:667    .text.MCI_ExecPositionCommand:00000000 MCI_ExecPositionCommand
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:751    .text.MCI_ExecPositionCommand:00000090 $d
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:756    .text.MCI_StartMotor:00000000 $t
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:762    .text.MCI_StartMotor:00000000 MCI_StartMotor
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:1597   .text.MCI_GetSTMState:00000000 MCI_GetSTMState
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:1862   .text.MCI_GetOccurredFaults:00000000 MCI_GetOccurredFaults
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:1907   .text.MCI_GetCurrentFaults:00000000 MCI_GetCurrentFaults
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:832    .text.MCI_StartWithPolarizationMotor:00000000 $t
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:838    .text.MCI_StartWithPolarizationMotor:00000000 MCI_StartWithPolarizationMotor
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:914    .text.MCI_StartOffsetMeasurments:00000000 $t
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:920    .text.MCI_StartOffsetMeasurments:00000000 MCI_StartOffsetMeasurments
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:992    .text.MCI_GetCalibratedOffsetsMotor:00000000 $t
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:998    .text.MCI_GetCalibratedOffsetsMotor:00000000 MCI_GetCalibratedOffsetsMotor
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:1054   .text.MCI_SetCalibratedOffsetsMotor:00000000 $t
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:1060   .text.MCI_SetCalibratedOffsetsMotor:00000000 MCI_SetCalibratedOffsetsMotor
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:1135   .text.MCI_StopMotor:00000000 $t
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:1141   .text.MCI_StopMotor:00000000 MCI_StopMotor
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:1227   .text.MCI_FaultAcknowledged:00000000 $t
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:1233   .text.MCI_FaultAcknowledged:00000000 MCI_FaultAcknowledged
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:1296   .text.MCI_FaultProcessing:00000000 $t
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:1302   .text.MCI_FaultProcessing:00000000 MCI_FaultProcessing
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:1367   .text.MCI_ExecBufferedCommands:00000000 $t
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:1373   .text.MCI_ExecBufferedCommands:00000000 MCI_ExecBufferedCommands
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:1529   .text.MCI_IsCommandAcknowledged:00000000 $t
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:1535   .text.MCI_IsCommandAcknowledged:00000000 MCI_IsCommandAcknowledged
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 105


C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:1591   .text.MCI_GetSTMState:00000000 $t
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:1636   .text.MCI_GetCtrlPositionState:00000000 $t
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:1642   .text.MCI_GetCtrlPositionState:00000000 MCI_GetCtrlPositionState
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:1680   .text.MCI_GetAlignmentStatus:00000000 $t
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:1686   .text.MCI_GetAlignmentStatus:00000000 MCI_GetAlignmentStatus
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:1724   .text.MCI_GetCurrentPosition:00000000 $t
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:1730   .text.MCI_GetCurrentPosition:00000000 MCI_GetCurrentPosition
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:1768   .text.MCI_GetTargetPosition:00000000 $t
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:1774   .text.MCI_GetTargetPosition:00000000 MCI_GetTargetPosition
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:1812   .text.MCI_GetMoveDuration:00000000 $t
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:1818   .text.MCI_GetMoveDuration:00000000 MCI_GetMoveDuration
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:1856   .text.MCI_GetOccurredFaults:00000000 $t
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:1901   .text.MCI_GetCurrentFaults:00000000 $t
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:1946   .text.MCI_GetFaultState:00000000 $t
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:1952   .text.MCI_GetFaultState:00000000 MCI_GetFaultState
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:2004   .text.MCI_GetControlMode:00000000 $t
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:2010   .text.MCI_GetControlMode:00000000 MCI_GetControlMode
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:2049   .text.MCI_GetImposedMotorDirection:00000000 $t
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:2055   .text.MCI_GetImposedMotorDirection:00000000 MCI_GetImposedMotorDirection
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:2162   .text.MCI_GetLastRampFinalSpeed:00000000 $t
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:2168   .text.MCI_GetLastRampFinalSpeed:00000000 MCI_GetLastRampFinalSpeed
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:2207   .text.MCI_GetLastRampFinalTorque:00000000 $t
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:2213   .text.MCI_GetLastRampFinalTorque:00000000 MCI_GetLastRampFinalTorque
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:2252   .text.MCI_GetLastRampFinalDuration:00000000 $t
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:2258   .text.MCI_GetLastRampFinalDuration:00000000 MCI_GetLastRampFinalDuration
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:2297   .text.MCI_GetLastRampFinalSpeed_F:00000000 $t
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:2303   .text.MCI_GetLastRampFinalSpeed_F:00000000 MCI_GetLastRampFinalSpeed_F
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:2362   .text.MCI_GetLastRampFinalSpeed_F:0000004c $d
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:2367   .text.MCI_RampCompleted:00000000 $t
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:2373   .text.MCI_RampCompleted:00000000 MCI_RampCompleted
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:2425   .text.MCI_StopSpeedRamp:00000000 $t
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:2431   .text.MCI_StopSpeedRamp:00000000 MCI_StopSpeedRamp
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:2469   .text.MCI_StopRamp:00000000 $t
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:2475   .text.MCI_StopRamp:00000000 MCI_StopRamp
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:2512   .text.MCI_GetSpdSensorReliability:00000000 $t
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:2518   .text.MCI_GetSpdSensorReliability:00000000 MCI_GetSpdSensorReliability
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:2563   .text.MCI_GetAvrgMecSpeedUnit:00000000 $t
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:2569   .text.MCI_GetAvrgMecSpeedUnit:00000000 MCI_GetAvrgMecSpeedUnit
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:2614   .text.MCI_GetAvrgMecSpeed_F:00000000 $t
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:2620   .text.MCI_GetAvrgMecSpeed_F:00000000 MCI_GetAvrgMecSpeed_F
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:2674   .text.MCI_GetAvrgMecSpeed_F:00000048 $d
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:2679   .text.MCI_GetMecSpeedRefUnit:00000000 $t
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:2685   .text.MCI_GetMecSpeedRefUnit:00000000 MCI_GetMecSpeedRefUnit
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:2723   .text.MCI_GetMecSpeedRef_F:00000000 $t
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:2729   .text.MCI_GetMecSpeedRef_F:00000000 MCI_GetMecSpeedRef_F
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:2776   .text.MCI_GetMecSpeedRef_F:0000003c $d
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:2781   .text.MCI_GetIab:00000000 $t
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:2787   .text.MCI_GetIab:00000000 MCI_GetIab
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:2835   .text.MCI_GetIab_F:00000000 $t
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:2841   .text.MCI_GetIab_F:00000000 MCI_GetIab_F
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:2923   .text.MCI_GetIalphabeta:00000000 $t
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:2929   .text.MCI_GetIalphabeta:00000000 MCI_GetIalphabeta
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:2978   .text.MCI_GetIqd:00000000 $t
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:2984   .text.MCI_GetIqd:00000000 MCI_GetIqd
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:3033   .text.MCI_GetIqd_F:00000000 $t
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:3039   .text.MCI_GetIqd_F:00000000 MCI_GetIqd_F
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:3121   .text.MCI_GetIqdHF:00000000 $t
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s 			page 106


C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:3127   .text.MCI_GetIqdHF:00000000 MCI_GetIqdHF
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:3176   .text.MCI_GetIqdref:00000000 $t
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:3182   .text.MCI_GetIqdref:00000000 MCI_GetIqdref
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:3231   .text.MCI_GetIqdref_F:00000000 $t
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:3237   .text.MCI_GetIqdref_F:00000000 MCI_GetIqdref_F
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:3319   .text.MCI_GetVqd:00000000 $t
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:3325   .text.MCI_GetVqd:00000000 MCI_GetVqd
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:3374   .text.MCI_GetValphabeta:00000000 $t
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:3380   .text.MCI_GetValphabeta:00000000 MCI_GetValphabeta
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:3429   .text.MCI_GetElAngledpp:00000000 $t
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:3435   .text.MCI_GetElAngledpp:00000000 MCI_GetElAngledpp
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:3476   .text.MCI_GetTeref:00000000 $t
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:3482   .text.MCI_GetTeref:00000000 MCI_GetTeref
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:3523   .text.MCI_GetTeref_F:00000000 $t
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:3529   .text.MCI_GetTeref_F:00000000 MCI_GetTeref_F
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:3581   .text.MCI_GetPhaseCurrentAmplitude:00000000 $t
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:3587   .text.MCI_GetPhaseCurrentAmplitude:00000000 MCI_GetPhaseCurrentAmplitude
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:3637   .text.MCI_GetPhaseVoltageAmplitude:00000000 $t
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:3643   .text.MCI_GetPhaseVoltageAmplitude:00000000 MCI_GetPhaseVoltageAmplitude
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:3719   .text.MCI_Clear_Iqdref:00000000 $t
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:3725   .text.MCI_Clear_Iqdref:00000000 MCI_Clear_Iqdref
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:3772   .text.MCI_Clear_PerfMeasure:00000000 $t
C:\Users\ep_ygh\AppData\Local\Temp\cc7miP3c.s:3778   .text.MCI_Clear_PerfMeasure:00000000 MCI_Clear_PerfMeasure

UNDEFINED SYMBOLS
MCM_Sqrt
STC_GetSpeedSensor
SPD_GetMecAngle
TC_MoveCommand
TC_FollowCommand
PWMC_GetOffsetCalib
PWMC_SetOffsetCalib
STC_SetControlMode
STC_ExecRamp
TC_GetControlPositionStatus
TC_GetAlignmentStatus
TC_GetCurrentPosition
TC_GetTargetPosition
TC_GetMoveDuration
STC_RampCompleted
STC_StopSpeedRamp
STC_StopRamp
SPD_Check
SPD_GetAvrgMecSpeedUnit
STC_GetMecSpeedRefUnit
STC_GetDefaultIqdref
MC_Perf_Clear
