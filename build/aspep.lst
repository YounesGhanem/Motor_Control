ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s 			page 1


   1              		.cpu cortex-m4
   2              		.arch armv7e-m
   3              		.fpu fpv4-sp-d16
   4              		.eabi_attribute 27, 1
   5              		.eabi_attribute 28, 1
   6              		.eabi_attribute 20, 1
   7              		.eabi_attribute 21, 1
   8              		.eabi_attribute 23, 3
   9              		.eabi_attribute 24, 1
  10              		.eabi_attribute 25, 1
  11              		.eabi_attribute 26, 1
  12              		.eabi_attribute 30, 6
  13              		.eabi_attribute 34, 1
  14              		.eabi_attribute 18, 4
  15              		.file	"aspep.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.section	.rodata.OFFSET_TAB_CCMRx,"a"
  20              		.align	2
  23              	OFFSET_TAB_CCMRx:
  24 0000 00000000 		.ascii	"\000\000\000\000\004\004\004<<"
  24      0404043C 
  24      3C
  25              		.section	.rodata.SHIFT_TAB_OCxx,"a"
  26              		.align	2
  29              	SHIFT_TAB_OCxx:
  30 0000 00000800 		.ascii	"\000\000\010\000\000\000\010\000\010"
  30      00000800 
  30      08
  31              		.section	.rodata.SHIFT_TAB_ICxx,"a"
  32              		.align	2
  35              	SHIFT_TAB_ICxx:
  36 0000 00000800 		.ascii	"\000\000\010\000\000\000\010\000\000"
  36      00000800 
  36      00
  37              		.section	.rodata.SHIFT_TAB_CCxP,"a"
  38              		.align	2
  41              	SHIFT_TAB_CCxP:
  42 0000 00020406 		.ascii	"\000\002\004\006\010\012\014\020\024"
  42      080A0C10 
  42      14
  43              		.section	.rodata.SHIFT_TAB_OISx,"a"
  44              		.align	2
  47              	SHIFT_TAB_OISx:
  48 0000 00010203 		.ascii	"\000\001\002\003\004\005\006\010\012"
  48      04050608 
  48      0A
  49              		.section	.rodata.CHANNEL_OFFSET_TAB,"a"
  50              		.align	2
  53              	CHANNEL_OFFSET_TAB:
  54 0000 081C3044 		.ascii	"\010\0340DXl\200"
  54      586C80
  55              		.section	.rodata.CRC4_Lookup8,"a"
  56              		.align	2
  59              	CRC4_Lookup8:
  60 0000 00020406 		.ascii	"\000\002\004\006\010\012\014\016\007\005\003\001\017"
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s 			page 2


  60      080A0C0E 
  60      07050301 
  60      0F
  61 000d 0D0B0907 		.ascii	"\015\013\011\007\005\003\001\017\015\013\011\000\002"
  61      0503010F 
  61      0D0B0900 
  61      02
  62 001a 0406080A 		.ascii	"\004\006\010\012\014\016\016\014\012\010\006\004\002"
  62      0C0E0E0C 
  62      0A080604 
  62      02
  63 0027 00090B0D 		.ascii	"\000\011\013\015\017\001\003\005\007\011\013\015\017"
  63      0F010305 
  63      07090B0D 
  63      0F
  64 0034 01030507 		.ascii	"\001\003\005\007\016\014\012\010\006\004\002\000\013"
  64      0E0C0A08 
  64      06040200 
  64      0B
  65 0041 090F0D03 		.ascii	"\011\017\015\003\001\007\005\014\016\010\012\004\006"
  65      0107050C 
  65      0E080A04 
  65      06
  66 004e 00020C0E 		.ascii	"\000\002\014\016\010\012\004\006\000\002\013\011\017"
  66      080A0406 
  66      00020B09 
  66      0F
  67 005b 0D030107 		.ascii	"\015\003\001\007\005\005\007\001\003\015\017\011\013"
  67      05050701 
  67      030D0F09 
  67      0B
  68 0068 02000604 		.ascii	"\002\000\006\004\012\010\016\014\002\000\006\004\012"
  68      0A080E0C 
  68      02000604 
  68      0A
  69 0075 080E0C05 		.ascii	"\010\016\014\005\007\001\003\015\017\011\013\001\003"
  69      0701030D 
  69      0F090B01 
  69      03
  70 0082 0507090B 		.ascii	"\005\007\011\013\015\017\006\004\002\000\016\014\012"
  70      0D0F0604 
  70      02000E0C 
  70      0A
  71 008f 08060402 		.ascii	"\010\006\004\002\000\016\014\012\010\001\003\005\007"
  71      000E0C0A 
  71      08010305 
  71      07
  72 009c 090B0D0F 		.ascii	"\011\013\015\017\017\015\013\011\007\005\003\001\010"
  72      0F0D0B09 
  72      07050301 
  72      08
  73 00a9 0A0C0E00 		.ascii	"\012\014\016\000\002\004\006\010\012\014\016\000\002"
  73      02040608 
  73      0A0C0E00 
  73      02
  74 00b6 04060F0D 		.ascii	"\004\006\017\015\013\011\007\005\003\001\012\010\016"
  74      0B090705 
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s 			page 3


  74      03010A08 
  74      0E
  75 00c3 0C020006 		.ascii	"\014\002\000\006\004\015\017\011\013\005\007\001\003"
  75      040D0F09 
  75      0B050701 
  75      03
  76 00d0 0D0F090B 		.ascii	"\015\017\011\013\005\007\001\003\012\010\016\014\002"
  76      05070103 
  76      0A080E0C 
  76      02
  77 00dd 00060404 		.ascii	"\000\006\004\004\006\000\002\014\016\010\012\003\001"
  77      0600020C 
  77      0E080A03 
  77      01
  78 00ea 07050B09 		.ascii	"\007\005\013\011\017\015\003\001\007\005\013\011\017"
  78      0F0D0301 
  78      07050B09 
  78      0F
  79 00f7 0D040600 		.ascii	"\015\004\006\000\002\014\016\010\012"
  79      020C0E08 
  79      0A
  80              		.section	.rodata.CRC4_Lookup4,"a"
  81              		.align	2
  84              	CRC4_Lookup4:
  85 0000 00070E09 		.ascii	"\000\007\016\011\013\014\005\002\001\006\017\010\012"
  85      0B0C0502 
  85      01060F08 
  85      0A
  86 000d 0D0403   		.ascii	"\015\004\003"
  87              		.section	.text.ASPEP_ComputeHeaderCRC,"ax",%progbits
  88              		.align	1
  89              		.syntax unified
  90              		.thumb
  91              		.thumb_func
  93              	ASPEP_ComputeHeaderCRC:
  94              	.LFB1090:
  95              		.file 1 "Src/aspep.c"
   1:Src/aspep.c   **** 
   2:Src/aspep.c   **** /**
   3:Src/aspep.c   ****   ******************************************************************************
   4:Src/aspep.c   ****   * @file   aspep.c
   5:Src/aspep.c   ****   * @author Motor Control SDK Team, ST Microelectronics
   6:Src/aspep.c   ****   * @brief  This file provides firmware functions that implement the aspep protocol
   7:Src/aspep.c   ****   *
   8:Src/aspep.c   ****   *
   9:Src/aspep.c   ****   ******************************************************************************
  10:Src/aspep.c   ****   * @attention
  11:Src/aspep.c   ****   *
  12:Src/aspep.c   ****   * <h2><center>&copy; Copyright (c) 2023 STMicroelectronics.
  13:Src/aspep.c   ****   * All rights reserved.</center></h2>
  14:Src/aspep.c   ****   *
  15:Src/aspep.c   ****   * This software component is licensed by ST under Ultimate Liberty license
  16:Src/aspep.c   ****   * SLA0044, the "License"; You may not use this file except in compliance with
  17:Src/aspep.c   ****   * the License. You may obtain a copy of the License at:
  18:Src/aspep.c   ****   *                             www.st.com/SLA0044
  19:Src/aspep.c   ****   *
  20:Src/aspep.c   ****   ******************************************************************************
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s 			page 4


  21:Src/aspep.c   ****   */
  22:Src/aspep.c   **** #include <stdint.h>
  23:Src/aspep.c   **** #include "aspep.h"
  24:Src/aspep.c   **** 
  25:Src/aspep.c   **** /* Local definition */
  26:Src/aspep.c   **** #define MIN(a,b) ( ((a) < (b)) ? (a) : (b) )
  27:Src/aspep.c   **** 
  28:Src/aspep.c   **** /* Local functions */
  29:Src/aspep.c   **** static bool ASPEP_CheckBeacon (ASPEP_Handle_t *pHandle);
  30:Src/aspep.c   **** static uint8_t ASPEP_TXframeProcess(ASPEP_Handle_t *pHandle, uint8_t packetType, void *txBuffer, ui
  31:Src/aspep.c   **** void ASPEP_sendBeacon(ASPEP_Handle_t *pHandle, ASPEP_Capabilities_def *capabilities);
  32:Src/aspep.c   **** void ASPEP_sendPing(ASPEP_Handle_t *pHandle, uint8_t state, uint16_t PacketNumber);
  33:Src/aspep.c   **** 
  34:Src/aspep.c   **** /** @addtogroup MCSDK
  35:Src/aspep.c   ****   * @{
  36:Src/aspep.c   ****   */
  37:Src/aspep.c   **** 
  38:Src/aspep.c   **** /** @addtogroup MCP
  39:Src/aspep.c   ****   * @{
  40:Src/aspep.c   ****   */
  41:Src/aspep.c   **** 
  42:Src/aspep.c   **** #ifndef CRC4_PER_NIBBLE
  43:Src/aspep.c   **** /**
  44:Src/aspep.c   ****   * @brief CRC-4 lookup table with 256 entries
  45:Src/aspep.c   ****   *
  46:Src/aspep.c   ****   * Computes and checks the CRC on the header with the BYTE granularity.
  47:Src/aspep.c   ****   *
  48:Src/aspep.c   ****   * When computing the CRC, the 7th nibble must to be processed with the CRC_Lookup4
  49:Src/aspep.c   ****   * table. Indeed, the header contains 7 nibbles (28 bits) of data on which the CRC is
  50:Src/aspep.c   ****   * to be computed. Hence, the CRC4_Lookup8 table cannot be used for the last nibble.
  51:Src/aspep.c   ****   *
  52:Src/aspep.c   ****   * Using only this lookup table requires that the amount of input data is a multiple of
  53:Src/aspep.c   ****   * 8 bits.
  54:Src/aspep.c   ****   */
  55:Src/aspep.c   **** static uint8_t const CRC4_Lookup8[] =
  56:Src/aspep.c   **** {
  57:Src/aspep.c   ****   /*          0,    1,    2,    3,    4,    5,    6,    7,    8,    9,   A,     B,    C,    D,    E
  58:Src/aspep.c   ****   /* 0 */  0x00, 0x02, 0x04, 0x06, 0x08, 0x0a, 0x0c, 0x0e, 0x07, 0x05, 0x03, 0x01, 0x0f, 0x0d, 0x0b
  59:Src/aspep.c   ****   /* 1 */  0x07, 0x05, 0x03, 0x01, 0x0f, 0x0d, 0x0b, 0x09, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0a, 0x0c
  60:Src/aspep.c   ****   /* 2 */  0x0e, 0x0c, 0x0a, 0x08, 0x06, 0x04, 0x02, 0x00, 0x09, 0x0b, 0x0d, 0x0f, 0x01, 0x03, 0x05
  61:Src/aspep.c   ****   /* 3 */  0x09, 0x0b, 0x0d, 0x0f, 0x01, 0x03, 0x05, 0x07, 0x0e, 0x0c, 0x0a, 0x08, 0x06, 0x04, 0x02
  62:Src/aspep.c   ****   /* 4 */  0x0b, 0x09, 0x0f, 0x0d, 0x03, 0x01, 0x07, 0x05, 0x0c, 0x0e, 0x08, 0x0a, 0x04, 0x06, 0x00
  63:Src/aspep.c   ****   /* 5 */  0x0c, 0x0e, 0x08, 0x0a, 0x04, 0x06, 0x00, 0x02, 0x0b, 0x09, 0x0f, 0x0d, 0x03, 0x01, 0x07
  64:Src/aspep.c   ****   /* 6 */  0x05, 0x07, 0x01, 0x03, 0x0d, 0x0f, 0x09, 0x0b, 0x02, 0x00, 0x06, 0x04, 0x0a, 0x08, 0x0e
  65:Src/aspep.c   ****   /* 7 */  0x02, 0x00, 0x06, 0x04, 0x0a, 0x08, 0x0e, 0x0c, 0x05, 0x07, 0x01, 0x03, 0x0d, 0x0f, 0x09
  66:Src/aspep.c   ****   /* 8 */  0x01, 0x03, 0x05, 0x07, 0x09, 0x0b, 0x0d, 0x0f, 0x06, 0x04, 0x02, 0x00, 0x0e, 0x0c, 0x0a
  67:Src/aspep.c   ****   /* 9 */  0x06, 0x04, 0x02, 0x00, 0x0e, 0x0c, 0x0a, 0x08, 0x01, 0x03, 0x05, 0x07, 0x09, 0x0b, 0x0d
  68:Src/aspep.c   ****   /* A */  0x0f, 0x0d, 0x0b, 0x09, 0x07, 0x05, 0x03, 0x01, 0x08, 0x0a, 0x0c, 0x0e, 0x00, 0x02, 0x04
  69:Src/aspep.c   ****   /* B */  0x08, 0x0a, 0x0c, 0x0e, 0x00, 0x02, 0x04, 0x06, 0x0f, 0x0d, 0x0b, 0x09, 0x07, 0x05, 0x03
  70:Src/aspep.c   ****   /* C */  0x0a, 0x08, 0x0e, 0x0c, 0x02, 0x00, 0x06, 0x04, 0x0d, 0x0f, 0x09, 0x0b, 0x05, 0x07, 0x01
  71:Src/aspep.c   ****   /* D */  0x0d, 0x0f, 0x09, 0x0b, 0x05, 0x07, 0x01, 0x03, 0x0a, 0x08, 0x0e, 0x0c, 0x02, 0x00, 0x06
  72:Src/aspep.c   ****   /* E */  0x04, 0x06, 0x00, 0x02, 0x0c, 0x0e, 0x08, 0x0a, 0x03, 0x01, 0x07, 0x05, 0x0b, 0x09, 0x0f
  73:Src/aspep.c   ****   /* F */  0x03, 0x01, 0x07, 0x05, 0x0b, 0x09, 0x0f, 0x0d, 0x04, 0x06, 0x00, 0x02, 0x0c, 0x0e, 0x08
  74:Src/aspep.c   **** };
  75:Src/aspep.c   **** 
  76:Src/aspep.c   **** /**
  77:Src/aspep.c   ****   * @brief CRC-4 lookup table with 16 entries
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s 			page 5


  78:Src/aspep.c   ****   *
  79:Src/aspep.c   ****   *  Used to compute and check the CRC on the header with either the BYTE or NIBBLE granularity
  80:Src/aspep.c   ****   * In case the BYTE granularity is used, the table is used only with the 7th nibble of the header
  81:Src/aspep.c   ****   * (bits 24 to 27) when computing the CRC.
  82:Src/aspep.c   ****   */
  83:Src/aspep.c   ****   //cstat !MISRAC2012-Rule-8.9_a
  84:Src/aspep.c   **** static uint8_t const CRC4_Lookup4[] =
  85:Src/aspep.c   **** {
  86:Src/aspep.c   ****   /*   0,    1,    2,    3,    4,    5,    6,    7,    8,    9,   A,     B,    C,    D,    E,    F 
  87:Src/aspep.c   ****   0x00, 0x07, 0x0e, 0x09, 0x0b, 0x0c, 0x05, 0x02, 0x01, 0x06, 0x0f, 0x08, 0x0a, 0x0d, 0x04, 0x03
  88:Src/aspep.c   **** };
  89:Src/aspep.c   **** #endif /* CRC4_PER_NIBBLE */
  90:Src/aspep.c   **** 
  91:Src/aspep.c   **** /**
  92:Src/aspep.c   ****   * @brief Computes a 4-bit CRC on the 28 LSBs of @p header and returns it in the 4 MSB of the head
  93:Src/aspep.c   ****   *
  94:Src/aspep.c   ****   *  The generator polynomial used for the CRC is x^4+x+1 (ref. CCITT-G704).
  95:Src/aspep.c   ****   *
  96:Src/aspep.c   ****   *  The 28 input bits are split into 7 nibbles that are processed from the least significant to th
  97:Src/aspep.c   ****   * most significant one as follows:
  98:Src/aspep.c   ****   *
  99:Src/aspep.c   ****   *  - the least significant (4-bit) nibble is processed first as if it were the most significant p
 100:Src/aspep.c   ****   *    of the divident;
 101:Src/aspep.c   ****   *  - the order of bits in each nibble is unchanged for processing which would leads to the follow
 102:Src/aspep.c   ****   *    bit processing sequence: 3, 2, 1, 0, 7, 6, 5, 4, 11, 10, 9, 8, 15, 14, 13, 12, 19, 18, 17, 1
 103:Src/aspep.c   ****   *    23, 22, 21, 20, 27, 26, 25, 24.
 104:Src/aspep.c   ****   *
 105:Src/aspep.c   ****   *  Two lookup tables based implementations are proposed: one solely relying on a 16 entries looku
 106:Src/aspep.c   ****   * table and another one that also uses a 256 entries lookup table. This last one is the default. 
 107:Src/aspep.c   ****   * requires 256 more bytes than the first but is also roughly two times faster.
 108:Src/aspep.c   ****   *
 109:Src/aspep.c   ****   *  The 16 entries lookup table based implementation is enabled when the CRC4_PER_NIBBLE preproces
 110:Src/aspep.c   ****   * flag is defined.
 111:Src/aspep.c   ****   *
 112:Src/aspep.c   ****   *  Note that the default, 256 entries lookup table based implementation also uses the 16 entries 
 113:Src/aspep.c   ****   * table because the amount of input data is not a multiple of 8 bits.
 114:Src/aspep.c   ****   *
 115:Src/aspep.c   ****   * The resulting CRC is written in bits 28 to 31 of @p header and the whole header is returned.
 116:Src/aspep.c   ****   */
 117:Src/aspep.c   **** static void ASPEP_ComputeHeaderCRC(uint32_t *headerPtr)
 118:Src/aspep.c   **** {
  96              		.loc 1 118 1
  97              		.cfi_startproc
  98              		@ args = 0, pretend = 0, frame = 16
  99              		@ frame_needed = 1, uses_anonymous_args = 0
 100              		@ link register save eliminated.
 101 0000 80B4     		push	{r7}
 102              	.LCFI0:
 103              		.cfi_def_cfa_offset 4
 104              		.cfi_offset 7, -4
 105 0002 85B0     		sub	sp, sp, #20
 106              	.LCFI1:
 107              		.cfi_def_cfa_offset 24
 108 0004 00AF     		add	r7, sp, #0
 109              	.LCFI2:
 110              		.cfi_def_cfa_register 7
 111 0006 7860     		str	r0, [r7, #4]
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s 			page 6


 119:Src/aspep.c   ****   uint8_t crc = 0;
 112              		.loc 1 119 11
 113 0008 0023     		movs	r3, #0
 114 000a FB73     		strb	r3, [r7, #15]
 120:Src/aspep.c   ****   uint32_t header = *headerPtr;
 115              		.loc 1 120 12
 116 000c 7B68     		ldr	r3, [r7, #4]
 117 000e 1B68     		ldr	r3, [r3]
 118 0010 BB60     		str	r3, [r7, #8]
 121:Src/aspep.c   **** 
 122:Src/aspep.c   **** #ifndef CRC4_PER_NIBBLE
 123:Src/aspep.c   ****   header &= 0x0fffffffU;
 119              		.loc 1 123 10
 120 0012 BB68     		ldr	r3, [r7, #8]
 121 0014 23F07043 		bic	r3, r3, #-268435456
 122 0018 BB60     		str	r3, [r7, #8]
 124:Src/aspep.c   **** 
 125:Src/aspep.c   ****   crc = CRC4_Lookup8[crc ^ (uint8_t)(header         & 0xffU)];
 123              		.loc 1 125 28
 124 001a BB68     		ldr	r3, [r7, #8]
 125 001c DAB2     		uxtb	r2, r3
 126              		.loc 1 125 26
 127 001e FB7B     		ldrb	r3, [r7, #15]
 128 0020 5340     		eors	r3, r3, r2
 129 0022 DBB2     		uxtb	r3, r3
 130 0024 1A46     		mov	r2, r3
 131              		.loc 1 125 7
 132 0026 174B     		ldr	r3, .L2
 133 0028 9B5C     		ldrb	r3, [r3, r2]
 134 002a FB73     		strb	r3, [r7, #15]
 126:Src/aspep.c   ****   crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 8U) & 0xffU)];
 135              		.loc 1 126 46
 136 002c BB68     		ldr	r3, [r7, #8]
 137 002e 1B0A     		lsrs	r3, r3, #8
 138              		.loc 1 126 28
 139 0030 DAB2     		uxtb	r2, r3
 140              		.loc 1 126 26
 141 0032 FB7B     		ldrb	r3, [r7, #15]
 142 0034 5340     		eors	r3, r3, r2
 143 0036 DBB2     		uxtb	r3, r3
 144 0038 1A46     		mov	r2, r3
 145              		.loc 1 126 7
 146 003a 124B     		ldr	r3, .L2
 147 003c 9B5C     		ldrb	r3, [r3, r2]
 148 003e FB73     		strb	r3, [r7, #15]
 127:Src/aspep.c   ****   crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 16U) & 0xffU)];
 149              		.loc 1 127 46
 150 0040 BB68     		ldr	r3, [r7, #8]
 151 0042 1B0C     		lsrs	r3, r3, #16
 152              		.loc 1 127 28
 153 0044 DAB2     		uxtb	r2, r3
 154              		.loc 1 127 26
 155 0046 FB7B     		ldrb	r3, [r7, #15]
 156 0048 5340     		eors	r3, r3, r2
 157 004a DBB2     		uxtb	r3, r3
 158 004c 1A46     		mov	r2, r3
 159              		.loc 1 127 7
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s 			page 7


 160 004e 0D4B     		ldr	r3, .L2
 161 0050 9B5C     		ldrb	r3, [r3, r2]
 162 0052 FB73     		strb	r3, [r7, #15]
 128:Src/aspep.c   ****   crc = CRC4_Lookup4[crc ^ (uint8_t)((header >> 24U) & 0x0fU)];
 163              		.loc 1 128 26
 164 0054 FA7B     		ldrb	r2, [r7, #15]	@ zero_extendqisi2
 165              		.loc 1 128 46
 166 0056 BB68     		ldr	r3, [r7, #8]
 167 0058 1B0E     		lsrs	r3, r3, #24
 168              		.loc 1 128 28
 169 005a DBB2     		uxtb	r3, r3
 170 005c 03F00F03 		and	r3, r3, #15
 171              		.loc 1 128 26
 172 0060 5340     		eors	r3, r3, r2
 173              		.loc 1 128 7
 174 0062 094A     		ldr	r2, .L2+4
 175 0064 D35C     		ldrb	r3, [r2, r3]
 176 0066 FB73     		strb	r3, [r7, #15]
 129:Src/aspep.c   **** #else /* CRC4_PER_NIBBLE */
 130:Src/aspep.c   ****   crc = CRC4_Lookup4[crc ^ (uint8_t)(header         & 0xfU)];
 131:Src/aspep.c   ****   crc = CRC4_Lookup4[crc ^ (uint8_t)((header >>  4U) & 0xfU)];
 132:Src/aspep.c   ****   crc = CRC4_Lookup4[crc ^ (uint8_t)((header >>  8U) & 0xfU)];
 133:Src/aspep.c   ****   crc = CRC4_Lookup4[crc ^ (uint8_t)((header >> 12U) & 0xfU)];
 134:Src/aspep.c   ****   crc = CRC4_Lookup4[crc ^ (uint8_t)((header >> 16U) & 0xfU)];
 135:Src/aspep.c   ****   crc = CRC4_Lookup4[crc ^ (uint8_t)((header >> 20U) & 0xfU)];
 136:Src/aspep.c   ****   crc = CRC4_Lookup4[crc ^ (uint8_t)((header >> 24U) & 0xfU)];
 137:Src/aspep.c   **** #endif /* CRC4_PER_NIBBLE */
 138:Src/aspep.c   **** 
 139:Src/aspep.c   ****   *headerPtr |= (uint32_t)crc << 28;
 177              		.loc 1 139 14
 178 0068 7B68     		ldr	r3, [r7, #4]
 179 006a 1A68     		ldr	r2, [r3]
 180              		.loc 1 139 17
 181 006c FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 182              		.loc 1 139 31
 183 006e 1B07     		lsls	r3, r3, #28
 184              		.loc 1 139 14
 185 0070 1A43     		orrs	r2, r2, r3
 186 0072 7B68     		ldr	r3, [r7, #4]
 187 0074 1A60     		str	r2, [r3]
 140:Src/aspep.c   **** 
 141:Src/aspep.c   **** }
 188              		.loc 1 141 1
 189 0076 00BF     		nop
 190 0078 1437     		adds	r7, r7, #20
 191              	.LCFI3:
 192              		.cfi_def_cfa_offset 4
 193 007a BD46     		mov	sp, r7
 194              	.LCFI4:
 195              		.cfi_def_cfa_register 13
 196              		@ sp needed
 197 007c 5DF8047B 		ldr	r7, [sp], #4
 198              	.LCFI5:
 199              		.cfi_restore 7
 200              		.cfi_def_cfa_offset 0
 201 0080 7047     		bx	lr
 202              	.L3:
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s 			page 8


 203 0082 00BF     		.align	2
 204              	.L2:
 205 0084 00000000 		.word	CRC4_Lookup8
 206 0088 00000000 		.word	CRC4_Lookup4
 207              		.cfi_endproc
 208              	.LFE1090:
 210              		.section	.text.ASPEP_CheckHeaderCRC,"ax",%progbits
 211              		.align	1
 212              		.syntax unified
 213              		.thumb
 214              		.thumb_func
 216              	ASPEP_CheckHeaderCRC:
 217              	.LFB1091:
 142:Src/aspep.c   **** 
 143:Src/aspep.c   **** /**
 144:Src/aspep.c   ****   * @brief Checks if @p header contains a valid 4-bit CRC and return true if this is the case and f
 145:Src/aspep.c   ****   *
 146:Src/aspep.c   ****   *  The CRC is computed over the 32 bits of the @p header. If the result is 0, the CRC is consider
 147:Src/aspep.c   ****   * and true is returned. If the result is not 0, false is returned.
 148:Src/aspep.c   ****   *
 149:Src/aspep.c   ****   * @sa ASPEP_ComputeHeaderCRC
 150:Src/aspep.c   ****   */
 151:Src/aspep.c   **** static bool ASPEP_CheckHeaderCRC(uint32_t header)
 152:Src/aspep.c   **** {
 218              		.loc 1 152 1
 219              		.cfi_startproc
 220              		@ args = 0, pretend = 0, frame = 16
 221              		@ frame_needed = 1, uses_anonymous_args = 0
 222              		@ link register save eliminated.
 223 0000 80B4     		push	{r7}
 224              	.LCFI6:
 225              		.cfi_def_cfa_offset 4
 226              		.cfi_offset 7, -4
 227 0002 85B0     		sub	sp, sp, #20
 228              	.LCFI7:
 229              		.cfi_def_cfa_offset 24
 230 0004 00AF     		add	r7, sp, #0
 231              	.LCFI8:
 232              		.cfi_def_cfa_register 7
 233 0006 7860     		str	r0, [r7, #4]
 153:Src/aspep.c   ****   uint8_t crc = 0;
 234              		.loc 1 153 11
 235 0008 0023     		movs	r3, #0
 236 000a FB73     		strb	r3, [r7, #15]
 154:Src/aspep.c   **** 
 155:Src/aspep.c   **** #ifndef CRC4_PER_NIBBLE
 156:Src/aspep.c   ****   crc = CRC4_Lookup8[crc ^ (uint8_t)(header         & 0xffU)];
 237              		.loc 1 156 28
 238 000c 7B68     		ldr	r3, [r7, #4]
 239 000e DAB2     		uxtb	r2, r3
 240              		.loc 1 156 26
 241 0010 FB7B     		ldrb	r3, [r7, #15]
 242 0012 5340     		eors	r3, r3, r2
 243 0014 DBB2     		uxtb	r3, r3
 244 0016 1A46     		mov	r2, r3
 245              		.loc 1 156 7
 246 0018 164B     		ldr	r3, .L6
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s 			page 9


 247 001a 9B5C     		ldrb	r3, [r3, r2]
 248 001c FB73     		strb	r3, [r7, #15]
 157:Src/aspep.c   ****   crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 8U) & 0xffU)];
 249              		.loc 1 157 46
 250 001e 7B68     		ldr	r3, [r7, #4]
 251 0020 1B0A     		lsrs	r3, r3, #8
 252              		.loc 1 157 28
 253 0022 DAB2     		uxtb	r2, r3
 254              		.loc 1 157 26
 255 0024 FB7B     		ldrb	r3, [r7, #15]
 256 0026 5340     		eors	r3, r3, r2
 257 0028 DBB2     		uxtb	r3, r3
 258 002a 1A46     		mov	r2, r3
 259              		.loc 1 157 7
 260 002c 114B     		ldr	r3, .L6
 261 002e 9B5C     		ldrb	r3, [r3, r2]
 262 0030 FB73     		strb	r3, [r7, #15]
 158:Src/aspep.c   ****   crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 16U) & 0xffU)];
 263              		.loc 1 158 46
 264 0032 7B68     		ldr	r3, [r7, #4]
 265 0034 1B0C     		lsrs	r3, r3, #16
 266              		.loc 1 158 28
 267 0036 DAB2     		uxtb	r2, r3
 268              		.loc 1 158 26
 269 0038 FB7B     		ldrb	r3, [r7, #15]
 270 003a 5340     		eors	r3, r3, r2
 271 003c DBB2     		uxtb	r3, r3
 272 003e 1A46     		mov	r2, r3
 273              		.loc 1 158 7
 274 0040 0C4B     		ldr	r3, .L6
 275 0042 9B5C     		ldrb	r3, [r3, r2]
 276 0044 FB73     		strb	r3, [r7, #15]
 159:Src/aspep.c   ****   crc = CRC4_Lookup8[crc ^ (uint8_t)((header >> 24U) & 0xffU)];
 277              		.loc 1 159 46
 278 0046 7B68     		ldr	r3, [r7, #4]
 279 0048 1B0E     		lsrs	r3, r3, #24
 280              		.loc 1 159 28
 281 004a DAB2     		uxtb	r2, r3
 282              		.loc 1 159 26
 283 004c FB7B     		ldrb	r3, [r7, #15]
 284 004e 5340     		eors	r3, r3, r2
 285 0050 DBB2     		uxtb	r3, r3
 286 0052 1A46     		mov	r2, r3
 287              		.loc 1 159 7
 288 0054 074B     		ldr	r3, .L6
 289 0056 9B5C     		ldrb	r3, [r3, r2]
 290 0058 FB73     		strb	r3, [r7, #15]
 160:Src/aspep.c   **** #else /* CRC4_PER_NIBBLE */
 161:Src/aspep.c   ****   crc = CRC4_Lookup4[crc ^ (uint8_t)(header         & 0xfU)];
 162:Src/aspep.c   ****   crc = CRC4_Lookup4[crc ^ (uint8_t)((header >>  4U) & 0xfU)];
 163:Src/aspep.c   ****   crc = CRC4_Lookup4[crc ^ (uint8_t)((header >>  8U) & 0xfU)];
 164:Src/aspep.c   ****   crc = CRC4_Lookup4[crc ^ (uint8_t)((header >> 12U) & 0xfU)];
 165:Src/aspep.c   ****   crc = CRC4_Lookup4[crc ^ (uint8_t)((header >> 16U) & 0xfU)];
 166:Src/aspep.c   ****   crc = CRC4_Lookup4[crc ^ (uint8_t)((header >> 20U) & 0xfU)];
 167:Src/aspep.c   ****   crc = CRC4_Lookup4[crc ^ (uint8_t)((header >> 24U) & 0xfU)];
 168:Src/aspep.c   ****   crc = crc ^ (uint8_t)((header >> 28) & 0xf);
 169:Src/aspep.c   **** #endif /* CRC4_PER_NIBBLE */
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s 			page 10


 170:Src/aspep.c   **** 
 171:Src/aspep.c   ****   return (crc == 0U);
 291              		.loc 1 171 15
 292 005a FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 293 005c 002B     		cmp	r3, #0
 294 005e 0CBF     		ite	eq
 295 0060 0123     		moveq	r3, #1
 296 0062 0023     		movne	r3, #0
 297 0064 DBB2     		uxtb	r3, r3
 172:Src/aspep.c   **** }
 298              		.loc 1 172 1
 299 0066 1846     		mov	r0, r3
 300 0068 1437     		adds	r7, r7, #20
 301              	.LCFI9:
 302              		.cfi_def_cfa_offset 4
 303 006a BD46     		mov	sp, r7
 304              	.LCFI10:
 305              		.cfi_def_cfa_register 13
 306              		@ sp needed
 307 006c 5DF8047B 		ldr	r7, [sp], #4
 308              	.LCFI11:
 309              		.cfi_restore 7
 310              		.cfi_def_cfa_offset 0
 311 0070 7047     		bx	lr
 312              	.L7:
 313 0072 00BF     		.align	2
 314              	.L6:
 315 0074 00000000 		.word	CRC4_Lookup8
 316              		.cfi_endproc
 317              	.LFE1091:
 319              		.section	.text.ASPEP_start,"ax",%progbits
 320              		.align	1
 321              		.global	ASPEP_start
 322              		.syntax unified
 323              		.thumb
 324              		.thumb_func
 326              	ASPEP_start:
 327              	.LFB1092:
 173:Src/aspep.c   **** 
 174:Src/aspep.c   **** /**
 175:Src/aspep.c   ****   * @brief  Starts ASPEP communication by configuring UART.
 176:Src/aspep.c   ****   *
 177:Src/aspep.c   ****   * @param  *pHandle Handler of the current instance of the ASPEP component
 178:Src/aspep.c   ****   */
 179:Src/aspep.c   **** void ASPEP_start(ASPEP_Handle_t *pHandle)
 180:Src/aspep.c   **** {
 328              		.loc 1 180 1
 329              		.cfi_startproc
 330              		@ args = 0, pretend = 0, frame = 8
 331              		@ frame_needed = 1, uses_anonymous_args = 0
 332 0000 80B5     		push	{r7, lr}
 333              	.LCFI12:
 334              		.cfi_def_cfa_offset 8
 335              		.cfi_offset 7, -8
 336              		.cfi_offset 14, -4
 337 0002 82B0     		sub	sp, sp, #8
 338              	.LCFI13:
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s 			page 11


 339              		.cfi_def_cfa_offset 16
 340 0004 00AF     		add	r7, sp, #0
 341              	.LCFI14:
 342              		.cfi_def_cfa_register 7
 343 0006 7860     		str	r0, [r7, #4]
 181:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
 182:Src/aspep.c   ****   if (MC_NULL == pHandle)
 183:Src/aspep.c   ****   {
 184:Src/aspep.c   ****     /* Nothing to do */
 185:Src/aspep.c   ****   }
 186:Src/aspep.c   ****   else
 187:Src/aspep.c   ****   {
 188:Src/aspep.c   **** #endif
 189:Src/aspep.c   ****     pHandle->fASPEP_HWInit(pHandle->HWIp);
 344              		.loc 1 189 12
 345 0008 7B68     		ldr	r3, [r7, #4]
 346 000a DB6C     		ldr	r3, [r3, #76]
 347              		.loc 1 189 5
 348 000c 7A68     		ldr	r2, [r7, #4]
 349 000e 5269     		ldr	r2, [r2, #20]
 350 0010 1046     		mov	r0, r2
 351 0012 9847     		blx	r3
 352              	.LVL0:
 190:Src/aspep.c   ****     pHandle->ASPEP_State = ASPEP_IDLE;
 353              		.loc 1 190 26
 354 0014 7B68     		ldr	r3, [r7, #4]
 355 0016 0022     		movs	r2, #0
 356 0018 83F86420 		strb	r2, [r3, #100]
 191:Src/aspep.c   ****     pHandle->ASPEP_TL_State = WAITING_PACKET;
 357              		.loc 1 191 29
 358 001c 7B68     		ldr	r3, [r7, #4]
 359 001e 0022     		movs	r2, #0
 360 0020 83F86520 		strb	r2, [r3, #101]
 192:Src/aspep.c   ****     pHandle->syncPacketCount = 0; /* Sync packet counter is reset only at startup*/
 361              		.loc 1 192 30
 362 0024 7B68     		ldr	r3, [r7, #4]
 363 0026 0022     		movs	r2, #0
 364 0028 83F86020 		strb	r2, [r3, #96]
 193:Src/aspep.c   **** 
 194:Src/aspep.c   ****     /* Configure UART to receive first packet*/
 195:Src/aspep.c   ****     pHandle->fASPEP_receive(pHandle->HWIp, pHandle->rxHeader, ASPEP_HEADER_SIZE);
 365              		.loc 1 195 12
 366 002c 7B68     		ldr	r3, [r7, #4]
 367 002e 5B6D     		ldr	r3, [r3, #84]
 368              		.loc 1 195 5
 369 0030 7A68     		ldr	r2, [r7, #4]
 370 0032 5069     		ldr	r0, [r2, #20]
 371              		.loc 1 195 51
 372 0034 7A68     		ldr	r2, [r7, #4]
 373 0036 02F11C01 		add	r1, r2, #28
 374              		.loc 1 195 5
 375 003a 0422     		movs	r2, #4
 376 003c 9847     		blx	r3
 377              	.LVL1:
 196:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
 197:Src/aspep.c   ****   }
 198:Src/aspep.c   **** #endif
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s 			page 12


 199:Src/aspep.c   **** }
 378              		.loc 1 199 1
 379 003e 00BF     		nop
 380 0040 0837     		adds	r7, r7, #8
 381              	.LCFI15:
 382              		.cfi_def_cfa_offset 8
 383 0042 BD46     		mov	sp, r7
 384              	.LCFI16:
 385              		.cfi_def_cfa_register 13
 386              		@ sp needed
 387 0044 80BD     		pop	{r7, pc}
 388              		.cfi_endproc
 389              	.LFE1092:
 391              		.section	.text.ASPEP_sendBeacon,"ax",%progbits
 392              		.align	1
 393              		.global	ASPEP_sendBeacon
 394              		.syntax unified
 395              		.thumb
 396              		.thumb_func
 398              	ASPEP_sendBeacon:
 399              	.LFB1093:
 200:Src/aspep.c   **** 
 201:Src/aspep.c   **** /**
 202:Src/aspep.c   ****   * @brief  Sends BEACON to controller containing matched capabilities between controller and perfo
 203:Src/aspep.c   ****   *
 204:Src/aspep.c   ****   * @param  *pHandle Handler of the current instance of the ASPEP component
 205:Src/aspep.c   ****   * @param  *capabilities Matched capabilities between controller and performer
 206:Src/aspep.c   ****   */
 207:Src/aspep.c   **** void ASPEP_sendBeacon(ASPEP_Handle_t *pHandle, ASPEP_Capabilities_def *capabilities)
 208:Src/aspep.c   **** {
 400              		.loc 1 208 1
 401              		.cfi_startproc
 402              		@ args = 0, pretend = 0, frame = 16
 403              		@ frame_needed = 1, uses_anonymous_args = 0
 404 0000 80B5     		push	{r7, lr}
 405              	.LCFI17:
 406              		.cfi_def_cfa_offset 8
 407              		.cfi_offset 7, -8
 408              		.cfi_offset 14, -4
 409 0002 84B0     		sub	sp, sp, #16
 410              	.LCFI18:
 411              		.cfi_def_cfa_offset 24
 412 0004 00AF     		add	r7, sp, #0
 413              	.LCFI19:
 414              		.cfi_def_cfa_register 7
 415 0006 7860     		str	r0, [r7, #4]
 416 0008 3960     		str	r1, [r7]
 209:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
 210:Src/aspep.c   ****   if ((MC_NULL == pHandle) || (NULL == capabilities))
 211:Src/aspep.c   ****   {
 212:Src/aspep.c   ****     /* Nothing to do */
 213:Src/aspep.c   ****   }
 214:Src/aspep.c   ****   else
 215:Src/aspep.c   ****   {
 216:Src/aspep.c   **** #endif
 217:Src/aspep.c   ****     uint32_t *packet = (uint32_t *)pHandle->ctrlBuffer.buffer; //cstat !MISRAC2012-Rule-11.3
 417              		.loc 1 217 15
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s 			page 13


 418 000a 7B68     		ldr	r3, [r7, #4]
 419 000c 2033     		adds	r3, r3, #32
 420 000e FB60     		str	r3, [r7, #12]
 218:Src/aspep.c   ****     *packet = (BEACON
 219:Src/aspep.c   ****              | (((uint32_t)capabilities->version) << 4U)
 421              		.loc 1 219 40
 422 0010 3B68     		ldr	r3, [r7]
 423 0012 1B79     		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 424              		.loc 1 219 51
 425 0014 1A01     		lsls	r2, r3, #4
 220:Src/aspep.c   ****              | (((uint32_t)capabilities->DATA_CRC) << 7U)
 426              		.loc 1 220 40
 427 0016 3B68     		ldr	r3, [r7]
 428 0018 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 429              		.loc 1 220 52
 430 001a DB01     		lsls	r3, r3, #7
 431              		.loc 1 220 14
 432 001c 1A43     		orrs	r2, r2, r3
 221:Src/aspep.c   ****              | (((uint32_t)capabilities->RX_maxSize) << 8U)
 433              		.loc 1 221 40
 434 001e 3B68     		ldr	r3, [r7]
 435 0020 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 436              		.loc 1 221 54
 437 0022 1B02     		lsls	r3, r3, #8
 438              		.loc 1 221 14
 439 0024 1A43     		orrs	r2, r2, r3
 222:Src/aspep.c   ****              | (((uint32_t)capabilities->TXS_maxSize) << 14U)
 440              		.loc 1 222 40
 441 0026 3B68     		ldr	r3, [r7]
 442 0028 9B78     		ldrb	r3, [r3, #2]	@ zero_extendqisi2
 443              		.loc 1 222 55
 444 002a 9B03     		lsls	r3, r3, #14
 445              		.loc 1 222 14
 446 002c 1A43     		orrs	r2, r2, r3
 223:Src/aspep.c   ****              | (((uint32_t)capabilities->TXA_maxSize) << 21U));
 447              		.loc 1 223 40
 448 002e 3B68     		ldr	r3, [r7]
 449 0030 DB78     		ldrb	r3, [r3, #3]	@ zero_extendqisi2
 450              		.loc 1 223 55
 451 0032 5B05     		lsls	r3, r3, #21
 452              		.loc 1 223 14
 453 0034 1343     		orrs	r3, r3, r2
 454 0036 43F00502 		orr	r2, r3, #5
 218:Src/aspep.c   ****              | (((uint32_t)capabilities->version) << 4U)
 455              		.loc 1 218 13
 456 003a FB68     		ldr	r3, [r7, #12]
 457 003c 1A60     		str	r2, [r3]
 224:Src/aspep.c   **** 
 225:Src/aspep.c   ****     (void)ASPEP_TXframeProcess(pHandle, ASPEP_CTRL, &pHandle->ctrlBuffer, ASPEP_CTRL_SIZE);
 458              		.loc 1 225 53
 459 003e 7B68     		ldr	r3, [r7, #4]
 460 0040 03F12002 		add	r2, r3, #32
 461              		.loc 1 225 11
 462 0044 0423     		movs	r3, #4
 463 0046 0021     		movs	r1, #0
 464 0048 7868     		ldr	r0, [r7, #4]
 465 004a FFF7FEFF 		bl	ASPEP_TXframeProcess
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s 			page 14


 226:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
 227:Src/aspep.c   ****   }
 228:Src/aspep.c   **** #endif
 229:Src/aspep.c   **** }
 466              		.loc 1 229 1
 467 004e 00BF     		nop
 468 0050 1037     		adds	r7, r7, #16
 469              	.LCFI20:
 470              		.cfi_def_cfa_offset 8
 471 0052 BD46     		mov	sp, r7
 472              	.LCFI21:
 473              		.cfi_def_cfa_register 13
 474              		@ sp needed
 475 0054 80BD     		pop	{r7, pc}
 476              		.cfi_endproc
 477              	.LFE1093:
 479              		.section	.text.ASPEP_sendNack,"ax",%progbits
 480              		.align	1
 481              		.syntax unified
 482              		.thumb
 483              		.thumb_func
 485              	ASPEP_sendNack:
 486              	.LFB1094:
 230:Src/aspep.c   **** 
 231:Src/aspep.c   **** /**
 232:Src/aspep.c   ****   * @brief  Sends back to controller a NOT_ACKNOWLEDGED message.
 233:Src/aspep.c   ****   *
 234:Src/aspep.c   ****   * @param  *pHandle Handler of the current instance of the ASPEP component
 235:Src/aspep.c   ****   * @param  errorInfo Information on the encountered error
 236:Src/aspep.c   ****   */
 237:Src/aspep.c   **** static void ASPEP_sendNack(ASPEP_Handle_t *pHandle, uint8_t errorInfo)
 238:Src/aspep.c   **** {
 487              		.loc 1 238 1
 488              		.cfi_startproc
 489              		@ args = 0, pretend = 0, frame = 16
 490              		@ frame_needed = 1, uses_anonymous_args = 0
 491 0000 80B5     		push	{r7, lr}
 492              	.LCFI22:
 493              		.cfi_def_cfa_offset 8
 494              		.cfi_offset 7, -8
 495              		.cfi_offset 14, -4
 496 0002 84B0     		sub	sp, sp, #16
 497              	.LCFI23:
 498              		.cfi_def_cfa_offset 24
 499 0004 00AF     		add	r7, sp, #0
 500              	.LCFI24:
 501              		.cfi_def_cfa_register 7
 502 0006 7860     		str	r0, [r7, #4]
 503 0008 0B46     		mov	r3, r1
 504 000a FB70     		strb	r3, [r7, #3]
 239:Src/aspep.c   ****   uint32_t *packet = (uint32_t *)pHandle->ctrlBuffer.buffer; //cstat !MISRAC2012-Rule-11.3
 505              		.loc 1 239 13
 506 000c 7B68     		ldr	r3, [r7, #4]
 507 000e 2033     		adds	r3, r3, #32
 508 0010 FB60     		str	r3, [r7, #12]
 240:Src/aspep.c   ****   *packet = NACK | (uint32_t)(((uint32_t) errorInfo) << 8U) | (uint32_t)(((uint32_t) errorInfo) << 
 509              		.loc 1 240 32
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s 			page 15


 510 0012 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 511              		.loc 1 240 20
 512 0014 1A02     		lsls	r2, r3, #8
 513              		.loc 1 240 75
 514 0016 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 515              		.loc 1 240 63
 516 0018 1B04     		lsls	r3, r3, #16
 517              		.loc 1 240 61
 518 001a 1343     		orrs	r3, r3, r2
 519 001c 43F00F02 		orr	r2, r3, #15
 520              		.loc 1 240 11
 521 0020 FB68     		ldr	r3, [r7, #12]
 522 0022 1A60     		str	r2, [r3]
 241:Src/aspep.c   ****   (void)ASPEP_TXframeProcess(pHandle, ASPEP_CTRL, &pHandle->ctrlBuffer, ASPEP_CTRL_SIZE);
 523              		.loc 1 241 51
 524 0024 7B68     		ldr	r3, [r7, #4]
 525 0026 03F12002 		add	r2, r3, #32
 526              		.loc 1 241 9
 527 002a 0423     		movs	r3, #4
 528 002c 0021     		movs	r1, #0
 529 002e 7868     		ldr	r0, [r7, #4]
 530 0030 FFF7FEFF 		bl	ASPEP_TXframeProcess
 242:Src/aspep.c   **** }
 531              		.loc 1 242 1
 532 0034 00BF     		nop
 533 0036 1037     		adds	r7, r7, #16
 534              	.LCFI25:
 535              		.cfi_def_cfa_offset 8
 536 0038 BD46     		mov	sp, r7
 537              	.LCFI26:
 538              		.cfi_def_cfa_register 13
 539              		@ sp needed
 540 003a 80BD     		pop	{r7, pc}
 541              		.cfi_endproc
 542              	.LFE1094:
 544              		.section	.text.ASPEP_sendPing,"ax",%progbits
 545              		.align	1
 546              		.global	ASPEP_sendPing
 547              		.syntax unified
 548              		.thumb
 549              		.thumb_func
 551              	ASPEP_sendPing:
 552              	.LFB1095:
 243:Src/aspep.c   **** 
 244:Src/aspep.c   **** /**
 245:Src/aspep.c   ****   * @brief  Sends back ping to controller once connection has been established.
 246:Src/aspep.c   ****   *
 247:Src/aspep.c   ****   * @param  *pHandle Handler of the current instance of the ASPEP component
 248:Src/aspep.c   ****   * @param  cBit Set to 1 if Performer has not been reset during communication
 249:Src/aspep.c   ****   * @param  packetNumber Number of requested packet incremented throughout the entire communication
 250:Src/aspep.c   ****   */
 251:Src/aspep.c   **** void ASPEP_sendPing(ASPEP_Handle_t *pHandle, uint8_t cBit, uint16_t packetNumber)
 252:Src/aspep.c   **** {
 553              		.loc 1 252 1
 554              		.cfi_startproc
 555              		@ args = 0, pretend = 0, frame = 16
 556              		@ frame_needed = 1, uses_anonymous_args = 0
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s 			page 16


 557 0000 80B5     		push	{r7, lr}
 558              	.LCFI27:
 559              		.cfi_def_cfa_offset 8
 560              		.cfi_offset 7, -8
 561              		.cfi_offset 14, -4
 562 0002 84B0     		sub	sp, sp, #16
 563              	.LCFI28:
 564              		.cfi_def_cfa_offset 24
 565 0004 00AF     		add	r7, sp, #0
 566              	.LCFI29:
 567              		.cfi_def_cfa_register 7
 568 0006 7860     		str	r0, [r7, #4]
 569 0008 0B46     		mov	r3, r1
 570 000a FB70     		strb	r3, [r7, #3]
 571 000c 1346     		mov	r3, r2	@ movhi
 572 000e 3B80     		strh	r3, [r7]	@ movhi
 253:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
 254:Src/aspep.c   ****   if (MC_NULL == pHandle)
 255:Src/aspep.c   ****   {
 256:Src/aspep.c   ****     /* Nothing to do */
 257:Src/aspep.c   ****   }
 258:Src/aspep.c   ****   else
 259:Src/aspep.c   ****   {
 260:Src/aspep.c   **** #endif
 261:Src/aspep.c   ****     uint32_t *packet = (uint32_t *)pHandle->ctrlBuffer.buffer; //cstat !MISRAC2012-Rule-11.3
 573              		.loc 1 261 15
 574 0010 7B68     		ldr	r3, [r7, #4]
 575 0012 2033     		adds	r3, r3, #32
 576 0014 FB60     		str	r3, [r7, #12]
 262:Src/aspep.c   ****     uint8_t Nbit = pHandle->syncPacketCount & 0x1U; /* Keep only LSB */
 577              		.loc 1 262 27
 578 0016 7B68     		ldr	r3, [r7, #4]
 579 0018 93F86030 		ldrb	r3, [r3, #96]	@ zero_extendqisi2
 580              		.loc 1 262 13
 581 001c 03F00103 		and	r3, r3, #1
 582 0020 FB72     		strb	r3, [r7, #11]
 263:Src/aspep.c   ****     uint8_t ipID = pHandle->liid & 0xFU;
 583              		.loc 1 263 27
 584 0022 7B68     		ldr	r3, [r7, #4]
 585 0024 93F86330 		ldrb	r3, [r3, #99]	@ zero_extendqisi2
 586              		.loc 1 263 13
 587 0028 03F00F03 		and	r3, r3, #15
 588 002c BB72     		strb	r3, [r7, #10]
 264:Src/aspep.c   ****     *packet = PING | (uint32_t)((uint32_t)cBit << 4U)
 589              		.loc 1 264 33
 590 002e FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 591              		.loc 1 264 22
 592 0030 1A01     		lsls	r2, r3, #4
 265:Src/aspep.c   ****                    | (uint32_t)((uint32_t)cBit << 5U)
 593              		.loc 1 265 33
 594 0032 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 595              		.loc 1 265 22
 596 0034 5B01     		lsls	r3, r3, #5
 597              		.loc 1 265 20
 598 0036 1A43     		orrs	r2, r2, r3
 266:Src/aspep.c   ****                    | (uint32_t)((uint32_t)Nbit << 6U)
 599              		.loc 1 266 33
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s 			page 17


 600 0038 FB7A     		ldrb	r3, [r7, #11]	@ zero_extendqisi2
 601              		.loc 1 266 22
 602 003a 9B01     		lsls	r3, r3, #6
 603              		.loc 1 266 20
 604 003c 1A43     		orrs	r2, r2, r3
 267:Src/aspep.c   ****                    | (uint32_t)((uint32_t)Nbit << 7U)
 605              		.loc 1 267 33
 606 003e FB7A     		ldrb	r3, [r7, #11]	@ zero_extendqisi2
 607              		.loc 1 267 22
 608 0040 DB01     		lsls	r3, r3, #7
 609              		.loc 1 267 20
 610 0042 1A43     		orrs	r2, r2, r3
 268:Src/aspep.c   ****                    | (uint32_t)((uint32_t)ipID << 8U)
 611              		.loc 1 268 33
 612 0044 BB7A     		ldrb	r3, [r7, #10]	@ zero_extendqisi2
 613              		.loc 1 268 22
 614 0046 1B02     		lsls	r3, r3, #8
 615              		.loc 1 268 20
 616 0048 1A43     		orrs	r2, r2, r3
 269:Src/aspep.c   ****                    | (uint32_t)(((uint32_t) packetNumber) << 12U);
 617              		.loc 1 269 34
 618 004a 3B88     		ldrh	r3, [r7]
 619              		.loc 1 269 22
 620 004c 1B03     		lsls	r3, r3, #12
 621              		.loc 1 269 20
 622 004e 1343     		orrs	r3, r3, r2
 623 0050 43F00602 		orr	r2, r3, #6
 264:Src/aspep.c   ****                    | (uint32_t)((uint32_t)cBit << 5U)
 624              		.loc 1 264 13
 625 0054 FB68     		ldr	r3, [r7, #12]
 626 0056 1A60     		str	r2, [r3]
 270:Src/aspep.c   ****     (void)ASPEP_TXframeProcess(pHandle, ASPEP_CTRL, &pHandle->ctrlBuffer, ASPEP_CTRL_SIZE);
 627              		.loc 1 270 53
 628 0058 7B68     		ldr	r3, [r7, #4]
 629 005a 03F12002 		add	r2, r3, #32
 630              		.loc 1 270 11
 631 005e 0423     		movs	r3, #4
 632 0060 0021     		movs	r1, #0
 633 0062 7868     		ldr	r0, [r7, #4]
 634 0064 FFF7FEFF 		bl	ASPEP_TXframeProcess
 271:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
 272:Src/aspep.c   ****   }
 273:Src/aspep.c   **** #endif
 274:Src/aspep.c   **** }
 635              		.loc 1 274 1
 636 0068 00BF     		nop
 637 006a 1037     		adds	r7, r7, #16
 638              	.LCFI30:
 639              		.cfi_def_cfa_offset 8
 640 006c BD46     		mov	sp, r7
 641              	.LCFI31:
 642              		.cfi_def_cfa_register 13
 643              		@ sp needed
 644 006e 80BD     		pop	{r7, pc}
 645              		.cfi_endproc
 646              	.LFE1095:
 648              		.section	.text.ASPEP_getBuffer,"ax",%progbits
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s 			page 18


 649              		.align	1
 650              		.global	ASPEP_getBuffer
 651              		.syntax unified
 652              		.thumb
 653              		.thumb_func
 655              	ASPEP_getBuffer:
 656              	.LFB1096:
 275:Src/aspep.c   **** 
 276:Src/aspep.c   **** /**
 277:Src/aspep.c   ****   * @brief  Assigns new buffer depending on buffer type request and prevents overwriting.
 278:Src/aspep.c   ****   *
 279:Src/aspep.c   ****   * @param  *pSupHandle Handler of the current instance of the MCTL component
 280:Src/aspep.c   ****   * @param  **buffer Pointer to the buffer to be assigned
 281:Src/aspep.c   ****   * @param  syncAsync Type of requested buffer, can be synchronous or asynchronous
 282:Src/aspep.c   ****   *
 283:Src/aspep.c   ****   * @return Returns true if there is a writable buffer. False otherwise.
 284:Src/aspep.c   ****   */
 285:Src/aspep.c   **** bool ASPEP_getBuffer(MCTL_Handle_t *pSupHandle, void **buffer,  uint8_t syncAsync)
 286:Src/aspep.c   **** {
 657              		.loc 1 286 1
 658              		.cfi_startproc
 659              		@ args = 0, pretend = 0, frame = 24
 660              		@ frame_needed = 1, uses_anonymous_args = 0
 661              		@ link register save eliminated.
 662 0000 80B4     		push	{r7}
 663              	.LCFI32:
 664              		.cfi_def_cfa_offset 4
 665              		.cfi_offset 7, -4
 666 0002 87B0     		sub	sp, sp, #28
 667              	.LCFI33:
 668              		.cfi_def_cfa_offset 32
 669 0004 00AF     		add	r7, sp, #0
 670              	.LCFI34:
 671              		.cfi_def_cfa_register 7
 672 0006 F860     		str	r0, [r7, #12]
 673 0008 B960     		str	r1, [r7, #8]
 674 000a 1346     		mov	r3, r2
 675 000c FB71     		strb	r3, [r7, #7]
 287:Src/aspep.c   ****   bool result = true;
 676              		.loc 1 287 8
 677 000e 0123     		movs	r3, #1
 678 0010 FB75     		strb	r3, [r7, #23]
 288:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
 289:Src/aspep.c   ****   if (MC_NULL == buffer)
 290:Src/aspep.c   ****   {
 291:Src/aspep.c   ****     result = false;
 292:Src/aspep.c   ****   }
 293:Src/aspep.c   ****   else
 294:Src/aspep.c   ****   {
 295:Src/aspep.c   **** #endif
 296:Src/aspep.c   ****     ASPEP_Handle_t *pHandle = (ASPEP_Handle_t *)pSupHandle; //cstat !MISRAC2012-Rule-11.3
 679              		.loc 1 296 21
 680 0012 FB68     		ldr	r3, [r7, #12]
 681 0014 3B61     		str	r3, [r7, #16]
 297:Src/aspep.c   **** 
 298:Src/aspep.c   ****     if (MCTL_SYNC == syncAsync)
 682              		.loc 1 298 8
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s 			page 19


 683 0016 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 684 0018 0A2B     		cmp	r3, #10
 685 001a 11D1     		bne	.L13
 299:Src/aspep.c   ****     {
 300:Src/aspep.c   ****       if (pHandle->syncBuffer.state <= writeLock) /* Possible values are free or writeLock*/
 686              		.loc 1 300 30
 687 001c 3B69     		ldr	r3, [r7, #16]
 688 001e 93F82E30 		ldrb	r3, [r3, #46]	@ zero_extendqisi2
 689              		.loc 1 300 10
 690 0022 012B     		cmp	r3, #1
 691 0024 09D8     		bhi	.L14
 301:Src/aspep.c   ****       {
 302:Src/aspep.c   ****         *buffer = &pHandle->syncBuffer.buffer[ASPEP_HEADER_SIZE];
 692              		.loc 1 302 39
 693 0026 3B69     		ldr	r3, [r7, #16]
 694 0028 9B6A     		ldr	r3, [r3, #40]
 695              		.loc 1 302 19
 696 002a 1A1D     		adds	r2, r3, #4
 697              		.loc 1 302 17
 698 002c BB68     		ldr	r3, [r7, #8]
 699 002e 1A60     		str	r2, [r3]
 303:Src/aspep.c   ****         pHandle->syncBuffer.state = writeLock;
 700              		.loc 1 303 35
 701 0030 3B69     		ldr	r3, [r7, #16]
 702 0032 0122     		movs	r2, #1
 703 0034 83F82E20 		strb	r2, [r3, #46]
 704 0038 36E0     		b	.L15
 705              	.L14:
 304:Src/aspep.c   ****       }
 305:Src/aspep.c   ****       else
 306:Src/aspep.c   ****       {
 307:Src/aspep.c   ****         result = false;
 706              		.loc 1 307 16
 707 003a 0023     		movs	r3, #0
 708 003c FB75     		strb	r3, [r7, #23]
 709 003e 33E0     		b	.L15
 710              	.L13:
 308:Src/aspep.c   ****       }
 309:Src/aspep.c   ****     }
 310:Src/aspep.c   ****     else /* Asynchronous buffer request */
 311:Src/aspep.c   ****     {
 312:Src/aspep.c   ****       if ((pHandle->asyncBufferA.state > writeLock) && (pHandle->asyncBufferB.state > writeLock))
 711              		.loc 1 312 33
 712 0040 3B69     		ldr	r3, [r7, #16]
 713 0042 93F83630 		ldrb	r3, [r3, #54]	@ zero_extendqisi2
 714              		.loc 1 312 10
 715 0046 012B     		cmp	r3, #1
 716 0048 07D9     		bls	.L16
 717              		.loc 1 312 78 discriminator 1
 718 004a 3B69     		ldr	r3, [r7, #16]
 719 004c 93F83E30 		ldrb	r3, [r3, #62]	@ zero_extendqisi2
 720              		.loc 1 312 53 discriminator 1
 721 0050 012B     		cmp	r3, #1
 722 0052 02D9     		bls	.L16
 313:Src/aspep.c   ****       {
 314:Src/aspep.c   ****         result = false;
 723              		.loc 1 314 16
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s 			page 20


 724 0054 0023     		movs	r3, #0
 725 0056 FB75     		strb	r3, [r7, #23]
 726 0058 26E0     		b	.L15
 727              	.L16:
 315:Src/aspep.c   ****       }
 316:Src/aspep.c   ****       else
 317:Src/aspep.c   ****       {
 318:Src/aspep.c   ****         if (pHandle->asyncBufferA.state <= writeLock)
 728              		.loc 1 318 34
 729 005a 3B69     		ldr	r3, [r7, #16]
 730 005c 93F83630 		ldrb	r3, [r3, #54]	@ zero_extendqisi2
 731              		.loc 1 318 12
 732 0060 012B     		cmp	r3, #1
 733 0062 0ED8     		bhi	.L17
 319:Src/aspep.c   ****         {
 320:Src/aspep.c   ****           pHandle->asyncBufferA.state = writeLock;
 734              		.loc 1 320 39
 735 0064 3B69     		ldr	r3, [r7, #16]
 736 0066 0122     		movs	r2, #1
 737 0068 83F83620 		strb	r2, [r3, #54]
 321:Src/aspep.c   ****           pHandle->lastRequestedAsyncBuff = &pHandle->asyncBufferA;
 738              		.loc 1 321 45
 739 006c 3B69     		ldr	r3, [r7, #16]
 740 006e 03F13002 		add	r2, r3, #48
 741              		.loc 1 321 43
 742 0072 3B69     		ldr	r3, [r7, #16]
 743 0074 1A64     		str	r2, [r3, #64]
 322:Src/aspep.c   ****           *buffer = &pHandle->asyncBufferA.buffer[ASPEP_HEADER_SIZE];
 744              		.loc 1 322 43
 745 0076 3B69     		ldr	r3, [r7, #16]
 746 0078 1B6B     		ldr	r3, [r3, #48]
 747              		.loc 1 322 21
 748 007a 1A1D     		adds	r2, r3, #4
 749              		.loc 1 322 19
 750 007c BB68     		ldr	r3, [r7, #8]
 751 007e 1A60     		str	r2, [r3]
 752 0080 12E0     		b	.L15
 753              	.L17:
 323:Src/aspep.c   **** #ifdef MCP_DEBUG_METRICS
 324:Src/aspep.c   ****           pHandle->asyncBufferA.RequestedNumber++;
 325:Src/aspep.c   **** #endif
 326:Src/aspep.c   ****         }
 327:Src/aspep.c   ****         else if (pHandle->asyncBufferB.state <= writeLock)
 754              		.loc 1 327 39
 755 0082 3B69     		ldr	r3, [r7, #16]
 756 0084 93F83E30 		ldrb	r3, [r3, #62]	@ zero_extendqisi2
 757              		.loc 1 327 17
 758 0088 012B     		cmp	r3, #1
 759 008a 0DD8     		bhi	.L15
 328:Src/aspep.c   ****         {
 329:Src/aspep.c   ****           pHandle->asyncBufferB.state = writeLock;
 760              		.loc 1 329 39
 761 008c 3B69     		ldr	r3, [r7, #16]
 762 008e 0122     		movs	r2, #1
 763 0090 83F83E20 		strb	r2, [r3, #62]
 330:Src/aspep.c   ****           pHandle->lastRequestedAsyncBuff = &pHandle->asyncBufferB;
 764              		.loc 1 330 45
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s 			page 21


 765 0094 3B69     		ldr	r3, [r7, #16]
 766 0096 03F13802 		add	r2, r3, #56
 767              		.loc 1 330 43
 768 009a 3B69     		ldr	r3, [r7, #16]
 769 009c 1A64     		str	r2, [r3, #64]
 331:Src/aspep.c   ****           *buffer = &pHandle->asyncBufferB.buffer[ASPEP_HEADER_SIZE];
 770              		.loc 1 331 43
 771 009e 3B69     		ldr	r3, [r7, #16]
 772 00a0 9B6B     		ldr	r3, [r3, #56]
 773              		.loc 1 331 21
 774 00a2 1A1D     		adds	r2, r3, #4
 775              		.loc 1 331 19
 776 00a4 BB68     		ldr	r3, [r7, #8]
 777 00a6 1A60     		str	r2, [r3]
 778              	.L15:
 332:Src/aspep.c   **** #ifdef MCP_DEBUG_METRICS
 333:Src/aspep.c   ****           pHandle->asyncBufferB.RequestedNumber++;
 334:Src/aspep.c   **** #endif
 335:Src/aspep.c   ****         }
 336:Src/aspep.c   ****         else
 337:Src/aspep.c   ****         {
 338:Src/aspep.c   ****           /* Nothing to do */
 339:Src/aspep.c   ****         }
 340:Src/aspep.c   ****       }
 341:Src/aspep.c   ****     }
 342:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
 343:Src/aspep.c   ****   }
 344:Src/aspep.c   **** #endif
 345:Src/aspep.c   ****   return (result);
 779              		.loc 1 345 10
 780 00a8 FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 346:Src/aspep.c   **** }
 781              		.loc 1 346 1
 782 00aa 1846     		mov	r0, r3
 783 00ac 1C37     		adds	r7, r7, #28
 784              	.LCFI35:
 785              		.cfi_def_cfa_offset 4
 786 00ae BD46     		mov	sp, r7
 787              	.LCFI36:
 788              		.cfi_def_cfa_register 13
 789              		@ sp needed
 790 00b0 5DF8047B 		ldr	r7, [sp], #4
 791              	.LCFI37:
 792              		.cfi_restore 7
 793              		.cfi_def_cfa_offset 0
 794 00b4 7047     		bx	lr
 795              		.cfi_endproc
 796              	.LFE1096:
 798              		.section	.text.ASPEP_CheckBeacon,"ax",%progbits
 799              		.align	1
 800              		.syntax unified
 801              		.thumb
 802              		.thumb_func
 804              	ASPEP_CheckBeacon:
 805              	.LFB1097:
 347:Src/aspep.c   **** 
 348:Src/aspep.c   **** /**
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s 			page 22


 349:Src/aspep.c   ****   * @brief  Checks controller's capabilities and compare them to performer's capabilities.
 350:Src/aspep.c   ****   *
 351:Src/aspep.c   ****   * @param  *pHandle Handler of the current instance of the ASPEP component
 352:Src/aspep.c   ****   *
 353:Src/aspep.c   ****   * @return Returns true if controller's capabilities match performer's one. False otherwise.
 354:Src/aspep.c   ****   */
 355:Src/aspep.c   **** bool ASPEP_CheckBeacon (ASPEP_Handle_t *pHandle)
 356:Src/aspep.c   **** {
 806              		.loc 1 356 1
 807              		.cfi_startproc
 808              		@ args = 0, pretend = 0, frame = 24
 809              		@ frame_needed = 1, uses_anonymous_args = 0
 810              		@ link register save eliminated.
 811 0000 80B4     		push	{r7}
 812              	.LCFI38:
 813              		.cfi_def_cfa_offset 4
 814              		.cfi_offset 7, -4
 815 0002 87B0     		sub	sp, sp, #28
 816              	.LCFI39:
 817              		.cfi_def_cfa_offset 32
 818 0004 00AF     		add	r7, sp, #0
 819              	.LCFI40:
 820              		.cfi_def_cfa_register 7
 821 0006 7860     		str	r0, [r7, #4]
 357:Src/aspep.c   ****   bool result = true;
 822              		.loc 1 357 8
 823 0008 0123     		movs	r3, #1
 824 000a FB75     		strb	r3, [r7, #23]
 358:Src/aspep.c   **** 
 359:Src/aspep.c   ****   uint32_t packetHeader = *((uint32_t *)pHandle->rxHeader); //cstat !MISRAC2012-Rule-11.3
 825              		.loc 1 359 41
 826 000c 7B68     		ldr	r3, [r7, #4]
 827 000e 1C33     		adds	r3, r3, #28
 828              		.loc 1 359 12
 829 0010 1B68     		ldr	r3, [r3]
 830 0012 3B61     		str	r3, [r7, #16]
 360:Src/aspep.c   ****   ASPEP_Capabilities_def MasterCapabilities;
 361:Src/aspep.c   ****   MasterCapabilities.version = (uint8_t)((packetHeader &0x70U)>> 4U);           /*Bits 4 to 6*/
 831              		.loc 1 361 63
 832 0014 3B69     		ldr	r3, [r7, #16]
 833 0016 1B09     		lsrs	r3, r3, #4
 834              		.loc 1 361 32
 835 0018 DBB2     		uxtb	r3, r3
 836 001a 03F00703 		and	r3, r3, #7
 837 001e DBB2     		uxtb	r3, r3
 838              		.loc 1 361 30
 839 0020 3B73     		strb	r3, [r7, #12]
 362:Src/aspep.c   ****   MasterCapabilities.DATA_CRC = pHandle->rxHeader[0] >> 7U ;                     /*Bit 7 */
 840              		.loc 1 362 50
 841 0022 7B68     		ldr	r3, [r7, #4]
 842 0024 1B7F     		ldrb	r3, [r3, #28]	@ zero_extendqisi2
 843              		.loc 1 362 31
 844 0026 DB09     		lsrs	r3, r3, #7
 845 0028 DBB2     		uxtb	r3, r3
 846 002a 3B72     		strb	r3, [r7, #8]
 363:Src/aspep.c   ****   MasterCapabilities.RX_maxSize = pHandle->rxHeader[1] &0x3FU;                  /*Bits 8 to  13*/
 847              		.loc 1 363 52
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s 			page 23


 848 002c 7B68     		ldr	r3, [r7, #4]
 849 002e 5B7F     		ldrb	r3, [r3, #29]	@ zero_extendqisi2
 850              		.loc 1 363 56
 851 0030 03F03F03 		and	r3, r3, #63
 852 0034 DBB2     		uxtb	r3, r3
 853              		.loc 1 363 33
 854 0036 7B72     		strb	r3, [r7, #9]
 364:Src/aspep.c   ****   MasterCapabilities.TXS_maxSize = (uint8_t)((packetHeader&0x01FC000U)  >> 14); /*Bits 14 to 20 */
 855              		.loc 1 364 73
 856 0038 3B69     		ldr	r3, [r7, #16]
 857 003a 9B0B     		lsrs	r3, r3, #14
 858              		.loc 1 364 36
 859 003c DBB2     		uxtb	r3, r3
 860 003e 03F07F03 		and	r3, r3, #127
 861 0042 DBB2     		uxtb	r3, r3
 862              		.loc 1 364 34
 863 0044 BB72     		strb	r3, [r7, #10]
 365:Src/aspep.c   ****   MasterCapabilities.TXA_maxSize = (uint8_t)((packetHeader&0xFE00000U) >> 21);  /*Bits 21 to 27  */
 864              		.loc 1 365 72
 865 0046 3B69     		ldr	r3, [r7, #16]
 866 0048 5B0D     		lsrs	r3, r3, #21
 867              		.loc 1 365 36
 868 004a DBB2     		uxtb	r3, r3
 869 004c 03F07F03 		and	r3, r3, #127
 870 0050 DBB2     		uxtb	r3, r3
 871              		.loc 1 365 34
 872 0052 FB72     		strb	r3, [r7, #11]
 366:Src/aspep.c   **** 
 367:Src/aspep.c   ****   pHandle->Capabilities.DATA_CRC = MIN(pHandle->Capabilities.DATA_CRC ,MasterCapabilities.DATA_CRC)
 873              		.loc 1 367 36
 874 0054 3A7A     		ldrb	r2, [r7, #8]	@ zero_extendqisi2
 875 0056 7B68     		ldr	r3, [r7, #4]
 876 0058 93F86C30 		ldrb	r3, [r3, #108]	@ zero_extendqisi2
 877 005c 9342     		cmp	r3, r2
 878 005e 28BF     		it	cs
 879 0060 1346     		movcs	r3, r2
 880 0062 DAB2     		uxtb	r2, r3
 881              		.loc 1 367 34
 882 0064 7B68     		ldr	r3, [r7, #4]
 883 0066 83F86C20 		strb	r2, [r3, #108]
 368:Src/aspep.c   ****   pHandle->Capabilities.RX_maxSize = MIN(pHandle->Capabilities.RX_maxSize, MasterCapabilities.RX_ma
 884              		.loc 1 368 38
 885 006a 7A7A     		ldrb	r2, [r7, #9]	@ zero_extendqisi2
 886 006c 7B68     		ldr	r3, [r7, #4]
 887 006e 93F86D30 		ldrb	r3, [r3, #109]	@ zero_extendqisi2
 888 0072 9342     		cmp	r3, r2
 889 0074 28BF     		it	cs
 890 0076 1346     		movcs	r3, r2
 891 0078 DAB2     		uxtb	r2, r3
 892              		.loc 1 368 36
 893 007a 7B68     		ldr	r3, [r7, #4]
 894 007c 83F86D20 		strb	r2, [r3, #109]
 369:Src/aspep.c   ****   pHandle->Capabilities.TXS_maxSize = MIN(pHandle->Capabilities.TXS_maxSize, MasterCapabilities.TXS
 895              		.loc 1 369 39
 896 0080 BA7A     		ldrb	r2, [r7, #10]	@ zero_extendqisi2
 897 0082 7B68     		ldr	r3, [r7, #4]
 898 0084 93F86E30 		ldrb	r3, [r3, #110]	@ zero_extendqisi2
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s 			page 24


 899 0088 9342     		cmp	r3, r2
 900 008a 28BF     		it	cs
 901 008c 1346     		movcs	r3, r2
 902 008e DAB2     		uxtb	r2, r3
 903              		.loc 1 369 37
 904 0090 7B68     		ldr	r3, [r7, #4]
 905 0092 83F86E20 		strb	r2, [r3, #110]
 370:Src/aspep.c   ****   pHandle->Capabilities.TXA_maxSize = MIN(pHandle->Capabilities.TXA_maxSize, MasterCapabilities.TXA
 906              		.loc 1 370 39
 907 0096 FA7A     		ldrb	r2, [r7, #11]	@ zero_extendqisi2
 908 0098 7B68     		ldr	r3, [r7, #4]
 909 009a 93F86F30 		ldrb	r3, [r3, #111]	@ zero_extendqisi2
 910 009e 9342     		cmp	r3, r2
 911 00a0 28BF     		it	cs
 912 00a2 1346     		movcs	r3, r2
 913 00a4 DAB2     		uxtb	r2, r3
 914              		.loc 1 370 37
 915 00a6 7B68     		ldr	r3, [r7, #4]
 916 00a8 83F86F20 		strb	r2, [r3, #111]
 371:Src/aspep.c   **** 
 372:Src/aspep.c   ****   if ((MasterCapabilities.DATA_CRC != pHandle->Capabilities.DATA_CRC)
 917              		.loc 1 372 26
 918 00ac 3A7A     		ldrb	r2, [r7, #8]	@ zero_extendqisi2
 919              		.loc 1 372 60
 920 00ae 7B68     		ldr	r3, [r7, #4]
 921 00b0 93F86C30 		ldrb	r3, [r3, #108]	@ zero_extendqisi2
 922              		.loc 1 372 6
 923 00b4 9A42     		cmp	r2, r3
 924 00b6 17D1     		bne	.L20
 373:Src/aspep.c   ****    /* Data packet the controller can send is bigger than performer can receive */
 374:Src/aspep.c   ****    || (MasterCapabilities.RX_maxSize > pHandle->Capabilities.RX_maxSize)
 925              		.loc 1 374 26
 926 00b8 7A7A     		ldrb	r2, [r7, #9]	@ zero_extendqisi2
 927              		.loc 1 374 61
 928 00ba 7B68     		ldr	r3, [r7, #4]
 929 00bc 93F86D30 		ldrb	r3, [r3, #109]	@ zero_extendqisi2
 930              		.loc 1 374 4
 931 00c0 9A42     		cmp	r2, r3
 932 00c2 11D8     		bhi	.L20
 375:Src/aspep.c   ****    /* Sync packet size alignement is required in order for the controller to be able to store it, a
 376:Src/aspep.c   ****     * response bigger than performer capability */
 377:Src/aspep.c   ****    || (pHandle->Capabilities.TXS_maxSize != MasterCapabilities.TXS_maxSize )
 933              		.loc 1 377 29
 934 00c4 7B68     		ldr	r3, [r7, #4]
 935 00c6 93F86E20 		ldrb	r2, [r3, #110]	@ zero_extendqisi2
 936              		.loc 1 377 63
 937 00ca BB7A     		ldrb	r3, [r7, #10]	@ zero_extendqisi2
 938              		.loc 1 377 4
 939 00cc 9A42     		cmp	r2, r3
 940 00ce 0BD1     		bne	.L20
 378:Src/aspep.c   ****    /* Async packet the performer can send is bigger than the controller can receive (but controller
 379:Src/aspep.c   ****     * packet than performer can transmit) */
 380:Src/aspep.c   ****    || (pHandle->Capabilities.TXA_maxSize != MasterCapabilities.TXA_maxSize )
 941              		.loc 1 380 29
 942 00d0 7B68     		ldr	r3, [r7, #4]
 943 00d2 93F86F20 		ldrb	r2, [r3, #111]	@ zero_extendqisi2
 944              		.loc 1 380 63
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s 			page 25


 945 00d6 FB7A     		ldrb	r3, [r7, #11]	@ zero_extendqisi2
 946              		.loc 1 380 4
 947 00d8 9A42     		cmp	r2, r3
 948 00da 05D1     		bne	.L20
 381:Src/aspep.c   ****    /* For the time being, controller version has to match performer version */
 382:Src/aspep.c   ****    || (MasterCapabilities.version != pHandle->Capabilities.version) )
 949              		.loc 1 382 26
 950 00dc 3A7B     		ldrb	r2, [r7, #12]	@ zero_extendqisi2
 951              		.loc 1 382 59
 952 00de 7B68     		ldr	r3, [r7, #4]
 953 00e0 93F87030 		ldrb	r3, [r3, #112]	@ zero_extendqisi2
 954              		.loc 1 382 4
 955 00e4 9A42     		cmp	r2, r3
 956 00e6 01D0     		beq	.L21
 957              	.L20:
 383:Src/aspep.c   ****   {
 384:Src/aspep.c   ****     result = false;
 958              		.loc 1 384 12
 959 00e8 0023     		movs	r3, #0
 960 00ea FB75     		strb	r3, [r7, #23]
 961              	.L21:
 385:Src/aspep.c   ****   }
 386:Src/aspep.c   ****   else
 387:Src/aspep.c   ****   {
 388:Src/aspep.c   ****     /* Nothing to do */
 389:Src/aspep.c   ****   }
 390:Src/aspep.c   **** 
 391:Src/aspep.c   ****   return (result);
 962              		.loc 1 391 10
 963 00ec FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 392:Src/aspep.c   **** }
 964              		.loc 1 392 1
 965 00ee 1846     		mov	r0, r3
 966 00f0 1C37     		adds	r7, r7, #28
 967              	.LCFI41:
 968              		.cfi_def_cfa_offset 4
 969 00f2 BD46     		mov	sp, r7
 970              	.LCFI42:
 971              		.cfi_def_cfa_register 13
 972              		@ sp needed
 973 00f4 5DF8047B 		ldr	r7, [sp], #4
 974              	.LCFI43:
 975              		.cfi_restore 7
 976              		.cfi_def_cfa_offset 0
 977 00f8 7047     		bx	lr
 978              		.cfi_endproc
 979              	.LFE1097:
 981              		.section	.text.ASPEP_sendPacket,"ax",%progbits
 982              		.align	1
 983              		.global	ASPEP_sendPacket
 984              		.syntax unified
 985              		.thumb
 986              		.thumb_func
 988              	ASPEP_sendPacket:
 989              	.LFB1098:
 393:Src/aspep.c   **** 
 394:Src/aspep.c   **** /**
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s 			page 26


 395:Src/aspep.c   ****   * @brief  Checks if any error has occurred and calls the ASPEP_TXframeProcess function.
 396:Src/aspep.c   ****   *
 397:Src/aspep.c   ****   * @param  *pSupHandle Handler of the current instance of the MCTL component
 398:Src/aspep.c   ****   * @param  *txBuffer can be 8, 16 or 32 bits, but must be 32 bits aligned
 399:Src/aspep.c   ****   * @param  txDataLength Size of useful data in byte
 400:Src/aspep.c   ****   * @param  syncAsync nature of the communication : synchronous or asynchronous
 401:Src/aspep.c   ****   *
 402:Src/aspep.c   ****   * @return Returns an ASPEP response defined in aspep.h
 403:Src/aspep.c   ****   */
 404:Src/aspep.c   **** uint8_t ASPEP_sendPacket(MCTL_Handle_t *pSupHandle, void *txBuffer, uint16_t txDataLength, uint8_t 
 405:Src/aspep.c   **** {
 990              		.loc 1 405 1
 991              		.cfi_startproc
 992              		@ args = 0, pretend = 0, frame = 40
 993              		@ frame_needed = 1, uses_anonymous_args = 0
 994 0000 80B5     		push	{r7, lr}
 995              	.LCFI44:
 996              		.cfi_def_cfa_offset 8
 997              		.cfi_offset 7, -8
 998              		.cfi_offset 14, -4
 999 0002 8AB0     		sub	sp, sp, #40
 1000              	.LCFI45:
 1001              		.cfi_def_cfa_offset 48
 1002 0004 00AF     		add	r7, sp, #0
 1003              	.LCFI46:
 1004              		.cfi_def_cfa_register 7
 1005 0006 F860     		str	r0, [r7, #12]
 1006 0008 B960     		str	r1, [r7, #8]
 1007 000a 1146     		mov	r1, r2
 1008 000c 1A46     		mov	r2, r3
 1009 000e 0B46     		mov	r3, r1	@ movhi
 1010 0010 FB80     		strh	r3, [r7, #6]	@ movhi
 1011 0012 1346     		mov	r3, r2
 1012 0014 7B71     		strb	r3, [r7, #5]
 406:Src/aspep.c   ****   uint8_t result = ASPEP_OK;
 1013              		.loc 1 406 11
 1014 0016 0023     		movs	r3, #0
 1015 0018 87F82730 		strb	r3, [r7, #39]
 407:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
 408:Src/aspep.c   ****   if ((MC_NULL == pSupHandle) || (MC_NULL == txBuffer))
 409:Src/aspep.c   ****   {
 410:Src/aspep.c   ****     result = ASPEP_BUFFER_ERROR;
 411:Src/aspep.c   ****   }
 412:Src/aspep.c   ****   else
 413:Src/aspep.c   ****   {
 414:Src/aspep.c   **** #endif
 415:Src/aspep.c   ****     uint32_t *header;
 416:Src/aspep.c   ****     uint32_t tmpHeader;
 417:Src/aspep.c   ****     uint16_t txDataLengthTemp;
 418:Src/aspep.c   ****     uint8_t *packet;
 419:Src/aspep.c   **** 
 420:Src/aspep.c   ****     txDataLengthTemp = txDataLength;
 1016              		.loc 1 420 22
 1017 001c FB88     		ldrh	r3, [r7, #6]	@ movhi
 1018 001e BB84     		strh	r3, [r7, #36]	@ movhi
 421:Src/aspep.c   ****     ASPEP_Handle_t *pHandle = (ASPEP_Handle_t *)pSupHandle; //cstat !MISRAC2012-Rule-11.3
 1019              		.loc 1 421 21
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s 			page 27


 1020 0020 FB68     		ldr	r3, [r7, #12]
 1021 0022 3B62     		str	r3, [r7, #32]
 422:Src/aspep.c   **** 
 423:Src/aspep.c   ****     if (ASPEP_CONNECTED == pHandle-> ASPEP_State)
 1022              		.loc 1 423 35
 1023 0024 3B6A     		ldr	r3, [r7, #32]
 1024 0026 93F86430 		ldrb	r3, [r3, #100]	@ zero_extendqisi2
 1025              		.loc 1 423 8
 1026 002a 022B     		cmp	r3, #2
 1027 002c 3FD1     		bne	.L24
 424:Src/aspep.c   ****     {
 425:Src/aspep.c   ****       /*We must add packet header on  */
 426:Src/aspep.c   ****       /* | [0101|0011] | Length 13b | Reserved |CRCH 4b| */
 427:Src/aspep.c   ****       packet = (uint8_t *)txBuffer; //cstat !MISRAC2012-Rule-11.5
 1028              		.loc 1 427 14
 1029 002e BB68     		ldr	r3, [r7, #8]
 1030 0030 FB61     		str	r3, [r7, #28]
 428:Src/aspep.c   ****       header = (uint32_t *)txBuffer; //cstat !MISRAC2012-Rule-11.5
 1031              		.loc 1 428 14
 1032 0032 BB68     		ldr	r3, [r7, #8]
 1033 0034 BB61     		str	r3, [r7, #24]
 429:Src/aspep.c   ****       header--; /* Header ues 4*8 bits on top of txBuffer*/
 1034              		.loc 1 429 13
 1035 0036 BB69     		ldr	r3, [r7, #24]
 1036 0038 043B     		subs	r3, r3, #4
 1037 003a BB61     		str	r3, [r7, #24]
 430:Src/aspep.c   ****       tmpHeader = ((uint32_t)((uint32_t)txDataLengthTemp << (uint32_t)4) | (uint32_t)syncAsync);
 1038              		.loc 1 430 31
 1039 003c BB8C     		ldrh	r3, [r7, #36]
 1040              		.loc 1 430 20
 1041 003e 1A01     		lsls	r2, r3, #4
 1042              		.loc 1 430 76
 1043 0040 7B79     		ldrb	r3, [r7, #5]	@ zero_extendqisi2
 1044              		.loc 1 430 17
 1045 0042 1343     		orrs	r3, r3, r2
 1046 0044 7B61     		str	r3, [r7, #20]
 431:Src/aspep.c   ****       *header = tmpHeader;
 1047              		.loc 1 431 15
 1048 0046 BB69     		ldr	r3, [r7, #24]
 1049 0048 7A69     		ldr	r2, [r7, #20]
 1050 004a 1A60     		str	r2, [r3]
 432:Src/aspep.c   ****       if (1U == pHandle->Capabilities.DATA_CRC)
 1051              		.loc 1 432 38
 1052 004c 3B6A     		ldr	r3, [r7, #32]
 1053 004e 93F86C30 		ldrb	r3, [r3, #108]	@ zero_extendqisi2
 1054              		.loc 1 432 10
 1055 0052 012B     		cmp	r3, #1
 1056 0054 0DD1     		bne	.L25
 433:Src/aspep.c   ****       {
 434:Src/aspep.c   ****         /* TODO : Compute real CRC*/
 435:Src/aspep.c   ****         packet[txDataLengthTemp] = (uint8_t)0xCA; /* Dummy CRC */
 1057              		.loc 1 435 15
 1058 0056 BB8C     		ldrh	r3, [r7, #36]
 1059 0058 FA69     		ldr	r2, [r7, #28]
 1060 005a 1344     		add	r3, r3, r2
 1061              		.loc 1 435 34
 1062 005c CA22     		movs	r2, #202
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s 			page 28


 1063 005e 1A70     		strb	r2, [r3]
 436:Src/aspep.c   ****         packet[txDataLengthTemp + 1U] = (uint8_t)0xFE; /* Dummy CRC */
 1064              		.loc 1 436 15
 1065 0060 BB8C     		ldrh	r3, [r7, #36]
 1066 0062 0133     		adds	r3, r3, #1
 1067 0064 FA69     		ldr	r2, [r7, #28]
 1068 0066 1344     		add	r3, r3, r2
 1069              		.loc 1 436 39
 1070 0068 FE22     		movs	r2, #254
 1071 006a 1A70     		strb	r2, [r3]
 437:Src/aspep.c   ****         txDataLengthTemp += (uint16_t)ASPEP_DATACRC_SIZE;
 1072              		.loc 1 437 26
 1073 006c BB8C     		ldrh	r3, [r7, #36]	@ movhi
 1074 006e 0233     		adds	r3, r3, #2
 1075 0070 BB84     		strh	r3, [r7, #36]	@ movhi
 1076              	.L25:
 438:Src/aspep.c   ****       }
 439:Src/aspep.c   ****       if (MCTL_SYNC == syncAsync)
 1077              		.loc 1 439 10
 1078 0072 7B79     		ldrb	r3, [r7, #5]	@ zero_extendqisi2
 1079 0074 0A2B     		cmp	r3, #10
 1080 0076 0AD1     		bne	.L26
 440:Src/aspep.c   ****       {
 441:Src/aspep.c   ****         if (pSupHandle->MCP_PacketAvailable)
 1081              		.loc 1 441 23
 1082 0078 FB68     		ldr	r3, [r7, #12]
 1083 007a 1B7C     		ldrb	r3, [r3, #16]	@ zero_extendqisi2
 1084              		.loc 1 441 12
 1085 007c 002B     		cmp	r3, #0
 1086 007e 03D0     		beq	.L27
 442:Src/aspep.c   ****         {
 443:Src/aspep.c   ****           pSupHandle->MCP_PacketAvailable = false; /* CMD from controller is processed*/
 1087              		.loc 1 443 43
 1088 0080 FB68     		ldr	r3, [r7, #12]
 1089 0082 0022     		movs	r2, #0
 1090 0084 1A74     		strb	r2, [r3, #16]
 1091 0086 02E0     		b	.L26
 1092              	.L27:
 444:Src/aspep.c   ****         }
 445:Src/aspep.c   ****         else
 446:Src/aspep.c   ****         {
 447:Src/aspep.c   ****           result = MCTL_SYNC_NOT_EXPECTED;
 1093              		.loc 1 447 18
 1094 0088 0123     		movs	r3, #1
 1095 008a 87F82730 		strb	r3, [r7, #39]
 1096              	.L26:
 448:Src/aspep.c   ****         }
 449:Src/aspep.c   ****       }
 450:Src/aspep.c   ****       if (ASPEP_OK == result) /* Send packet only if no error detected so far*/
 1097              		.loc 1 450 10
 1098 008e 97F82730 		ldrb	r3, [r7, #39]	@ zero_extendqisi2
 1099 0092 002B     		cmp	r3, #0
 1100 0094 0ED1     		bne	.L28
 451:Src/aspep.c   ****       {
 452:Src/aspep.c   ****         result = ASPEP_TXframeProcess(pHandle, syncAsync, header, txDataLengthTemp + (uint16_t)ASPE
 1101              		.loc 1 452 18
 1102 0096 BB8C     		ldrh	r3, [r7, #36]	@ movhi
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s 			page 29


 1103 0098 0433     		adds	r3, r3, #4
 1104 009a 9BB2     		uxth	r3, r3
 1105 009c 7979     		ldrb	r1, [r7, #5]	@ zero_extendqisi2
 1106 009e BA69     		ldr	r2, [r7, #24]
 1107 00a0 386A     		ldr	r0, [r7, #32]
 1108 00a2 FFF7FEFF 		bl	ASPEP_TXframeProcess
 1109 00a6 0346     		mov	r3, r0
 1110 00a8 87F82730 		strb	r3, [r7, #39]
 1111 00ac 02E0     		b	.L28
 1112              	.L24:
 453:Src/aspep.c   ****       }
 454:Src/aspep.c   ****     }
 455:Src/aspep.c   ****     else
 456:Src/aspep.c   ****     {
 457:Src/aspep.c   ****       result = ASPEP_NOT_CONNECTED;
 1113              		.loc 1 457 14
 1114 00ae 0223     		movs	r3, #2
 1115 00b0 87F82730 		strb	r3, [r7, #39]
 1116              	.L28:
 458:Src/aspep.c   ****     }
 459:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
 460:Src/aspep.c   ****   }
 461:Src/aspep.c   **** #endif
 462:Src/aspep.c   ****   return (result);
 1117              		.loc 1 462 10
 1118 00b4 97F82730 		ldrb	r3, [r7, #39]	@ zero_extendqisi2
 463:Src/aspep.c   **** }
 1119              		.loc 1 463 1
 1120 00b8 1846     		mov	r0, r3
 1121 00ba 2837     		adds	r7, r7, #40
 1122              	.LCFI47:
 1123              		.cfi_def_cfa_offset 8
 1124 00bc BD46     		mov	sp, r7
 1125              	.LCFI48:
 1126              		.cfi_def_cfa_register 13
 1127              		@ sp needed
 1128 00be 80BD     		pop	{r7, pc}
 1129              		.cfi_endproc
 1130              	.LFE1098:
 1132              		.section	.text.ASPEP_TXframeProcess,"ax",%progbits
 1133              		.align	1
 1134              		.syntax unified
 1135              		.thumb
 1136              		.thumb_func
 1138              	ASPEP_TXframeProcess:
 1139              	.LFB1099:
 464:Src/aspep.c   **** 
 465:Src/aspep.c   **** /**
 466:Src/aspep.c   ****   * @brief  Checks if HW resource is busy before sending packet. Otherwise saves packet for next op
 467:Src/aspep.c   ****   *
 468:Src/aspep.c   ****   * This function contains a critical section.
 469:Src/aspep.c   ****   * It can be accessed concurently under High frequency task (by MCPA_datalog)
 470:Src/aspep.c   ****   * and under Medium frequency task (MC_Scheduler -> ASPEP_RxFrameProcess ).
 471:Src/aspep.c   ****   *
 472:Src/aspep.c   ****   * @param  *pHandle Handler of the current instance of the ASPEP component
 473:Src/aspep.c   ****   * @param  dataType Nature of the communication : synchronous, asynchronous or a CTL packet
 474:Src/aspep.c   ****   * @param  *txBuffer CRC Header to be computed in sent packet
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s 			page 30


 475:Src/aspep.c   ****   * @param  bufferLength Size of the packet to be sent : Header + Data
 476:Src/aspep.c   ****   *
 477:Src/aspep.c   ****   * @return Returns an ASPEP response defined in aspep.h
 478:Src/aspep.c   ****   */
 479:Src/aspep.c   **** uint8_t ASPEP_TXframeProcess(ASPEP_Handle_t *pHandle, uint8_t dataType, void *txBuffer, uint16_t bu
 480:Src/aspep.c   **** {
 1140              		.loc 1 480 1
 1141              		.cfi_startproc
 1142              		@ args = 0, pretend = 0, frame = 24
 1143              		@ frame_needed = 1, uses_anonymous_args = 0
 1144 0000 80B5     		push	{r7, lr}
 1145              	.LCFI49:
 1146              		.cfi_def_cfa_offset 8
 1147              		.cfi_offset 7, -8
 1148              		.cfi_offset 14, -4
 1149 0002 86B0     		sub	sp, sp, #24
 1150              	.LCFI50:
 1151              		.cfi_def_cfa_offset 32
 1152 0004 00AF     		add	r7, sp, #0
 1153              	.LCFI51:
 1154              		.cfi_def_cfa_register 7
 1155 0006 F860     		str	r0, [r7, #12]
 1156 0008 7A60     		str	r2, [r7, #4]
 1157 000a 1A46     		mov	r2, r3
 1158 000c 0B46     		mov	r3, r1
 1159 000e FB72     		strb	r3, [r7, #11]
 1160 0010 1346     		mov	r3, r2	@ movhi
 1161 0012 3B81     		strh	r3, [r7, #8]	@ movhi
 481:Src/aspep.c   ****   uint8_t result = ASPEP_OK;
 1162              		.loc 1 481 11
 1163 0014 0023     		movs	r3, #0
 1164 0016 FB75     		strb	r3, [r7, #23]
 482:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
 483:Src/aspep.c   ****   if (MC_NULL == txBuffer)
 484:Src/aspep.c   ****   {
 485:Src/aspep.c   ****     result = ASPEP_BUFFER_ERROR;
 486:Src/aspep.c   ****   }
 487:Src/aspep.c   ****   else
 488:Src/aspep.c   ****   {
 489:Src/aspep.c   **** #endif
 490:Src/aspep.c   ****     /* Insert CRC header in the packet to send */
 491:Src/aspep.c   ****     ASPEP_ComputeHeaderCRC((uint32_t *)txBuffer); //cstat !MISRAC2012-Rule-11.5
 1165              		.loc 1 491 5
 1166 0018 7868     		ldr	r0, [r7, #4]
 1167 001a FFF7FEFF 		bl	ASPEP_ComputeHeaderCRC
 1168              	.LBB14:
 1169              	.LBB15:
 1170              		.file 2 "Drivers/CMSIS/Include/cmsis_gcc.h"
   1:Drivers/CMSIS/Include/cmsis_gcc.h **** /**************************************************************************//**
   2:Drivers/CMSIS/Include/cmsis_gcc.h ****  * @file     cmsis_gcc.h
   3:Drivers/CMSIS/Include/cmsis_gcc.h ****  * @brief    CMSIS compiler GCC header file
   4:Drivers/CMSIS/Include/cmsis_gcc.h ****  * @version  V5.2.0
   5:Drivers/CMSIS/Include/cmsis_gcc.h ****  * @date     08. May 2019
   6:Drivers/CMSIS/Include/cmsis_gcc.h ****  ******************************************************************************/
   7:Drivers/CMSIS/Include/cmsis_gcc.h **** /*
   8:Drivers/CMSIS/Include/cmsis_gcc.h ****  * Copyright (c) 2009-2019 Arm Limited. All rights reserved.
   9:Drivers/CMSIS/Include/cmsis_gcc.h ****  *
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s 			page 31


  10:Drivers/CMSIS/Include/cmsis_gcc.h ****  * SPDX-License-Identifier: Apache-2.0
  11:Drivers/CMSIS/Include/cmsis_gcc.h ****  *
  12:Drivers/CMSIS/Include/cmsis_gcc.h ****  * Licensed under the Apache License, Version 2.0 (the License); you may
  13:Drivers/CMSIS/Include/cmsis_gcc.h ****  * not use this file except in compliance with the License.
  14:Drivers/CMSIS/Include/cmsis_gcc.h ****  * You may obtain a copy of the License at
  15:Drivers/CMSIS/Include/cmsis_gcc.h ****  *
  16:Drivers/CMSIS/Include/cmsis_gcc.h ****  * www.apache.org/licenses/LICENSE-2.0
  17:Drivers/CMSIS/Include/cmsis_gcc.h ****  *
  18:Drivers/CMSIS/Include/cmsis_gcc.h ****  * Unless required by applicable law or agreed to in writing, software
  19:Drivers/CMSIS/Include/cmsis_gcc.h ****  * distributed under the License is distributed on an AS IS BASIS, WITHOUT
  20:Drivers/CMSIS/Include/cmsis_gcc.h ****  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  21:Drivers/CMSIS/Include/cmsis_gcc.h ****  * See the License for the specific language governing permissions and
  22:Drivers/CMSIS/Include/cmsis_gcc.h ****  * limitations under the License.
  23:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
  24:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  25:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef __CMSIS_GCC_H
  26:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_H
  27:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  28:Drivers/CMSIS/Include/cmsis_gcc.h **** /* ignore some GCC warnings */
  29:Drivers/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic push
  30:Drivers/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wsign-conversion"
  31:Drivers/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wconversion"
  32:Drivers/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wunused-parameter"
  33:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  34:Drivers/CMSIS/Include/cmsis_gcc.h **** /* Fallback for __has_builtin */
  35:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef __has_builtin
  36:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __has_builtin(x) (0)
  37:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  38:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  39:Drivers/CMSIS/Include/cmsis_gcc.h **** /* CMSIS compiler specific defines */
  40:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __ASM
  41:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __ASM                                  __asm
  42:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  43:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __INLINE
  44:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __INLINE                               inline
  45:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  46:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __STATIC_INLINE
  47:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __STATIC_INLINE                        static inline
  48:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  49:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __STATIC_FORCEINLINE                 
  50:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __STATIC_FORCEINLINE                   __attribute__((always_inline)) static inline
  51:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif                                           
  52:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __NO_RETURN
  53:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __NO_RETURN                            __attribute__((__noreturn__))
  54:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  55:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __USED
  56:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __USED                                 __attribute__((used))
  57:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  58:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __WEAK
  59:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __WEAK                                 __attribute__((weak))
  60:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  61:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __PACKED
  62:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __PACKED                               __attribute__((packed, aligned(1)))
  63:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  64:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __PACKED_STRUCT
  65:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __PACKED_STRUCT                        struct __attribute__((packed, aligned(1)))
  66:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s 			page 32


  67:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __PACKED_UNION
  68:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __PACKED_UNION                         union __attribute__((packed, aligned(1)))
  69:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  70:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32        /* deprecated */
  71:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  72:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  73:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  74:Drivers/CMSIS/Include/cmsis_gcc.h ****   struct __attribute__((packed)) T_UINT32 { uint32_t v; };
  75:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  76:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
  77:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  78:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT16_WRITE
  79:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  80:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  81:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  82:Drivers/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
  83:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  84:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void *)(addr))-
  85:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  86:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT16_READ
  87:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  88:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  89:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  90:Drivers/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
  91:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  92:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(add
  93:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  94:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32_WRITE
  95:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
  96:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  97:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  98:Drivers/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
  99:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
 100:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))-
 101:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 102:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32_READ
 103:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic push
 104:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
 105:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
 106:Drivers/CMSIS/Include/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
 107:Drivers/CMSIS/Include/cmsis_gcc.h ****   #pragma GCC diagnostic pop
 108:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(add
 109:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 110:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __ALIGNED
 111:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __ALIGNED(x)                           __attribute__((aligned(x)))
 112:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 113:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __RESTRICT
 114:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __RESTRICT                             __restrict
 115:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 116:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef   __COMPILER_BARRIER
 117:Drivers/CMSIS/Include/cmsis_gcc.h ****   #define __COMPILER_BARRIER()                   __ASM volatile("":::"memory")
 118:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 119:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 120:Drivers/CMSIS/Include/cmsis_gcc.h **** /* #########################  Startup and Lowlevel Init  ######################## */
 121:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 122:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef __PROGRAM_START
 123:Drivers/CMSIS/Include/cmsis_gcc.h **** 
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s 			page 33


 124:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 125:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Initializes data and bss sections
 126:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details This default implementations initialized all data and additional bss
 127:Drivers/CMSIS/Include/cmsis_gcc.h ****            sections relying on .copy.table and .zero.table specified properly
 128:Drivers/CMSIS/Include/cmsis_gcc.h ****            in the used linker script.
 129:Drivers/CMSIS/Include/cmsis_gcc.h ****   
 130:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 131:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE __NO_RETURN void __cmsis_start(void)
 132:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 133:Drivers/CMSIS/Include/cmsis_gcc.h ****   extern void _start(void) __NO_RETURN;
 134:Drivers/CMSIS/Include/cmsis_gcc.h ****   
 135:Drivers/CMSIS/Include/cmsis_gcc.h ****   typedef struct {
 136:Drivers/CMSIS/Include/cmsis_gcc.h ****     uint32_t const* src;
 137:Drivers/CMSIS/Include/cmsis_gcc.h ****     uint32_t* dest;
 138:Drivers/CMSIS/Include/cmsis_gcc.h ****     uint32_t  wlen;
 139:Drivers/CMSIS/Include/cmsis_gcc.h ****   } __copy_table_t;
 140:Drivers/CMSIS/Include/cmsis_gcc.h ****   
 141:Drivers/CMSIS/Include/cmsis_gcc.h ****   typedef struct {
 142:Drivers/CMSIS/Include/cmsis_gcc.h ****     uint32_t* dest;
 143:Drivers/CMSIS/Include/cmsis_gcc.h ****     uint32_t  wlen;
 144:Drivers/CMSIS/Include/cmsis_gcc.h ****   } __zero_table_t;
 145:Drivers/CMSIS/Include/cmsis_gcc.h ****   
 146:Drivers/CMSIS/Include/cmsis_gcc.h ****   extern const __copy_table_t __copy_table_start__;
 147:Drivers/CMSIS/Include/cmsis_gcc.h ****   extern const __copy_table_t __copy_table_end__;
 148:Drivers/CMSIS/Include/cmsis_gcc.h ****   extern const __zero_table_t __zero_table_start__;
 149:Drivers/CMSIS/Include/cmsis_gcc.h ****   extern const __zero_table_t __zero_table_end__;
 150:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 151:Drivers/CMSIS/Include/cmsis_gcc.h ****   for (__copy_table_t const* pTable = &__copy_table_start__; pTable < &__copy_table_end__; ++pTable
 152:Drivers/CMSIS/Include/cmsis_gcc.h ****     for(uint32_t i=0u; i<pTable->wlen; ++i) {
 153:Drivers/CMSIS/Include/cmsis_gcc.h ****       pTable->dest[i] = pTable->src[i];
 154:Drivers/CMSIS/Include/cmsis_gcc.h ****     }
 155:Drivers/CMSIS/Include/cmsis_gcc.h ****   }
 156:Drivers/CMSIS/Include/cmsis_gcc.h ****  
 157:Drivers/CMSIS/Include/cmsis_gcc.h ****   for (__zero_table_t const* pTable = &__zero_table_start__; pTable < &__zero_table_end__; ++pTable
 158:Drivers/CMSIS/Include/cmsis_gcc.h ****     for(uint32_t i=0u; i<pTable->wlen; ++i) {
 159:Drivers/CMSIS/Include/cmsis_gcc.h ****       pTable->dest[i] = 0u;
 160:Drivers/CMSIS/Include/cmsis_gcc.h ****     }
 161:Drivers/CMSIS/Include/cmsis_gcc.h ****   }
 162:Drivers/CMSIS/Include/cmsis_gcc.h ****  
 163:Drivers/CMSIS/Include/cmsis_gcc.h ****   _start();
 164:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 165:Drivers/CMSIS/Include/cmsis_gcc.h ****   
 166:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __PROGRAM_START           __cmsis_start
 167:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 168:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 169:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef __INITIAL_SP
 170:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __INITIAL_SP              __StackTop
 171:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 172:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 173:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef __STACK_LIMIT
 174:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __STACK_LIMIT             __StackLimit
 175:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 176:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 177:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef __VECTOR_TABLE
 178:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __VECTOR_TABLE            __Vectors
 179:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 180:Drivers/CMSIS/Include/cmsis_gcc.h **** 
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s 			page 34


 181:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef __VECTOR_TABLE_ATTRIBUTE
 182:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __VECTOR_TABLE_ATTRIBUTE  __attribute((used, section(".vectors")))
 183:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 184:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 185:Drivers/CMSIS/Include/cmsis_gcc.h **** /* ###########################  Core Function Access  ########################### */
 186:Drivers/CMSIS/Include/cmsis_gcc.h **** /** \ingroup  CMSIS_Core_FunctionInterface
 187:Drivers/CMSIS/Include/cmsis_gcc.h ****     \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
 188:Drivers/CMSIS/Include/cmsis_gcc.h ****   @{
 189:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 190:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 191:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 192:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Enable IRQ Interrupts
 193:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
 194:Drivers/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 195:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 196:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __enable_irq(void)
 197:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 198:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsie i" : : : "memory");
 199:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 200:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 201:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 202:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 203:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Disable IRQ Interrupts
 204:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Disables IRQ interrupts by setting the I-bit in the CPSR.
 205:Drivers/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 206:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 207:Drivers/CMSIS/Include/cmsis_gcc.h **** __STATIC_FORCEINLINE void __disable_irq(void)
 208:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 209:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsid i" : : : "memory");
 1171              		.loc 2 209 3
 1172              		.syntax unified
 1173              	@ 209 "Drivers/CMSIS/Include/cmsis_gcc.h" 1
 1174 001e 72B6     		cpsid i
 1175              	@ 0 "" 2
 210:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 1176              		.loc 2 210 1
 1177              		.thumb
 1178              		.syntax unified
 1179 0020 00BF     		nop
 1180              	.LBE15:
 1181              	.LBE14:
 492:Src/aspep.c   ****     __disable_irq(); /*TODO: Disable High frequency task is enough */
 493:Src/aspep.c   ****     if (NULL == pHandle->lockBuffer) /* Communication Ip free to send data*/
 1182              		.loc 1 493 24
 1183 0022 FB68     		ldr	r3, [r7, #12]
 1184 0024 9B6C     		ldr	r3, [r3, #72]
 1185              		.loc 1 493 8
 1186 0026 002B     		cmp	r3, #0
 1187 0028 2BD1     		bne	.L31
 494:Src/aspep.c   ****     {
 495:Src/aspep.c   ****       if (MCTL_ASYNC == dataType)
 1188              		.loc 1 495 10
 1189 002a FB7A     		ldrb	r3, [r7, #11]	@ zero_extendqisi2
 1190 002c 092B     		cmp	r3, #9
 1191 002e 08D1     		bne	.L32
 496:Src/aspep.c   ****       {
 497:Src/aspep.c   ****         /* In ASYNC, two flipflop buffers are used, the txBuffer points always to lastRequestedAsyn
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s 			page 35


 498:Src/aspep.c   ****         pHandle->lastRequestedAsyncBuff->state = readLock;
 1192              		.loc 1 498 16
 1193 0030 FB68     		ldr	r3, [r7, #12]
 1194 0032 1B6C     		ldr	r3, [r3, #64]
 1195              		.loc 1 498 48
 1196 0034 0322     		movs	r2, #3
 1197 0036 9A71     		strb	r2, [r3, #6]
 499:Src/aspep.c   ****         pHandle->lockBuffer = (void *)pHandle->lastRequestedAsyncBuff;
 1198              		.loc 1 499 46
 1199 0038 FB68     		ldr	r3, [r7, #12]
 1200 003a 1A6C     		ldr	r2, [r3, #64]
 1201              		.loc 1 499 29
 1202 003c FB68     		ldr	r3, [r7, #12]
 1203 003e 9A64     		str	r2, [r3, #72]
 1204 0040 15E0     		b	.L33
 1205              	.L32:
 500:Src/aspep.c   **** #ifdef MCP_DEBUG_METRICS
 501:Src/aspep.c   ****         pHandle->lastRequestedAsyncBuff->SentNumber++;
 502:Src/aspep.c   **** #endif
 503:Src/aspep.c   ****       }
 504:Src/aspep.c   ****       else if (MCTL_SYNC == dataType)
 1206              		.loc 1 504 15
 1207 0042 FB7A     		ldrb	r3, [r7, #11]	@ zero_extendqisi2
 1208 0044 0A2B     		cmp	r3, #10
 1209 0046 09D1     		bne	.L34
 505:Src/aspep.c   ****       {
 506:Src/aspep.c   ****         pHandle->syncBuffer.state = readLock;
 1210              		.loc 1 506 35
 1211 0048 FB68     		ldr	r3, [r7, #12]
 1212 004a 0322     		movs	r2, #3
 1213 004c 83F82E20 		strb	r2, [r3, #46]
 507:Src/aspep.c   ****         pHandle->lockBuffer = (void *)&pHandle->syncBuffer;
 1214              		.loc 1 507 39
 1215 0050 FB68     		ldr	r3, [r7, #12]
 1216 0052 03F12802 		add	r2, r3, #40
 1217              		.loc 1 507 29
 1218 0056 FB68     		ldr	r3, [r7, #12]
 1219 0058 9A64     		str	r2, [r3, #72]
 1220 005a 08E0     		b	.L33
 1221              	.L34:
 508:Src/aspep.c   ****       }
 509:Src/aspep.c   ****       else
 510:Src/aspep.c   ****       {
 511:Src/aspep.c   ****         pHandle->ctrlBuffer.state = readLock;
 1222              		.loc 1 511 35
 1223 005c FB68     		ldr	r3, [r7, #12]
 1224 005e 0322     		movs	r2, #3
 1225 0060 83F82420 		strb	r2, [r3, #36]
 512:Src/aspep.c   ****         pHandle->lockBuffer = (void *)&pHandle->ctrlBuffer;
 1226              		.loc 1 512 39
 1227 0064 FB68     		ldr	r3, [r7, #12]
 1228 0066 03F12002 		add	r2, r3, #32
 1229              		.loc 1 512 29
 1230 006a FB68     		ldr	r3, [r7, #12]
 1231 006c 9A64     		str	r2, [r3, #72]
 1232              	.L33:
 1233              	.LBB16:
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s 			page 36


 1234              	.LBB17:
 198:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 1235              		.loc 2 198 3
 1236              		.syntax unified
 1237              	@ 198 "Drivers/CMSIS/Include/cmsis_gcc.h" 1
 1238 006e 62B6     		cpsie i
 1239              	@ 0 "" 2
 199:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 1240              		.loc 2 199 1
 1241              		.thumb
 1242              		.syntax unified
 1243 0070 00BF     		nop
 1244              	.LBE17:
 1245              	.LBE16:
 513:Src/aspep.c   ****       }
 514:Src/aspep.c   ****       /* Enable HF task It */
 515:Src/aspep.c   ****       __enable_irq(); /*TODO: Enable High frequency task is enough */
 516:Src/aspep.c   ****       pHandle->fASPEP_send(pHandle->HWIp, txBuffer, bufferLength);
 1246              		.loc 1 516 14
 1247 0072 FB68     		ldr	r3, [r7, #12]
 1248 0074 9B6D     		ldr	r3, [r3, #88]
 1249              		.loc 1 516 7
 1250 0076 FA68     		ldr	r2, [r7, #12]
 1251 0078 5069     		ldr	r0, [r2, #20]
 1252 007a 3A89     		ldrh	r2, [r7, #8]
 1253 007c 7968     		ldr	r1, [r7, #4]
 1254 007e 9847     		blx	r3
 1255              	.LVL2:
 1256 0080 3FE0     		b	.L35
 1257              	.L31:
 1258              	.LBB18:
 1259              	.LBB19:
 198:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 1260              		.loc 2 198 3
 1261              		.syntax unified
 1262              	@ 198 "Drivers/CMSIS/Include/cmsis_gcc.h" 1
 1263 0082 62B6     		cpsie i
 1264              	@ 0 "" 2
 199:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 1265              		.loc 2 199 1
 1266              		.thumb
 1267              		.syntax unified
 1268 0084 00BF     		nop
 1269              	.LBE19:
 1270              	.LBE18:
 517:Src/aspep.c   ****     }
 518:Src/aspep.c   ****     else /* HW resource busy, saving packet to sent it once resource will be freed*/
 519:Src/aspep.c   ****     {
 520:Src/aspep.c   ****       __enable_irq(); /*TODO: Enable High frequency task is enough */
 521:Src/aspep.c   ****       /* Lock buffer can be freed here */
 522:Src/aspep.c   ****       if (MCTL_ASYNC == dataType)
 1271              		.loc 1 522 10
 1272 0086 FB7A     		ldrb	r3, [r7, #11]	@ zero_extendqisi2
 1273 0088 092B     		cmp	r3, #9
 1274 008a 18D1     		bne	.L36
 523:Src/aspep.c   ****       {
 524:Src/aspep.c   ****         /* Check that the buffer received is the one expected - probably useless */
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s 			page 37


 525:Src/aspep.c   ****         if (txBuffer != (uint8_t *)pHandle->lastRequestedAsyncBuff->buffer)
 1275              		.loc 1 525 43
 1276 008c FB68     		ldr	r3, [r7, #12]
 1277 008e 1B6C     		ldr	r3, [r3, #64]
 1278              		.loc 1 525 67
 1279 0090 1B68     		ldr	r3, [r3]
 1280              		.loc 1 525 12
 1281 0092 7A68     		ldr	r2, [r7, #4]
 1282 0094 9A42     		cmp	r2, r3
 1283 0096 01D0     		beq	.L37
 526:Src/aspep.c   ****         {
 527:Src/aspep.c   ****           result = ASPEP_BUFFER_ERROR;
 1284              		.loc 1 527 18
 1285 0098 0323     		movs	r3, #3
 1286 009a FB75     		strb	r3, [r7, #23]
 1287              	.L37:
 528:Src/aspep.c   ****         }
 529:Src/aspep.c   ****         else
 530:Src/aspep.c   ****         {
 531:Src/aspep.c   ****           /* Nothing to do */
 532:Src/aspep.c   ****         }
 533:Src/aspep.c   ****         if (NULL == pHandle->asyncNextBuffer)
 1288              		.loc 1 533 28
 1289 009c FB68     		ldr	r3, [r7, #12]
 1290 009e 5B6C     		ldr	r3, [r3, #68]
 1291              		.loc 1 533 12
 1292 00a0 002B     		cmp	r3, #0
 1293 00a2 03D1     		bne	.L38
 534:Src/aspep.c   ****         {
 535:Src/aspep.c   ****           /* Required to keep the right sending order */
 536:Src/aspep.c   ****           pHandle->asyncNextBuffer = pHandle->lastRequestedAsyncBuff;
 1294              		.loc 1 536 45
 1295 00a4 FB68     		ldr	r3, [r7, #12]
 1296 00a6 1A6C     		ldr	r2, [r3, #64]
 1297              		.loc 1 536 36
 1298 00a8 FB68     		ldr	r3, [r7, #12]
 1299 00aa 5A64     		str	r2, [r3, #68]
 1300              	.L38:
 537:Src/aspep.c   ****         }
 538:Src/aspep.c   ****         else
 539:Src/aspep.c   ****         {
 540:Src/aspep.c   ****           /* Nothing to do */
 541:Src/aspep.c   ****         }
 542:Src/aspep.c   ****         pHandle->lastRequestedAsyncBuff->state = pending;
 1301              		.loc 1 542 16
 1302 00ac FB68     		ldr	r3, [r7, #12]
 1303 00ae 1B6C     		ldr	r3, [r3, #64]
 1304              		.loc 1 542 48
 1305 00b0 0222     		movs	r2, #2
 1306 00b2 9A71     		strb	r2, [r3, #6]
 543:Src/aspep.c   ****         pHandle->lastRequestedAsyncBuff->length = bufferLength;
 1307              		.loc 1 543 16
 1308 00b4 FB68     		ldr	r3, [r7, #12]
 1309 00b6 1B6C     		ldr	r3, [r3, #64]
 1310              		.loc 1 543 49
 1311 00b8 3A89     		ldrh	r2, [r7, #8]	@ movhi
 1312 00ba 9A80     		strh	r2, [r3, #4]	@ movhi
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s 			page 38


 1313 00bc 21E0     		b	.L35
 1314              	.L36:
 544:Src/aspep.c   **** #ifdef MCP_DEBUG_METRICS
 545:Src/aspep.c   ****         pHandle->lastRequestedAsyncBuff->PendingNumber++;
 546:Src/aspep.c   **** #endif
 547:Src/aspep.c   ****       }
 548:Src/aspep.c   ****       else if (MCTL_SYNC == dataType)
 1315              		.loc 1 548 15
 1316 00be FB7A     		ldrb	r3, [r7, #11]	@ zero_extendqisi2
 1317 00c0 0A2B     		cmp	r3, #10
 1318 00c2 0FD1     		bne	.L39
 549:Src/aspep.c   ****       {
 550:Src/aspep.c   ****         if (pHandle -> syncBuffer.state != writeLock)
 1319              		.loc 1 550 34
 1320 00c4 FB68     		ldr	r3, [r7, #12]
 1321 00c6 93F82E30 		ldrb	r3, [r3, #46]	@ zero_extendqisi2
 1322              		.loc 1 550 12
 1323 00ca 012B     		cmp	r3, #1
 1324 00cc 02D0     		beq	.L40
 551:Src/aspep.c   ****         {
 552:Src/aspep.c   ****           result = ASPEP_BUFFER_ERROR;
 1325              		.loc 1 552 18
 1326 00ce 0323     		movs	r3, #3
 1327 00d0 FB75     		strb	r3, [r7, #23]
 1328 00d2 16E0     		b	.L35
 1329              	.L40:
 553:Src/aspep.c   ****         }
 554:Src/aspep.c   ****         else
 555:Src/aspep.c   ****         {
 556:Src/aspep.c   ****           pHandle->syncBuffer.state = pending;
 1330              		.loc 1 556 37
 1331 00d4 FB68     		ldr	r3, [r7, #12]
 1332 00d6 0222     		movs	r2, #2
 1333 00d8 83F82E20 		strb	r2, [r3, #46]
 557:Src/aspep.c   ****           pHandle->syncBuffer.length = bufferLength;
 1334              		.loc 1 557 38
 1335 00dc FB68     		ldr	r3, [r7, #12]
 1336 00de 3A89     		ldrh	r2, [r7, #8]	@ movhi
 1337 00e0 9A85     		strh	r2, [r3, #44]	@ movhi
 1338 00e2 0EE0     		b	.L35
 1339              	.L39:
 558:Src/aspep.c   ****         }
 559:Src/aspep.c   ****       }
 560:Src/aspep.c   ****       else if(ASPEP_CTRL == dataType)
 1340              		.loc 1 560 14
 1341 00e4 FB7A     		ldrb	r3, [r7, #11]	@ zero_extendqisi2
 1342 00e6 002B     		cmp	r3, #0
 1343 00e8 0BD1     		bne	.L35
 561:Src/aspep.c   ****       {
 562:Src/aspep.c   ****         if (pHandle->ctrlBuffer.state != available)
 1344              		.loc 1 562 32
 1345 00ea FB68     		ldr	r3, [r7, #12]
 1346 00ec 93F82430 		ldrb	r3, [r3, #36]	@ zero_extendqisi2
 1347              		.loc 1 562 12
 1348 00f0 002B     		cmp	r3, #0
 1349 00f2 02D0     		beq	.L41
 563:Src/aspep.c   ****         {
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s 			page 39


 564:Src/aspep.c   ****           result = ASPEP_BUFFER_ERROR;
 1350              		.loc 1 564 18
 1351 00f4 0323     		movs	r3, #3
 1352 00f6 FB75     		strb	r3, [r7, #23]
 1353 00f8 03E0     		b	.L35
 1354              	.L41:
 565:Src/aspep.c   ****         }
 566:Src/aspep.c   ****         else
 567:Src/aspep.c   ****         {
 568:Src/aspep.c   ****           pHandle->ctrlBuffer.state = pending;
 1355              		.loc 1 568 37
 1356 00fa FB68     		ldr	r3, [r7, #12]
 1357 00fc 0222     		movs	r2, #2
 1358 00fe 83F82420 		strb	r2, [r3, #36]
 1359              	.L35:
 569:Src/aspep.c   ****         }
 570:Src/aspep.c   ****       }
 571:Src/aspep.c   ****       else
 572:Src/aspep.c   ****       {
 573:Src/aspep.c   ****         /* Nothing to do */
 574:Src/aspep.c   ****       }
 575:Src/aspep.c   ****     }
 576:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
 577:Src/aspep.c   ****   }
 578:Src/aspep.c   **** #endif
 579:Src/aspep.c   ****   return (result);
 1360              		.loc 1 579 10
 1361 0102 FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
 580:Src/aspep.c   **** }
 1362              		.loc 1 580 1
 1363 0104 1846     		mov	r0, r3
 1364 0106 1837     		adds	r7, r7, #24
 1365              	.LCFI52:
 1366              		.cfi_def_cfa_offset 8
 1367 0108 BD46     		mov	sp, r7
 1368              	.LCFI53:
 1369              		.cfi_def_cfa_register 13
 1370              		@ sp needed
 1371 010a 80BD     		pop	{r7, pc}
 1372              		.cfi_endproc
 1373              	.LFE1099:
 1375              		.section	.text.ASPEP_HWDataTransmittedIT,"ax",%progbits
 1376              		.align	1
 1377              		.global	ASPEP_HWDataTransmittedIT
 1378              		.syntax unified
 1379              		.thumb
 1380              		.thumb_func
 1382              	ASPEP_HWDataTransmittedIT:
 1383              	.LFB1100:
 581:Src/aspep.c   **** 
 582:Src/aspep.c   **** /**
 583:Src/aspep.c   ****   * @brief  Frees previously locked buffer and/or locks the next pending buffer. Once locked, sends
 584:Src/aspep.c   ****   *
 585:Src/aspep.c   ****   * Called as soon as previous packet transfer is completed, pHandle->lockBuffer is set before pack
 586:Src/aspep.c   ****   * Therefore, there is no need to protect this ISR against another higher priority ISR (HF Task).
 587:Src/aspep.c   ****   *
 588:Src/aspep.c   ****   * @param  *pHandle Handler of the current instance of the ASPEP component
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s 			page 40


 589:Src/aspep.c   ****   */
 590:Src/aspep.c   **** void ASPEP_HWDataTransmittedIT(ASPEP_Handle_t *pHandle)
 591:Src/aspep.c   **** {
 1384              		.loc 1 591 1
 1385              		.cfi_startproc
 1386              		@ args = 0, pretend = 0, frame = 16
 1387              		@ frame_needed = 1, uses_anonymous_args = 0
 1388 0000 80B5     		push	{r7, lr}
 1389              	.LCFI54:
 1390              		.cfi_def_cfa_offset 8
 1391              		.cfi_offset 7, -8
 1392              		.cfi_offset 14, -4
 1393 0002 84B0     		sub	sp, sp, #16
 1394              	.LCFI55:
 1395              		.cfi_def_cfa_offset 24
 1396 0004 00AF     		add	r7, sp, #0
 1397              	.LCFI56:
 1398              		.cfi_def_cfa_register 7
 1399 0006 7860     		str	r0, [r7, #4]
 592:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
 593:Src/aspep.c   ****   if (NULL == pHandle)
 594:Src/aspep.c   ****   {
 595:Src/aspep.c   ****     /* Nothing to do */
 596:Src/aspep.c   ****   }
 597:Src/aspep.c   ****   else
 598:Src/aspep.c   ****   {
 599:Src/aspep.c   **** #endif
 600:Src/aspep.c   ****     /* First free previous readLock buffer */
 601:Src/aspep.c   ****     if (pHandle->ctrlBuffer.state == readLock)
 1400              		.loc 1 601 28
 1401 0008 7B68     		ldr	r3, [r7, #4]
 1402 000a 93F82430 		ldrb	r3, [r3, #36]	@ zero_extendqisi2
 1403              		.loc 1 601 8
 1404 000e 032B     		cmp	r3, #3
 1405 0010 04D1     		bne	.L44
 602:Src/aspep.c   ****     {
 603:Src/aspep.c   ****       pHandle->ctrlBuffer.state = available;
 1406              		.loc 1 603 33
 1407 0012 7B68     		ldr	r3, [r7, #4]
 1408 0014 0022     		movs	r2, #0
 1409 0016 83F82420 		strb	r2, [r3, #36]
 1410 001a 05E0     		b	.L45
 1411              	.L44:
 1412              	.LBB20:
 604:Src/aspep.c   ****     }
 605:Src/aspep.c   ****     else /* if previous buffer was not ASPEP_CTRL, then the buffer locked is a MCTL_Buff_t */
 606:Src/aspep.c   ****     {
 607:Src/aspep.c   ****       MCTL_Buff_t *tempBuff = (MCTL_Buff_t *)pHandle->lockBuffer; //cstat !MISRAC2012-Rule-11.5
 1413              		.loc 1 607 20
 1414 001c 7B68     		ldr	r3, [r7, #4]
 1415 001e 9B6C     		ldr	r3, [r3, #72]
 1416 0020 FB60     		str	r3, [r7, #12]
 608:Src/aspep.c   ****       tempBuff->state = available;
 1417              		.loc 1 608 23
 1418 0022 FB68     		ldr	r3, [r7, #12]
 1419 0024 0022     		movs	r2, #0
 1420 0026 9A71     		strb	r2, [r3, #6]
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s 			page 41


 1421              	.L45:
 1422              	.LBE20:
 609:Src/aspep.c   ****     }
 610:Src/aspep.c   ****     if (pHandle->syncBuffer.state == pending)
 1423              		.loc 1 610 28
 1424 0028 7B68     		ldr	r3, [r7, #4]
 1425 002a 93F82E30 		ldrb	r3, [r3, #46]	@ zero_extendqisi2
 1426              		.loc 1 610 8
 1427 002e 022B     		cmp	r3, #2
 1428 0030 12D1     		bne	.L46
 611:Src/aspep.c   ****     {
 612:Src/aspep.c   ****       pHandle->lockBuffer = (void *)&pHandle->syncBuffer;
 1429              		.loc 1 612 37
 1430 0032 7B68     		ldr	r3, [r7, #4]
 1431 0034 03F12802 		add	r2, r3, #40
 1432              		.loc 1 612 27
 1433 0038 7B68     		ldr	r3, [r7, #4]
 1434 003a 9A64     		str	r2, [r3, #72]
 613:Src/aspep.c   ****       pHandle->fASPEP_send(pHandle->HWIp, pHandle->syncBuffer.buffer, pHandle->syncBuffer.length);
 1435              		.loc 1 613 14
 1436 003c 7B68     		ldr	r3, [r7, #4]
 1437 003e 9B6D     		ldr	r3, [r3, #88]
 1438              		.loc 1 613 7
 1439 0040 7A68     		ldr	r2, [r7, #4]
 1440 0042 5069     		ldr	r0, [r2, #20]
 1441              		.loc 1 613 62
 1442 0044 7A68     		ldr	r2, [r7, #4]
 1443 0046 916A     		ldr	r1, [r2, #40]
 1444              		.loc 1 613 7
 1445 0048 7A68     		ldr	r2, [r7, #4]
 1446 004a 928D     		ldrh	r2, [r2, #44]
 1447 004c 9847     		blx	r3
 1448              	.LVL3:
 614:Src/aspep.c   ****       pHandle->syncBuffer.state = readLock;
 1449              		.loc 1 614 33
 1450 004e 7B68     		ldr	r3, [r7, #4]
 1451 0050 0322     		movs	r2, #3
 1452 0052 83F82E20 		strb	r2, [r3, #46]
 615:Src/aspep.c   ****     }
 616:Src/aspep.c   ****     /* Second prepare transfer of pending buffer */
 617:Src/aspep.c   ****     else if (pHandle->ctrlBuffer.state == pending)
 618:Src/aspep.c   ****     {
 619:Src/aspep.c   ****       pHandle->lockBuffer = (void *)(&pHandle ->ctrlBuffer);
 620:Src/aspep.c   ****       pHandle->fASPEP_send(pHandle ->HWIp, pHandle->ctrlBuffer.buffer, ASPEP_CTRL_SIZE);
 621:Src/aspep.c   ****       pHandle->ctrlBuffer.state = readLock;
 622:Src/aspep.c   ****     }
 623:Src/aspep.c   ****     else
 624:Src/aspep.c   ****     {
 625:Src/aspep.c   ****       __disable_irq();
 626:Src/aspep.c   ****       if (pHandle->asyncNextBuffer != NULL)
 627:Src/aspep.c   ****       {
 628:Src/aspep.c   ****         pHandle->lockBuffer = (void *)pHandle->asyncNextBuffer;
 629:Src/aspep.c   ****         pHandle->asyncNextBuffer->state = readLock;
 630:Src/aspep.c   **** #ifdef MCP_DEBUG_METRICS
 631:Src/aspep.c   ****         pHandle->asyncNextBuffer->SentNumber++;
 632:Src/aspep.c   **** #endif
 633:Src/aspep.c   ****         pHandle->fASPEP_send(pHandle ->HWIp, pHandle->asyncNextBuffer->buffer, pHandle->asyncNextBu
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s 			page 42


 634:Src/aspep.c   ****         /* If one Async buffer is still pending, assign it to the asyncNextBuffer pointer*/
 635:Src/aspep.c   ****         if ((pHandle->asyncBufferA.state == pending) || (pHandle->asyncBufferB.state == pending))
 636:Src/aspep.c   ****         {
 637:Src/aspep.c   ****           //cstat !MISRAC2012-Rule-11.4
 638:Src/aspep.c   ****           uint32_t temp = (uint32_t)&pHandle->asyncBufferA + (uint32_t)&pHandle->asyncBufferB
 639:Src/aspep.c   ****                           - (uint32_t) pHandle->asyncNextBuffer; //cstat !MISRAC2012-Rule-11.4
 640:Src/aspep.c   ****           pHandle->asyncNextBuffer = (MCTL_Buff_t *) temp; //cstat !MISRAC2012-Rule-11.4
 641:Src/aspep.c   ****         }
 642:Src/aspep.c   ****         else
 643:Src/aspep.c   ****         {
 644:Src/aspep.c   ****           pHandle->asyncNextBuffer = NULL;
 645:Src/aspep.c   ****         }
 646:Src/aspep.c   ****       }
 647:Src/aspep.c   ****       else /* No TX packet are pending, HW resource is free*/
 648:Src/aspep.c   ****       {
 649:Src/aspep.c   ****         pHandle->lockBuffer = NULL;
 650:Src/aspep.c   ****       }
 651:Src/aspep.c   ****       __enable_irq();
 652:Src/aspep.c   ****     }
 653:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
 654:Src/aspep.c   ****   }
 655:Src/aspep.c   **** #endif
 656:Src/aspep.c   **** }
 1453              		.loc 1 656 1
 1454 0056 51E0     		b	.L54
 1455              	.L46:
 617:Src/aspep.c   ****     {
 1456              		.loc 1 617 33
 1457 0058 7B68     		ldr	r3, [r7, #4]
 1458 005a 93F82430 		ldrb	r3, [r3, #36]	@ zero_extendqisi2
 617:Src/aspep.c   ****     {
 1459              		.loc 1 617 13
 1460 005e 022B     		cmp	r3, #2
 1461 0060 12D1     		bne	.L48
 619:Src/aspep.c   ****       pHandle->fASPEP_send(pHandle ->HWIp, pHandle->ctrlBuffer.buffer, ASPEP_CTRL_SIZE);
 1462              		.loc 1 619 38
 1463 0062 7B68     		ldr	r3, [r7, #4]
 1464 0064 03F12002 		add	r2, r3, #32
 619:Src/aspep.c   ****       pHandle->fASPEP_send(pHandle ->HWIp, pHandle->ctrlBuffer.buffer, ASPEP_CTRL_SIZE);
 1465              		.loc 1 619 27
 1466 0068 7B68     		ldr	r3, [r7, #4]
 1467 006a 9A64     		str	r2, [r3, #72]
 620:Src/aspep.c   ****       pHandle->ctrlBuffer.state = readLock;
 1468              		.loc 1 620 14
 1469 006c 7B68     		ldr	r3, [r7, #4]
 1470 006e 9B6D     		ldr	r3, [r3, #88]
 620:Src/aspep.c   ****       pHandle->ctrlBuffer.state = readLock;
 1471              		.loc 1 620 7
 1472 0070 7A68     		ldr	r2, [r7, #4]
 1473 0072 5069     		ldr	r0, [r2, #20]
 620:Src/aspep.c   ****       pHandle->ctrlBuffer.state = readLock;
 1474              		.loc 1 620 63
 1475 0074 7A68     		ldr	r2, [r7, #4]
 1476 0076 02F12001 		add	r1, r2, #32
 620:Src/aspep.c   ****       pHandle->ctrlBuffer.state = readLock;
 1477              		.loc 1 620 7
 1478 007a 0422     		movs	r2, #4
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s 			page 43


 1479 007c 9847     		blx	r3
 1480              	.LVL4:
 621:Src/aspep.c   ****     }
 1481              		.loc 1 621 33
 1482 007e 7B68     		ldr	r3, [r7, #4]
 1483 0080 0322     		movs	r2, #3
 1484 0082 83F82420 		strb	r2, [r3, #36]
 1485              		.loc 1 656 1
 1486 0086 39E0     		b	.L54
 1487              	.L48:
 1488              	.LBB21:
 1489              	.LBB22:
 209:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 1490              		.loc 2 209 3
 1491              		.syntax unified
 1492              	@ 209 "Drivers/CMSIS/Include/cmsis_gcc.h" 1
 1493 0088 72B6     		cpsid i
 1494              	@ 0 "" 2
 1495              		.loc 2 210 1
 1496              		.thumb
 1497              		.syntax unified
 1498 008a 00BF     		nop
 1499              	.LBE22:
 1500              	.LBE21:
 626:Src/aspep.c   ****       {
 1501              		.loc 1 626 18
 1502 008c 7B68     		ldr	r3, [r7, #4]
 1503 008e 5B6C     		ldr	r3, [r3, #68]
 626:Src/aspep.c   ****       {
 1504              		.loc 1 626 10
 1505 0090 002B     		cmp	r3, #0
 1506 0092 2ED0     		beq	.L49
 628:Src/aspep.c   ****         pHandle->asyncNextBuffer->state = readLock;
 1507              		.loc 1 628 46
 1508 0094 7B68     		ldr	r3, [r7, #4]
 1509 0096 5A6C     		ldr	r2, [r3, #68]
 628:Src/aspep.c   ****         pHandle->asyncNextBuffer->state = readLock;
 1510              		.loc 1 628 29
 1511 0098 7B68     		ldr	r3, [r7, #4]
 1512 009a 9A64     		str	r2, [r3, #72]
 629:Src/aspep.c   **** #ifdef MCP_DEBUG_METRICS
 1513              		.loc 1 629 16
 1514 009c 7B68     		ldr	r3, [r7, #4]
 1515 009e 5B6C     		ldr	r3, [r3, #68]
 629:Src/aspep.c   **** #ifdef MCP_DEBUG_METRICS
 1516              		.loc 1 629 41
 1517 00a0 0322     		movs	r2, #3
 1518 00a2 9A71     		strb	r2, [r3, #6]
 633:Src/aspep.c   ****         /* If one Async buffer is still pending, assign it to the asyncNextBuffer pointer*/
 1519              		.loc 1 633 16
 1520 00a4 7B68     		ldr	r3, [r7, #4]
 1521 00a6 9B6D     		ldr	r3, [r3, #88]
 633:Src/aspep.c   ****         /* If one Async buffer is still pending, assign it to the asyncNextBuffer pointer*/
 1522              		.loc 1 633 9
 1523 00a8 7A68     		ldr	r2, [r7, #4]
 1524 00aa 5069     		ldr	r0, [r2, #20]
 633:Src/aspep.c   ****         /* If one Async buffer is still pending, assign it to the asyncNextBuffer pointer*/
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s 			page 44


 1525              		.loc 1 633 53
 1526 00ac 7A68     		ldr	r2, [r7, #4]
 1527 00ae 526C     		ldr	r2, [r2, #68]
 633:Src/aspep.c   ****         /* If one Async buffer is still pending, assign it to the asyncNextBuffer pointer*/
 1528              		.loc 1 633 70
 1529 00b0 1168     		ldr	r1, [r2]
 633:Src/aspep.c   ****         /* If one Async buffer is still pending, assign it to the asyncNextBuffer pointer*/
 1530              		.loc 1 633 87
 1531 00b2 7A68     		ldr	r2, [r7, #4]
 1532 00b4 526C     		ldr	r2, [r2, #68]
 633:Src/aspep.c   ****         /* If one Async buffer is still pending, assign it to the asyncNextBuffer pointer*/
 1533              		.loc 1 633 9
 1534 00b6 9288     		ldrh	r2, [r2, #4]
 1535 00b8 9847     		blx	r3
 1536              	.LVL5:
 635:Src/aspep.c   ****         {
 1537              		.loc 1 635 35
 1538 00ba 7B68     		ldr	r3, [r7, #4]
 1539 00bc 93F83630 		ldrb	r3, [r3, #54]	@ zero_extendqisi2
 635:Src/aspep.c   ****         {
 1540              		.loc 1 635 12
 1541 00c0 022B     		cmp	r3, #2
 1542 00c2 04D0     		beq	.L50
 635:Src/aspep.c   ****         {
 1543              		.loc 1 635 79 discriminator 1
 1544 00c4 7B68     		ldr	r3, [r7, #4]
 1545 00c6 93F83E30 		ldrb	r3, [r3, #62]	@ zero_extendqisi2
 635:Src/aspep.c   ****         {
 1546              		.loc 1 635 54 discriminator 1
 1547 00ca 022B     		cmp	r3, #2
 1548 00cc 0DD1     		bne	.L51
 1549              	.L50:
 1550              	.LBB23:
 638:Src/aspep.c   ****                           - (uint32_t) pHandle->asyncNextBuffer; //cstat !MISRAC2012-Rule-11.4
 1551              		.loc 1 638 37
 1552 00ce 7B68     		ldr	r3, [r7, #4]
 1553 00d0 3033     		adds	r3, r3, #48
 638:Src/aspep.c   ****                           - (uint32_t) pHandle->asyncNextBuffer; //cstat !MISRAC2012-Rule-11.4
 1554              		.loc 1 638 27
 1555 00d2 1A46     		mov	r2, r3
 638:Src/aspep.c   ****                           - (uint32_t) pHandle->asyncNextBuffer; //cstat !MISRAC2012-Rule-11.4
 1556              		.loc 1 638 72
 1557 00d4 7B68     		ldr	r3, [r7, #4]
 1558 00d6 3833     		adds	r3, r3, #56
 638:Src/aspep.c   ****                           - (uint32_t) pHandle->asyncNextBuffer; //cstat !MISRAC2012-Rule-11.4
 1559              		.loc 1 638 60
 1560 00d8 1344     		add	r3, r3, r2
 639:Src/aspep.c   ****           pHandle->asyncNextBuffer = (MCTL_Buff_t *) temp; //cstat !MISRAC2012-Rule-11.4
 1561              		.loc 1 639 47
 1562 00da 7A68     		ldr	r2, [r7, #4]
 1563 00dc 526C     		ldr	r2, [r2, #68]
 638:Src/aspep.c   ****                           - (uint32_t) pHandle->asyncNextBuffer; //cstat !MISRAC2012-Rule-11.4
 1564              		.loc 1 638 20
 1565 00de 9B1A     		subs	r3, r3, r2
 1566 00e0 BB60     		str	r3, [r7, #8]
 640:Src/aspep.c   ****         }
 1567              		.loc 1 640 38
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s 			page 45


 1568 00e2 BA68     		ldr	r2, [r7, #8]
 640:Src/aspep.c   ****         }
 1569              		.loc 1 640 36
 1570 00e4 7B68     		ldr	r3, [r7, #4]
 1571 00e6 5A64     		str	r2, [r3, #68]
 1572              	.LBE23:
 636:Src/aspep.c   ****           //cstat !MISRAC2012-Rule-11.4
 1573              		.loc 1 636 9
 1574 00e8 06E0     		b	.L53
 1575              	.L51:
 644:Src/aspep.c   ****         }
 1576              		.loc 1 644 36
 1577 00ea 7B68     		ldr	r3, [r7, #4]
 1578 00ec 0022     		movs	r2, #0
 1579 00ee 5A64     		str	r2, [r3, #68]
 1580 00f0 02E0     		b	.L53
 1581              	.L49:
 649:Src/aspep.c   ****       }
 1582              		.loc 1 649 29
 1583 00f2 7B68     		ldr	r3, [r7, #4]
 1584 00f4 0022     		movs	r2, #0
 1585 00f6 9A64     		str	r2, [r3, #72]
 1586              	.L53:
 1587              	.LBB24:
 1588              	.LBB25:
 198:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 1589              		.loc 2 198 3
 1590              		.syntax unified
 1591              	@ 198 "Drivers/CMSIS/Include/cmsis_gcc.h" 1
 1592 00f8 62B6     		cpsie i
 1593              	@ 0 "" 2
 199:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 1594              		.loc 2 199 1
 1595              		.thumb
 1596              		.syntax unified
 1597 00fa 00BF     		nop
 1598              	.L54:
 1599              	.LBE25:
 1600              	.LBE24:
 1601              		.loc 1 656 1
 1602 00fc 00BF     		nop
 1603 00fe 1037     		adds	r7, r7, #16
 1604              	.LCFI57:
 1605              		.cfi_def_cfa_offset 8
 1606 0100 BD46     		mov	sp, r7
 1607              	.LCFI58:
 1608              		.cfi_def_cfa_register 13
 1609              		@ sp needed
 1610 0102 80BD     		pop	{r7, pc}
 1611              		.cfi_endproc
 1612              	.LFE1100:
 1614              		.section	.text.ASPEP_RXframeProcess,"ax",%progbits
 1615              		.align	1
 1616              		.global	ASPEP_RXframeProcess
 1617              		.syntax unified
 1618              		.thumb
 1619              		.thumb_func
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s 			page 46


 1621              	ASPEP_RXframeProcess:
 1622              	.LFB1101:
 657:Src/aspep.c   **** 
 658:Src/aspep.c   **** /**
 659:Src/aspep.c   ****   * @brief  Updates ASPEP state depending on received packet from Controller and sends a response a
 660:Src/aspep.c   ****   *
 661:Src/aspep.c   ****   * ASPEP protocol defined in section 4.4.1 Connection Procedure of Motor Control Protocol Suite of
 662:Src/aspep.c   ****   *
 663:Src/aspep.c   ****   * @param  *pSupHandle Handler of the current instance of the MCTL component
 664:Src/aspep.c   ****   * @param  *packetLength Length of the packet to be processed
 665:Src/aspep.c   ****   *
 666:Src/aspep.c   ****   * @return Returns the buffer of data transmitted by the MCP controller device
 667:Src/aspep.c   ****   */
 668:Src/aspep.c   **** uint8_t *ASPEP_RXframeProcess(MCTL_Handle_t *pSupHandle, uint16_t *packetLength)
 669:Src/aspep.c   **** {
 1623              		.loc 1 669 1
 1624              		.cfi_startproc
 1625              		@ args = 0, pretend = 0, frame = 24
 1626              		@ frame_needed = 1, uses_anonymous_args = 0
 1627 0000 80B5     		push	{r7, lr}
 1628              	.LCFI59:
 1629              		.cfi_def_cfa_offset 8
 1630              		.cfi_offset 7, -8
 1631              		.cfi_offset 14, -4
 1632 0002 86B0     		sub	sp, sp, #24
 1633              	.LCFI60:
 1634              		.cfi_def_cfa_offset 32
 1635 0004 00AF     		add	r7, sp, #0
 1636              	.LCFI61:
 1637              		.cfi_def_cfa_register 7
 1638 0006 7860     		str	r0, [r7, #4]
 1639 0008 3960     		str	r1, [r7]
 670:Src/aspep.c   ****   uint8_t *result = NULL; //cstat !MISRAC2012-Rule-8.13
 1640              		.loc 1 670 12
 1641 000a 0023     		movs	r3, #0
 1642 000c 7B61     		str	r3, [r7, #20]
 671:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
 672:Src/aspep.c   ****   if ((NULL == pSupHandle) || (NULL == packetLength))
 673:Src/aspep.c   ****   {
 674:Src/aspep.c   ****     /* Nothing to do */
 675:Src/aspep.c   ****   }
 676:Src/aspep.c   ****   else
 677:Src/aspep.c   ****   {
 678:Src/aspep.c   **** #endif
 679:Src/aspep.c   ****     ASPEP_Handle_t *pHandle = (ASPEP_Handle_t *)pSupHandle; //cstat !MISRAC2012-Rule-11.3
 1643              		.loc 1 679 21
 1644 000e 7B68     		ldr	r3, [r7, #4]
 1645 0010 3B61     		str	r3, [r7, #16]
 680:Src/aspep.c   ****     uint32_t packetHeader = *((uint32_t *)pHandle->rxHeader); //cstat !MISRAC2012-Rule-11.3
 1646              		.loc 1 680 43
 1647 0012 3B69     		ldr	r3, [r7, #16]
 1648 0014 1C33     		adds	r3, r3, #28
 1649              		.loc 1 680 14
 1650 0016 1B68     		ldr	r3, [r3]
 1651 0018 FB60     		str	r3, [r7, #12]
 681:Src/aspep.c   ****     uint16_t packetNumber;
 682:Src/aspep.c   **** #if VALID_CRC_DATA
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s 			page 47


 683:Src/aspep.c   ****     bool validCRCData = true;
 684:Src/aspep.c   **** #endif
 685:Src/aspep.c   ****     *packetLength = 0;
 1652              		.loc 1 685 19
 1653 001a 3B68     		ldr	r3, [r7]
 1654 001c 0022     		movs	r2, #0
 1655 001e 1A80     		strh	r2, [r3]	@ movhi
 686:Src/aspep.c   ****     if (pHandle->NewPacketAvailable)
 1656              		.loc 1 686 16
 1657 0020 3B69     		ldr	r3, [r7, #16]
 1658 0022 93F86130 		ldrb	r3, [r3, #97]	@ zero_extendqisi2
 1659              		.loc 1 686 8
 1660 0026 002B     		cmp	r3, #0
 1661 0028 00F0CD80 		beq	.L56
 687:Src/aspep.c   ****     {
 688:Src/aspep.c   ****       pHandle->NewPacketAvailable = false; /* Consumes new packet*/
 1662              		.loc 1 688 35
 1663 002c 3B69     		ldr	r3, [r7, #16]
 1664 002e 0022     		movs	r2, #0
 1665 0030 83F86120 		strb	r2, [r3, #97]
 689:Src/aspep.c   ****       switch (pHandle->ASPEP_State)
 1666              		.loc 1 689 22
 1667 0034 3B69     		ldr	r3, [r7, #16]
 1668 0036 93F86430 		ldrb	r3, [r3, #100]	@ zero_extendqisi2
 1669              		.loc 1 689 7
 1670 003a 022B     		cmp	r3, #2
 1671 003c 6FD0     		beq	.L57
 1672 003e 022B     		cmp	r3, #2
 1673 0040 00F3B080 		bgt	.L75
 1674 0044 002B     		cmp	r3, #0
 1675 0046 02D0     		beq	.L59
 1676 0048 012B     		cmp	r3, #1
 1677 004a 3ED0     		beq	.L60
 690:Src/aspep.c   ****       {
 691:Src/aspep.c   ****         case ASPEP_IDLE:
 692:Src/aspep.c   ****         {
 693:Src/aspep.c   ****           if (BEACON == pHandle->rxPacketType)
 694:Src/aspep.c   ****           {
 695:Src/aspep.c   ****             if (ASPEP_CheckBeacon(pHandle) == true)
 696:Src/aspep.c   ****             {
 697:Src/aspep.c   ****               /* Controller capabilities match performer capabilities.*/
 698:Src/aspep.c   ****               pSupHandle->txSyncMaxPayload = (pHandle->Capabilities.TXS_maxSize + (uint16_t)1U) * (
 699:Src/aspep.c   ****               pSupHandle->txAsyncMaxPayload = (pHandle->Capabilities.TXA_maxSize) * (uint16_t)64U;
 700:Src/aspep.c   ****               pHandle->maxRXPayload = (pHandle->Capabilities.RX_maxSize + (uint16_t)1U) * (uint16_t
 701:Src/aspep.c   ****               pHandle->ASPEP_State = ASPEP_CONFIGURED;
 702:Src/aspep.c   ****             }
 703:Src/aspep.c   ****             else
 704:Src/aspep.c   ****             {
 705:Src/aspep.c   ****               /* Nothing to do, controller has to send back new beacon with matching capabilities *
 706:Src/aspep.c   ****             }
 707:Src/aspep.c   ****             /* Beacon Packet must be answered*/
 708:Src/aspep.c   ****             ASPEP_sendBeacon(pHandle, &pHandle->Capabilities);
 709:Src/aspep.c   ****           }
 710:Src/aspep.c   ****           else if (PING == pHandle->rxPacketType)
 711:Src/aspep.c   ****           {
 712:Src/aspep.c   ****             /* In Listening for controller performer, */
 713:Src/aspep.c   ****             packetNumber = (uint16_t)((packetHeader & 0x0FFFF000U) >> (uint16_t)12U);
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s 			page 48


 714:Src/aspep.c   ****             ASPEP_sendPing(pHandle, ASPEP_PING_RESET, packetNumber);
 715:Src/aspep.c   ****           }
 716:Src/aspep.c   ****           else
 717:Src/aspep.c   ****           {
 718:Src/aspep.c   ****             /* Nothing to do */
 719:Src/aspep.c   ****           }
 720:Src/aspep.c   ****           break;
 721:Src/aspep.c   ****         }
 722:Src/aspep.c   **** 
 723:Src/aspep.c   ****         case ASPEP_CONFIGURED:
 724:Src/aspep.c   ****         {
 725:Src/aspep.c   ****           if (BEACON == pHandle->rxPacketType)
 726:Src/aspep.c   ****           {
 727:Src/aspep.c   ****             if (ASPEP_CheckBeacon(pHandle) == false)
 728:Src/aspep.c   ****             {
 729:Src/aspep.c   ****               pHandle->ASPEP_State = ASPEP_IDLE;
 730:Src/aspep.c   ****             }
 731:Src/aspep.c   ****             else
 732:Src/aspep.c   ****             {
 733:Src/aspep.c   ****               /* Nothing to do */
 734:Src/aspep.c   ****             }
 735:Src/aspep.c   **** 
 736:Src/aspep.c   ****             ASPEP_sendBeacon (pHandle, &pHandle->Capabilities);
 737:Src/aspep.c   ****           }
 738:Src/aspep.c   ****           else if (PING == pHandle->rxPacketType)
 739:Src/aspep.c   ****           {
 740:Src/aspep.c   ****             /* In Listening for controller performer, */
 741:Src/aspep.c   ****             packetNumber = (uint16_t)((packetHeader & 0x0FFFF000U) >> (uint16_t)12U);
 742:Src/aspep.c   ****             ASPEP_sendPing(pHandle, ASPEP_PING_CFG, packetNumber);
 743:Src/aspep.c   ****             pHandle->ASPEP_State = ASPEP_CONNECTED;
 744:Src/aspep.c   ****           }
 745:Src/aspep.c   ****           else
 746:Src/aspep.c   ****           {
 747:Src/aspep.c   ****             /* Nothing to do */
 748:Src/aspep.c   ****           }
 749:Src/aspep.c   ****           break;
 750:Src/aspep.c   ****         }
 751:Src/aspep.c   **** 
 752:Src/aspep.c   ****         case ASPEP_CONNECTED:
 753:Src/aspep.c   ****         {
 754:Src/aspep.c   ****           if (BEACON == pHandle->rxPacketType)
 755:Src/aspep.c   ****           {
 756:Src/aspep.c   ****             if (ASPEP_CheckBeacon(pHandle) == false)
 757:Src/aspep.c   ****             {
 758:Src/aspep.c   ****               pHandle->ASPEP_State = ASPEP_IDLE;
 759:Src/aspep.c   ****             }
 760:Src/aspep.c   ****             else
 761:Src/aspep.c   ****             {
 762:Src/aspep.c   ****               pHandle->ASPEP_State = ASPEP_CONFIGURED;
 763:Src/aspep.c   ****             }
 764:Src/aspep.c   ****             ASPEP_sendBeacon(pHandle, &pHandle->Capabilities);
 765:Src/aspep.c   ****           }
 766:Src/aspep.c   ****           else if (PING == pHandle->rxPacketType)
 767:Src/aspep.c   ****           {
 768:Src/aspep.c   ****             packetNumber = pHandle->rxHeader[1];
 769:Src/aspep.c   ****             ASPEP_sendPing(pHandle, ASPEP_PING_CFG, packetNumber);
 770:Src/aspep.c   ****           }
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s 			page 49


 771:Src/aspep.c   ****           else if (DATA_PACKET == pHandle->rxPacketType)
 772:Src/aspep.c   ****           {
 773:Src/aspep.c   **** #if VALID_CRC_DATA
 774:Src/aspep.c   ****             if (validCRCData)
 775:Src/aspep.c   ****             {
 776:Src/aspep.c   **** #endif
 777:Src/aspep.c   ****               pHandle->syncPacketCount++; /* this counter is incremented at each valid data packet 
 778:Src/aspep.c   ****               pSupHandle->MCP_PacketAvailable = true; /* Will be consumed in ASPEP_sendPacket */
 779:Src/aspep.c   ****               *packetLength = pHandle->rxLength;
 780:Src/aspep.c   ****               result = pHandle->rxBuffer;
 781:Src/aspep.c   **** #if VALID_CRC_DATA
 782:Src/aspep.c   ****             }
 783:Src/aspep.c   ****             else
 784:Src/aspep.c   ****             {
 785:Src/aspep.c   ****               ASPEP_sendNack (pHandle, ASPEP_BAD_CRC_DATA);
 786:Src/aspep.c   ****             }
 787:Src/aspep.c   **** #endif
 788:Src/aspep.c   ****           }
 789:Src/aspep.c   ****           else
 790:Src/aspep.c   ****           {
 791:Src/aspep.c   ****             /* This condition is not reachable because already filtred by NewPacketAvailable */
 792:Src/aspep.c   ****             /* ASPEP_sendNack (pHandle, ASPEP_BAD_PACKET_TYPE) */
 793:Src/aspep.c   ****           }
 794:Src/aspep.c   ****           break;
 795:Src/aspep.c   ****         }
 796:Src/aspep.c   **** 
 797:Src/aspep.c   ****         default:
 798:Src/aspep.c   ****           break;
 1678              		.loc 1 798 11
 1679 004c AAE0     		b	.L75
 1680              	.L59:
 693:Src/aspep.c   ****           {
 1681              		.loc 1 693 32
 1682 004e 3B69     		ldr	r3, [r7, #16]
 1683 0050 9B6E     		ldr	r3, [r3, #104]
 693:Src/aspep.c   ****           {
 1684              		.loc 1 693 14
 1685 0052 052B     		cmp	r3, #5
 1686 0054 2BD1     		bne	.L61
 695:Src/aspep.c   ****             {
 1687              		.loc 1 695 17
 1688 0056 3869     		ldr	r0, [r7, #16]
 1689 0058 FFF7FEFF 		bl	ASPEP_CheckBeacon
 1690 005c 0346     		mov	r3, r0
 695:Src/aspep.c   ****             {
 1691              		.loc 1 695 16
 1692 005e 002B     		cmp	r3, #0
 1693 0060 1ED0     		beq	.L62
 698:Src/aspep.c   ****               pSupHandle->txAsyncMaxPayload = (pHandle->Capabilities.TXA_maxSize) * (uint16_t)64U;
 1694              		.loc 1 698 68
 1695 0062 3B69     		ldr	r3, [r7, #16]
 1696 0064 93F86E30 		ldrb	r3, [r3, #110]	@ zero_extendqisi2
 698:Src/aspep.c   ****               pSupHandle->txAsyncMaxPayload = (pHandle->Capabilities.TXA_maxSize) * (uint16_t)64U;
 1697              		.loc 1 698 81
 1698 0068 0133     		adds	r3, r3, #1
 698:Src/aspep.c   ****               pSupHandle->txAsyncMaxPayload = (pHandle->Capabilities.TXA_maxSize) * (uint16_t)64U;
 1699              		.loc 1 698 44
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s 			page 50


 1700 006a 9BB2     		uxth	r3, r3
 1701 006c 5B01     		lsls	r3, r3, #5
 1702 006e 9AB2     		uxth	r2, r3
 1703 0070 7B68     		ldr	r3, [r7, #4]
 1704 0072 9A81     		strh	r2, [r3, #12]	@ movhi
 699:Src/aspep.c   ****               pHandle->maxRXPayload = (pHandle->Capabilities.RX_maxSize + (uint16_t)1U) * (uint16_t
 1705              		.loc 1 699 69
 1706 0074 3B69     		ldr	r3, [r7, #16]
 1707 0076 93F86F30 		ldrb	r3, [r3, #111]	@ zero_extendqisi2
 699:Src/aspep.c   ****               pHandle->maxRXPayload = (pHandle->Capabilities.RX_maxSize + (uint16_t)1U) * (uint16_t
 1708              		.loc 1 699 45
 1709 007a 9BB2     		uxth	r3, r3
 1710 007c 9B01     		lsls	r3, r3, #6
 1711 007e 9AB2     		uxth	r2, r3
 1712 0080 7B68     		ldr	r3, [r7, #4]
 1713 0082 DA81     		strh	r2, [r3, #14]	@ movhi
 700:Src/aspep.c   ****               pHandle->ASPEP_State = ASPEP_CONFIGURED;
 1714              		.loc 1 700 61
 1715 0084 3B69     		ldr	r3, [r7, #16]
 1716 0086 93F86D30 		ldrb	r3, [r3, #109]	@ zero_extendqisi2
 700:Src/aspep.c   ****               pHandle->ASPEP_State = ASPEP_CONFIGURED;
 1717              		.loc 1 700 73
 1718 008a 0133     		adds	r3, r3, #1
 700:Src/aspep.c   ****               pHandle->ASPEP_State = ASPEP_CONFIGURED;
 1719              		.loc 1 700 37
 1720 008c 9BB2     		uxth	r3, r3
 1721 008e 5B01     		lsls	r3, r3, #5
 1722 0090 9AB2     		uxth	r2, r3
 1723 0092 3B69     		ldr	r3, [r7, #16]
 1724 0094 A3F85E20 		strh	r2, [r3, #94]	@ movhi
 701:Src/aspep.c   ****             }
 1725              		.loc 1 701 36
 1726 0098 3B69     		ldr	r3, [r7, #16]
 1727 009a 0122     		movs	r2, #1
 1728 009c 83F86420 		strb	r2, [r3, #100]
 1729              	.L62:
 708:Src/aspep.c   ****           }
 1730              		.loc 1 708 13
 1731 00a0 3B69     		ldr	r3, [r7, #16]
 1732 00a2 6C33     		adds	r3, r3, #108
 1733 00a4 1946     		mov	r1, r3
 1734 00a6 3869     		ldr	r0, [r7, #16]
 1735 00a8 FFF7FEFF 		bl	ASPEP_sendBeacon
 720:Src/aspep.c   ****         }
 1736              		.loc 1 720 11
 1737 00ac 7CE0     		b	.L76
 1738              	.L61:
 710:Src/aspep.c   ****           {
 1739              		.loc 1 710 35
 1740 00ae 3B69     		ldr	r3, [r7, #16]
 1741 00b0 9B6E     		ldr	r3, [r3, #104]
 710:Src/aspep.c   ****           {
 1742              		.loc 1 710 19
 1743 00b2 062B     		cmp	r3, #6
 1744 00b4 78D1     		bne	.L76
 713:Src/aspep.c   ****             ASPEP_sendPing(pHandle, ASPEP_PING_RESET, packetNumber);
 1745              		.loc 1 713 68
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s 			page 51


 1746 00b6 FB68     		ldr	r3, [r7, #12]
 1747 00b8 1B0B     		lsrs	r3, r3, #12
 713:Src/aspep.c   ****             ASPEP_sendPing(pHandle, ASPEP_PING_RESET, packetNumber);
 1748              		.loc 1 713 26
 1749 00ba 7B81     		strh	r3, [r7, #10]	@ movhi
 714:Src/aspep.c   ****           }
 1750              		.loc 1 714 13
 1751 00bc 7B89     		ldrh	r3, [r7, #10]
 1752 00be 1A46     		mov	r2, r3
 1753 00c0 0021     		movs	r1, #0
 1754 00c2 3869     		ldr	r0, [r7, #16]
 1755 00c4 FFF7FEFF 		bl	ASPEP_sendPing
 720:Src/aspep.c   ****         }
 1756              		.loc 1 720 11
 1757 00c8 6EE0     		b	.L76
 1758              	.L60:
 725:Src/aspep.c   ****           {
 1759              		.loc 1 725 32
 1760 00ca 3B69     		ldr	r3, [r7, #16]
 1761 00cc 9B6E     		ldr	r3, [r3, #104]
 725:Src/aspep.c   ****           {
 1762              		.loc 1 725 14
 1763 00ce 052B     		cmp	r3, #5
 1764 00d0 13D1     		bne	.L65
 727:Src/aspep.c   ****             {
 1765              		.loc 1 727 17
 1766 00d2 3869     		ldr	r0, [r7, #16]
 1767 00d4 FFF7FEFF 		bl	ASPEP_CheckBeacon
 1768 00d8 0346     		mov	r3, r0
 727:Src/aspep.c   ****             {
 1769              		.loc 1 727 44
 1770 00da 83F00103 		eor	r3, r3, #1
 1771 00de DBB2     		uxtb	r3, r3
 727:Src/aspep.c   ****             {
 1772              		.loc 1 727 16
 1773 00e0 002B     		cmp	r3, #0
 1774 00e2 03D0     		beq	.L66
 729:Src/aspep.c   ****             }
 1775              		.loc 1 729 36
 1776 00e4 3B69     		ldr	r3, [r7, #16]
 1777 00e6 0022     		movs	r2, #0
 1778 00e8 83F86420 		strb	r2, [r3, #100]
 1779              	.L66:
 736:Src/aspep.c   ****           }
 1780              		.loc 1 736 13
 1781 00ec 3B69     		ldr	r3, [r7, #16]
 1782 00ee 6C33     		adds	r3, r3, #108
 1783 00f0 1946     		mov	r1, r3
 1784 00f2 3869     		ldr	r0, [r7, #16]
 1785 00f4 FFF7FEFF 		bl	ASPEP_sendBeacon
 749:Src/aspep.c   ****         }
 1786              		.loc 1 749 11
 1787 00f8 58E0     		b	.L77
 1788              	.L65:
 738:Src/aspep.c   ****           {
 1789              		.loc 1 738 35
 1790 00fa 3B69     		ldr	r3, [r7, #16]
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s 			page 52


 1791 00fc 9B6E     		ldr	r3, [r3, #104]
 738:Src/aspep.c   ****           {
 1792              		.loc 1 738 19
 1793 00fe 062B     		cmp	r3, #6
 1794 0100 54D1     		bne	.L77
 741:Src/aspep.c   ****             ASPEP_sendPing(pHandle, ASPEP_PING_CFG, packetNumber);
 1795              		.loc 1 741 68
 1796 0102 FB68     		ldr	r3, [r7, #12]
 1797 0104 1B0B     		lsrs	r3, r3, #12
 741:Src/aspep.c   ****             ASPEP_sendPing(pHandle, ASPEP_PING_CFG, packetNumber);
 1798              		.loc 1 741 26
 1799 0106 7B81     		strh	r3, [r7, #10]	@ movhi
 742:Src/aspep.c   ****             pHandle->ASPEP_State = ASPEP_CONNECTED;
 1800              		.loc 1 742 13
 1801 0108 7B89     		ldrh	r3, [r7, #10]
 1802 010a 1A46     		mov	r2, r3
 1803 010c 0121     		movs	r1, #1
 1804 010e 3869     		ldr	r0, [r7, #16]
 1805 0110 FFF7FEFF 		bl	ASPEP_sendPing
 743:Src/aspep.c   ****           }
 1806              		.loc 1 743 34
 1807 0114 3B69     		ldr	r3, [r7, #16]
 1808 0116 0222     		movs	r2, #2
 1809 0118 83F86420 		strb	r2, [r3, #100]
 749:Src/aspep.c   ****         }
 1810              		.loc 1 749 11
 1811 011c 46E0     		b	.L77
 1812              	.L57:
 754:Src/aspep.c   ****           {
 1813              		.loc 1 754 32
 1814 011e 3B69     		ldr	r3, [r7, #16]
 1815 0120 9B6E     		ldr	r3, [r3, #104]
 754:Src/aspep.c   ****           {
 1816              		.loc 1 754 14
 1817 0122 052B     		cmp	r3, #5
 1818 0124 18D1     		bne	.L68
 756:Src/aspep.c   ****             {
 1819              		.loc 1 756 17
 1820 0126 3869     		ldr	r0, [r7, #16]
 1821 0128 FFF7FEFF 		bl	ASPEP_CheckBeacon
 1822 012c 0346     		mov	r3, r0
 756:Src/aspep.c   ****             {
 1823              		.loc 1 756 44
 1824 012e 83F00103 		eor	r3, r3, #1
 1825 0132 DBB2     		uxtb	r3, r3
 756:Src/aspep.c   ****             {
 1826              		.loc 1 756 16
 1827 0134 002B     		cmp	r3, #0
 1828 0136 04D0     		beq	.L69
 758:Src/aspep.c   ****             }
 1829              		.loc 1 758 36
 1830 0138 3B69     		ldr	r3, [r7, #16]
 1831 013a 0022     		movs	r2, #0
 1832 013c 83F86420 		strb	r2, [r3, #100]
 1833 0140 03E0     		b	.L70
 1834              	.L69:
 762:Src/aspep.c   ****             }
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s 			page 53


 1835              		.loc 1 762 36
 1836 0142 3B69     		ldr	r3, [r7, #16]
 1837 0144 0122     		movs	r2, #1
 1838 0146 83F86420 		strb	r2, [r3, #100]
 1839              	.L70:
 764:Src/aspep.c   ****           }
 1840              		.loc 1 764 13
 1841 014a 3B69     		ldr	r3, [r7, #16]
 1842 014c 6C33     		adds	r3, r3, #108
 1843 014e 1946     		mov	r1, r3
 1844 0150 3869     		ldr	r0, [r7, #16]
 1845 0152 FFF7FEFF 		bl	ASPEP_sendBeacon
 794:Src/aspep.c   ****         }
 1846              		.loc 1 794 11
 1847 0156 2BE0     		b	.L78
 1848              	.L68:
 766:Src/aspep.c   ****           {
 1849              		.loc 1 766 35
 1850 0158 3B69     		ldr	r3, [r7, #16]
 1851 015a 9B6E     		ldr	r3, [r3, #104]
 766:Src/aspep.c   ****           {
 1852              		.loc 1 766 19
 1853 015c 062B     		cmp	r3, #6
 1854 015e 09D1     		bne	.L72
 768:Src/aspep.c   ****             ASPEP_sendPing(pHandle, ASPEP_PING_CFG, packetNumber);
 1855              		.loc 1 768 45
 1856 0160 3B69     		ldr	r3, [r7, #16]
 1857 0162 5B7F     		ldrb	r3, [r3, #29]	@ zero_extendqisi2
 768:Src/aspep.c   ****             ASPEP_sendPing(pHandle, ASPEP_PING_CFG, packetNumber);
 1858              		.loc 1 768 26
 1859 0164 7B81     		strh	r3, [r7, #10]	@ movhi
 769:Src/aspep.c   ****           }
 1860              		.loc 1 769 13
 1861 0166 7B89     		ldrh	r3, [r7, #10]
 1862 0168 1A46     		mov	r2, r3
 1863 016a 0121     		movs	r1, #1
 1864 016c 3869     		ldr	r0, [r7, #16]
 1865 016e FFF7FEFF 		bl	ASPEP_sendPing
 794:Src/aspep.c   ****         }
 1866              		.loc 1 794 11
 1867 0172 1DE0     		b	.L78
 1868              	.L72:
 771:Src/aspep.c   ****           {
 1869              		.loc 1 771 42
 1870 0174 3B69     		ldr	r3, [r7, #16]
 1871 0176 9B6E     		ldr	r3, [r3, #104]
 771:Src/aspep.c   ****           {
 1872              		.loc 1 771 19
 1873 0178 092B     		cmp	r3, #9
 1874 017a 19D1     		bne	.L78
 777:Src/aspep.c   ****               pSupHandle->MCP_PacketAvailable = true; /* Will be consumed in ASPEP_sendPacket */
 1875              		.loc 1 777 22
 1876 017c 3B69     		ldr	r3, [r7, #16]
 1877 017e 93F86030 		ldrb	r3, [r3, #96]	@ zero_extendqisi2
 777:Src/aspep.c   ****               pSupHandle->MCP_PacketAvailable = true; /* Will be consumed in ASPEP_sendPacket */
 1878              		.loc 1 777 39
 1879 0182 0133     		adds	r3, r3, #1
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s 			page 54


 1880 0184 DAB2     		uxtb	r2, r3
 1881 0186 3B69     		ldr	r3, [r7, #16]
 1882 0188 83F86020 		strb	r2, [r3, #96]
 778:Src/aspep.c   ****               *packetLength = pHandle->rxLength;
 1883              		.loc 1 778 47
 1884 018c 7B68     		ldr	r3, [r7, #4]
 1885 018e 0122     		movs	r2, #1
 1886 0190 1A74     		strb	r2, [r3, #16]
 779:Src/aspep.c   ****               result = pHandle->rxBuffer;
 1887              		.loc 1 779 38
 1888 0192 3B69     		ldr	r3, [r7, #16]
 1889 0194 B3F85C20 		ldrh	r2, [r3, #92]
 779:Src/aspep.c   ****               result = pHandle->rxBuffer;
 1890              		.loc 1 779 29
 1891 0198 3B68     		ldr	r3, [r7]
 1892 019a 1A80     		strh	r2, [r3]	@ movhi
 780:Src/aspep.c   **** #if VALID_CRC_DATA
 1893              		.loc 1 780 22
 1894 019c 3B69     		ldr	r3, [r7, #16]
 1895 019e 9B69     		ldr	r3, [r3, #24]
 1896 01a0 7B61     		str	r3, [r7, #20]
 794:Src/aspep.c   ****         }
 1897              		.loc 1 794 11
 1898 01a2 05E0     		b	.L78
 1899              	.L75:
 1900              		.loc 1 798 11
 1901 01a4 00BF     		nop
 1902 01a6 04E0     		b	.L64
 1903              	.L76:
 720:Src/aspep.c   ****         }
 1904              		.loc 1 720 11
 1905 01a8 00BF     		nop
 1906 01aa 02E0     		b	.L64
 1907              	.L77:
 749:Src/aspep.c   ****         }
 1908              		.loc 1 749 11
 1909 01ac 00BF     		nop
 1910 01ae 00E0     		b	.L64
 1911              	.L78:
 794:Src/aspep.c   ****         }
 1912              		.loc 1 794 11
 1913 01b0 00BF     		nop
 1914              	.L64:
 799:Src/aspep.c   ****       }
 800:Src/aspep.c   ****       /* The valid received packet is now safely consumes, we are ready to receive a new packet */
 801:Src/aspep.c   ****       pHandle->fASPEP_receive(pHandle->HWIp, pHandle->rxHeader, ASPEP_HEADER_SIZE);
 1915              		.loc 1 801 14
 1916 01b2 3B69     		ldr	r3, [r7, #16]
 1917 01b4 5B6D     		ldr	r3, [r3, #84]
 1918              		.loc 1 801 7
 1919 01b6 3A69     		ldr	r2, [r7, #16]
 1920 01b8 5069     		ldr	r0, [r2, #20]
 1921              		.loc 1 801 53
 1922 01ba 3A69     		ldr	r2, [r7, #16]
 1923 01bc 02F11C01 		add	r1, r2, #28
 1924              		.loc 1 801 7
 1925 01c0 0422     		movs	r2, #4
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s 			page 55


 1926 01c2 9847     		blx	r3
 1927              	.LVL6:
 1928 01c4 15E0     		b	.L73
 1929              	.L56:
 802:Src/aspep.c   ****     }
 803:Src/aspep.c   ****     else if (pHandle->badPacketFlag > ASPEP_OK)
 1930              		.loc 1 803 21
 1931 01c6 3B69     		ldr	r3, [r7, #16]
 1932 01c8 93F86230 		ldrb	r3, [r3, #98]	@ zero_extendqisi2
 1933              		.loc 1 803 13
 1934 01cc 002B     		cmp	r3, #0
 1935 01ce 10D0     		beq	.L73
 804:Src/aspep.c   ****     {
 805:Src/aspep.c   ****       ASPEP_sendNack(pHandle, pHandle->badPacketFlag);
 1936              		.loc 1 805 7
 1937 01d0 3B69     		ldr	r3, [r7, #16]
 1938 01d2 93F86230 		ldrb	r3, [r3, #98]	@ zero_extendqisi2
 1939 01d6 1946     		mov	r1, r3
 1940 01d8 3869     		ldr	r0, [r7, #16]
 1941 01da FFF7FEFF 		bl	ASPEP_sendNack
 806:Src/aspep.c   ****       /* ASPEP_RXframeProcess can be called before reception of another packet */
 807:Src/aspep.c   ****       pHandle->badPacketFlag = ASPEP_OK;
 1942              		.loc 1 807 30
 1943 01de 3B69     		ldr	r3, [r7, #16]
 1944 01e0 0022     		movs	r2, #0
 1945 01e2 83F86220 		strb	r2, [r3, #98]
 808:Src/aspep.c   ****       /* As we received a packet with a bad header, we need to be sure that the HW IP is well Synch
 809:Src/aspep.c   ****         * DMA will be configured to receive next packet as soon as HW IP RX line is free to receive
 810:Src/aspep.c   ****         * It is important to note that we will detect only the NEXT free line transition, it means 
 811:Src/aspep.c   ****         * be lost but the end of this lost packet will generate the IDLE interrupt
 812:Src/aspep.c   ****         * the IDLE interrupt will call ASPEP_HWDMAReset (in charge of the IP_aspep driver to call i
 813:Src/aspep.c   ****         * time)*/
 814:Src/aspep.c   ****       pHandle->fASPEP_HWSync(pHandle->HWIp);
 1946              		.loc 1 814 14
 1947 01e6 3B69     		ldr	r3, [r7, #16]
 1948 01e8 1B6D     		ldr	r3, [r3, #80]
 1949              		.loc 1 814 7
 1950 01ea 3A69     		ldr	r2, [r7, #16]
 1951 01ec 5269     		ldr	r2, [r2, #20]
 1952 01ee 1046     		mov	r0, r2
 1953 01f0 9847     		blx	r3
 1954              	.LVL7:
 1955              	.L73:
 815:Src/aspep.c   ****     }
 816:Src/aspep.c   ****     else
 817:Src/aspep.c   ****     {
 818:Src/aspep.c   ****       /* Nothing to do, no response is due to the controller */
 819:Src/aspep.c   ****     }
 820:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
 821:Src/aspep.c   ****   }
 822:Src/aspep.c   **** #endif
 823:Src/aspep.c   ****   return (result);
 1956              		.loc 1 823 10
 1957 01f2 7B69     		ldr	r3, [r7, #20]
 824:Src/aspep.c   **** }
 1958              		.loc 1 824 1
 1959 01f4 1846     		mov	r0, r3
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s 			page 56


 1960 01f6 1837     		adds	r7, r7, #24
 1961              	.LCFI62:
 1962              		.cfi_def_cfa_offset 8
 1963 01f8 BD46     		mov	sp, r7
 1964              	.LCFI63:
 1965              		.cfi_def_cfa_register 13
 1966              		@ sp needed
 1967 01fa 80BD     		pop	{r7, pc}
 1968              		.cfi_endproc
 1969              	.LFE1101:
 1971              		.section	.text.ASPEP_HWDataReceivedIT,"ax",%progbits
 1972              		.align	1
 1973              		.global	ASPEP_HWDataReceivedIT
 1974              		.syntax unified
 1975              		.thumb
 1976              		.thumb_func
 1978              	ASPEP_HWDataReceivedIT:
 1979              	.LFB1102:
 825:Src/aspep.c   **** 
 826:Src/aspep.c   **** /**
 827:Src/aspep.c   ****   * @brief  Processes the received data packet.
 828:Src/aspep.c   ****   *
 829:Src/aspep.c   ****   * This function is called once DMA has transfered the configure number of byte.
 830:Src/aspep.c   ****   * Upon reception of a new packet the DMA will be re-configured only once the answer has been sent
 831:Src/aspep.c   ****   * This is mandatory to avoid a race condition in case of a new packet is received while executing
 832:Src/aspep.c   ****   * If the packet received contains an error in the header, the HW IP will be re-synchronised first
 833:Src/aspep.c   ****   *
 834:Src/aspep.c   ****   * @param  *pHandle Handler of the current instance of the ASPEP component
 835:Src/aspep.c   ****   */
 836:Src/aspep.c   **** void ASPEP_HWDataReceivedIT(ASPEP_Handle_t *pHandle)
 837:Src/aspep.c   **** {
 1980              		.loc 1 837 1
 1981              		.cfi_startproc
 1982              		@ args = 0, pretend = 0, frame = 8
 1983              		@ frame_needed = 1, uses_anonymous_args = 0
 1984 0000 90B5     		push	{r4, r7, lr}
 1985              	.LCFI64:
 1986              		.cfi_def_cfa_offset 12
 1987              		.cfi_offset 4, -12
 1988              		.cfi_offset 7, -8
 1989              		.cfi_offset 14, -4
 1990 0002 83B0     		sub	sp, sp, #12
 1991              	.LCFI65:
 1992              		.cfi_def_cfa_offset 24
 1993 0004 00AF     		add	r7, sp, #0
 1994              	.LCFI66:
 1995              		.cfi_def_cfa_register 7
 1996 0006 7860     		str	r0, [r7, #4]
 838:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
 839:Src/aspep.c   ****   if (MC_NULL == pHandle)
 840:Src/aspep.c   ****   {
 841:Src/aspep.c   ****     /* Nothing to do */
 842:Src/aspep.c   ****   }
 843:Src/aspep.c   ****   else
 844:Src/aspep.c   ****   {
 845:Src/aspep.c   **** #endif
 846:Src/aspep.c   ****     switch (pHandle->ASPEP_TL_State)
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s 			page 57


 1997              		.loc 1 846 20
 1998 0008 7B68     		ldr	r3, [r7, #4]
 1999 000a 93F86530 		ldrb	r3, [r3, #101]	@ zero_extendqisi2
 2000              		.loc 1 846 5
 2001 000e 002B     		cmp	r3, #0
 2002 0010 02D0     		beq	.L80
 2003 0012 012B     		cmp	r3, #1
 2004 0014 5FD0     		beq	.L81
 847:Src/aspep.c   ****     {
 848:Src/aspep.c   ****       case WAITING_PACKET:
 849:Src/aspep.c   ****       {
 850:Src/aspep.c   ****         if (ASPEP_CheckHeaderCRC(*(uint32_t *)pHandle->rxHeader) == true) //cstat !MISRAC2012-Rule-
 851:Src/aspep.c   ****         {
 852:Src/aspep.c   ****           pHandle->rxPacketType = (ASPEP_packetType)(((uint32_t)pHandle->rxHeader[0]) & ID_MASK);
 853:Src/aspep.c   ****           switch (pHandle->rxPacketType)
 854:Src/aspep.c   ****           {
 855:Src/aspep.c   ****             case DATA_PACKET:
 856:Src/aspep.c   ****             {
 857:Src/aspep.c   ****               //cstat !MISRAC2012-Rule-11.3
 858:Src/aspep.c   ****               pHandle->rxLength = (uint16_t)((*((uint16_t *)pHandle->rxHeader) & 0x1FFF0U) >> (uint
 859:Src/aspep.c   ****               if (0U == pHandle->rxLength) /* data packet with length 0 is a valid packet */
 860:Src/aspep.c   ****               {
 861:Src/aspep.c   ****                 pHandle->NewPacketAvailable = true;
 862:Src/aspep.c   ****                 /* The receiver is not reconfigure right now on purpose to avoid race condition whe
 863:Src/aspep.c   ****                   *  processed in ASPEP_RXframeProcess */
 864:Src/aspep.c   ****               }
 865:Src/aspep.c   ****               else if (pHandle->rxLength <= pHandle->maxRXPayload)
 866:Src/aspep.c   ****               {
 867:Src/aspep.c   ****                 pHandle->fASPEP_receive(pHandle->HWIp, pHandle->rxBuffer,  /* need to read + 2 byte
 868:Src/aspep.c   ****                                         (pHandle->rxLength + ((uint16_t)ASPEP_DATACRC_SIZE * (uint1
 869:Src/aspep.c   ****                 pHandle->ASPEP_TL_State = WAITING_PAYLOAD;
 870:Src/aspep.c   ****               }
 871:Src/aspep.c   ****               else
 872:Src/aspep.c   ****               {
 873:Src/aspep.c   ****                 pHandle->badPacketFlag = ASPEP_BAD_PACKET_SIZE;
 874:Src/aspep.c   ****               }
 875:Src/aspep.c   ****               break;
 876:Src/aspep.c   ****             }
 877:Src/aspep.c   **** 
 878:Src/aspep.c   ****             case BEACON:
 879:Src/aspep.c   ****             case PING:
 880:Src/aspep.c   ****             {
 881:Src/aspep.c   ****               pHandle->NewPacketAvailable = true;
 882:Src/aspep.c   ****               /* The receiver is not reconfigure right now on purpose to avoid race condition when 
 883:Src/aspep.c   ****                 * processed in ASPEP_RXframeProcess */
 884:Src/aspep.c   ****               break;
 885:Src/aspep.c   ****             }
 886:Src/aspep.c   **** 
 887:Src/aspep.c   ****             default:
 888:Src/aspep.c   ****             {
 889:Src/aspep.c   ****               pHandle->badPacketFlag = ASPEP_BAD_PACKET_TYPE;
 890:Src/aspep.c   ****               break;
 891:Src/aspep.c   ****             }
 892:Src/aspep.c   ****           }
 893:Src/aspep.c   ****         }
 894:Src/aspep.c   ****         else
 895:Src/aspep.c   ****         {
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s 			page 58


 896:Src/aspep.c   ****           pHandle->badPacketFlag = ASPEP_BAD_CRC_HEADER;
 897:Src/aspep.c   ****         }
 898:Src/aspep.c   ****         break;
 899:Src/aspep.c   ****       }
 900:Src/aspep.c   **** 
 901:Src/aspep.c   ****       case WAITING_PAYLOAD:
 902:Src/aspep.c   ****       {
 903:Src/aspep.c   ****         pHandle->ASPEP_TL_State = WAITING_PACKET;
 904:Src/aspep.c   ****         /* Payload received, */
 905:Src/aspep.c   ****         pHandle->NewPacketAvailable = true;
 906:Src/aspep.c   ****         /* The receiver is not reconfigure right now on purpose to avoid race condition when the pa
 907:Src/aspep.c   ****           * processed in ASPEP_RXframeProcess */
 908:Src/aspep.c   ****         break;
 909:Src/aspep.c   ****       }
 910:Src/aspep.c   **** 
 911:Src/aspep.c   ****       default:
 912:Src/aspep.c   ****         break;
 2005              		.loc 1 912 9
 2006 0016 67E0     		b	.L92
 2007              	.L80:
 850:Src/aspep.c   ****         {
 2008              		.loc 1 850 47
 2009 0018 7B68     		ldr	r3, [r7, #4]
 2010 001a 1C33     		adds	r3, r3, #28
 850:Src/aspep.c   ****         {
 2011              		.loc 1 850 13
 2012 001c 1B68     		ldr	r3, [r3]
 2013 001e 1846     		mov	r0, r3
 2014 0020 FFF7FEFF 		bl	ASPEP_CheckHeaderCRC
 2015 0024 0346     		mov	r3, r0
 850:Src/aspep.c   ****         {
 2016              		.loc 1 850 12
 2017 0026 002B     		cmp	r3, #0
 2018 0028 4FD0     		beq	.L83
 852:Src/aspep.c   ****           switch (pHandle->rxPacketType)
 2019              		.loc 1 852 82
 2020 002a 7B68     		ldr	r3, [r7, #4]
 2021 002c 1B7F     		ldrb	r3, [r3, #28]	@ zero_extendqisi2
 852:Src/aspep.c   ****           switch (pHandle->rxPacketType)
 2022              		.loc 1 852 35
 2023 002e 03F00F02 		and	r2, r3, #15
 852:Src/aspep.c   ****           switch (pHandle->rxPacketType)
 2024              		.loc 1 852 33
 2025 0032 7B68     		ldr	r3, [r7, #4]
 2026 0034 9A66     		str	r2, [r3, #104]
 853:Src/aspep.c   ****           {
 2027              		.loc 1 853 26
 2028 0036 7B68     		ldr	r3, [r7, #4]
 2029 0038 9B6E     		ldr	r3, [r3, #104]
 2030 003a 062B     		cmp	r3, #6
 2031 003c 02D8     		bhi	.L84
 2032 003e 052B     		cmp	r3, #5
 2033 0040 39D2     		bcs	.L85
 2034 0042 3DE0     		b	.L86
 2035              	.L84:
 2036 0044 092B     		cmp	r3, #9
 2037 0046 3BD1     		bne	.L86
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s 			page 59


 858:Src/aspep.c   ****               if (0U == pHandle->rxLength) /* data packet with length 0 is a valid packet */
 2038              		.loc 1 858 61
 2039 0048 7B68     		ldr	r3, [r7, #4]
 2040 004a 1C33     		adds	r3, r3, #28
 858:Src/aspep.c   ****               if (0U == pHandle->rxLength) /* data packet with length 0 is a valid packet */
 2041              		.loc 1 858 47
 2042 004c 1B88     		ldrh	r3, [r3]
 858:Src/aspep.c   ****               if (0U == pHandle->rxLength) /* data packet with length 0 is a valid packet */
 2043              		.loc 1 858 92
 2044 004e 1B09     		lsrs	r3, r3, #4
 2045 0050 9AB2     		uxth	r2, r3
 858:Src/aspep.c   ****               if (0U == pHandle->rxLength) /* data packet with length 0 is a valid packet */
 2046              		.loc 1 858 33
 2047 0052 7B68     		ldr	r3, [r7, #4]
 2048 0054 A3F85C20 		strh	r2, [r3, #92]	@ movhi
 859:Src/aspep.c   ****               {
 2049              		.loc 1 859 32
 2050 0058 7B68     		ldr	r3, [r7, #4]
 2051 005a B3F85C30 		ldrh	r3, [r3, #92]
 859:Src/aspep.c   ****               {
 2052              		.loc 1 859 18
 2053 005e 002B     		cmp	r3, #0
 2054 0060 04D1     		bne	.L87
 861:Src/aspep.c   ****                 /* The receiver is not reconfigure right now on purpose to avoid race condition whe
 2055              		.loc 1 861 45
 2056 0062 7B68     		ldr	r3, [r7, #4]
 2057 0064 0122     		movs	r2, #1
 2058 0066 83F86120 		strb	r2, [r3, #97]
 875:Src/aspep.c   ****             }
 2059              		.loc 1 875 15
 2060 006a 33E0     		b	.L91
 2061              	.L87:
 865:Src/aspep.c   ****               {
 2062              		.loc 1 865 31
 2063 006c 7B68     		ldr	r3, [r7, #4]
 2064 006e B3F85C20 		ldrh	r2, [r3, #92]
 865:Src/aspep.c   ****               {
 2065              		.loc 1 865 52
 2066 0072 7B68     		ldr	r3, [r7, #4]
 2067 0074 B3F85E30 		ldrh	r3, [r3, #94]
 865:Src/aspep.c   ****               {
 2068              		.loc 1 865 23
 2069 0078 9A42     		cmp	r2, r3
 2070 007a 17D8     		bhi	.L89
 867:Src/aspep.c   ****                                         (pHandle->rxLength + ((uint16_t)ASPEP_DATACRC_SIZE * (uint1
 2071              		.loc 1 867 24
 2072 007c 7B68     		ldr	r3, [r7, #4]
 2073 007e 5B6D     		ldr	r3, [r3, #84]
 867:Src/aspep.c   ****                                         (pHandle->rxLength + ((uint16_t)ASPEP_DATACRC_SIZE * (uint1
 2074              		.loc 1 867 17
 2075 0080 7A68     		ldr	r2, [r7, #4]
 2076 0082 5069     		ldr	r0, [r2, #20]
 867:Src/aspep.c   ****                                         (pHandle->rxLength + ((uint16_t)ASPEP_DATACRC_SIZE * (uint1
 2077              		.loc 1 867 63
 2078 0084 7A68     		ldr	r2, [r7, #4]
 2079 0086 9469     		ldr	r4, [r2, #24]
 868:Src/aspep.c   ****                 pHandle->ASPEP_TL_State = WAITING_PAYLOAD;
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s 			page 60


 2080              		.loc 1 868 49
 2081 0088 7A68     		ldr	r2, [r7, #4]
 2082 008a B2F85C10 		ldrh	r1, [r2, #92]
 868:Src/aspep.c   ****                 pHandle->ASPEP_TL_State = WAITING_PAYLOAD;
 2083              		.loc 1 868 125
 2084 008e 7A68     		ldr	r2, [r7, #4]
 2085 0090 92F86C20 		ldrb	r2, [r2, #108]	@ zero_extendqisi2
 867:Src/aspep.c   ****                                         (pHandle->rxLength + ((uint16_t)ASPEP_DATACRC_SIZE * (uint1
 2086              		.loc 1 867 17
 2087 0094 92B2     		uxth	r2, r2
 2088 0096 5200     		lsls	r2, r2, #1
 2089 0098 92B2     		uxth	r2, r2
 2090 009a 0A44     		add	r2, r2, r1
 2091 009c 92B2     		uxth	r2, r2
 2092 009e 2146     		mov	r1, r4
 2093 00a0 9847     		blx	r3
 2094              	.LVL8:
 869:Src/aspep.c   ****               }
 2095              		.loc 1 869 41
 2096 00a2 7B68     		ldr	r3, [r7, #4]
 2097 00a4 0122     		movs	r2, #1
 2098 00a6 83F86520 		strb	r2, [r3, #101]
 875:Src/aspep.c   ****             }
 2099              		.loc 1 875 15
 2100 00aa 13E0     		b	.L91
 2101              	.L89:
 873:Src/aspep.c   ****               }
 2102              		.loc 1 873 40
 2103 00ac 7B68     		ldr	r3, [r7, #4]
 2104 00ae 0222     		movs	r2, #2
 2105 00b0 83F86220 		strb	r2, [r3, #98]
 875:Src/aspep.c   ****             }
 2106              		.loc 1 875 15
 2107 00b4 0EE0     		b	.L91
 2108              	.L85:
 881:Src/aspep.c   ****               /* The receiver is not reconfigure right now on purpose to avoid race condition when 
 2109              		.loc 1 881 43
 2110 00b6 7B68     		ldr	r3, [r7, #4]
 2111 00b8 0122     		movs	r2, #1
 2112 00ba 83F86120 		strb	r2, [r3, #97]
 884:Src/aspep.c   ****             }
 2113              		.loc 1 884 15
 2114 00be 09E0     		b	.L91
 2115              	.L86:
 889:Src/aspep.c   ****               break;
 2116              		.loc 1 889 38
 2117 00c0 7B68     		ldr	r3, [r7, #4]
 2118 00c2 0122     		movs	r2, #1
 2119 00c4 83F86220 		strb	r2, [r3, #98]
 890:Src/aspep.c   ****             }
 2120              		.loc 1 890 15
 2121 00c8 04E0     		b	.L91
 2122              	.L83:
 896:Src/aspep.c   ****         }
 2123              		.loc 1 896 34
 2124 00ca 7B68     		ldr	r3, [r7, #4]
 2125 00cc 0422     		movs	r2, #4
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s 			page 61


 2126 00ce 83F86220 		strb	r2, [r3, #98]
 898:Src/aspep.c   ****       }
 2127              		.loc 1 898 9
 2128 00d2 09E0     		b	.L92
 2129              	.L91:
 2130 00d4 08E0     		b	.L92
 2131              	.L81:
 903:Src/aspep.c   ****         /* Payload received, */
 2132              		.loc 1 903 33
 2133 00d6 7B68     		ldr	r3, [r7, #4]
 2134 00d8 0022     		movs	r2, #0
 2135 00da 83F86520 		strb	r2, [r3, #101]
 905:Src/aspep.c   ****         /* The receiver is not reconfigure right now on purpose to avoid race condition when the pa
 2136              		.loc 1 905 37
 2137 00de 7B68     		ldr	r3, [r7, #4]
 2138 00e0 0122     		movs	r2, #1
 2139 00e2 83F86120 		strb	r2, [r3, #97]
 908:Src/aspep.c   ****       }
 2140              		.loc 1 908 9
 2141 00e6 00BF     		nop
 2142              	.L92:
 913:Src/aspep.c   ****     }
 914:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
 915:Src/aspep.c   ****   }
 916:Src/aspep.c   **** #endif
 917:Src/aspep.c   **** }
 2143              		.loc 1 917 1
 2144 00e8 00BF     		nop
 2145 00ea 0C37     		adds	r7, r7, #12
 2146              	.LCFI67:
 2147              		.cfi_def_cfa_offset 12
 2148 00ec BD46     		mov	sp, r7
 2149              	.LCFI68:
 2150              		.cfi_def_cfa_register 13
 2151              		@ sp needed
 2152 00ee 90BD     		pop	{r4, r7, pc}
 2153              		.cfi_endproc
 2154              	.LFE1102:
 2156              		.section	.text.ASPEP_HWDMAReset,"ax",%progbits
 2157              		.align	1
 2158              		.global	ASPEP_HWDMAReset
 2159              		.syntax unified
 2160              		.thumb
 2161              		.thumb_func
 2163              	ASPEP_HWDMAReset:
 2164              	.LFB1103:
 918:Src/aspep.c   **** 
 919:Src/aspep.c   **** /**
 920:Src/aspep.c   ****   * @brief  Resets DMA after debugger has stopped the MCU.
 921:Src/aspep.c   ****   *
 922:Src/aspep.c   ****   * @param  *pHandle Handler of the current instance of the ASPEP component
 923:Src/aspep.c   ****   */
 924:Src/aspep.c   **** void ASPEP_HWDMAReset(ASPEP_Handle_t *pHandle)
 925:Src/aspep.c   **** {
 2165              		.loc 1 925 1
 2166              		.cfi_startproc
 2167              		@ args = 0, pretend = 0, frame = 8
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s 			page 62


 2168              		@ frame_needed = 1, uses_anonymous_args = 0
 2169 0000 80B5     		push	{r7, lr}
 2170              	.LCFI69:
 2171              		.cfi_def_cfa_offset 8
 2172              		.cfi_offset 7, -8
 2173              		.cfi_offset 14, -4
 2174 0002 82B0     		sub	sp, sp, #8
 2175              	.LCFI70:
 2176              		.cfi_def_cfa_offset 16
 2177 0004 00AF     		add	r7, sp, #0
 2178              	.LCFI71:
 2179              		.cfi_def_cfa_register 7
 2180 0006 7860     		str	r0, [r7, #4]
 926:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
 927:Src/aspep.c   ****   if (NULL == pHandle)
 928:Src/aspep.c   ****   {
 929:Src/aspep.c   ****     /* Nothing to do */
 930:Src/aspep.c   ****   }
 931:Src/aspep.c   ****   else
 932:Src/aspep.c   ****   {
 933:Src/aspep.c   **** #endif
 934:Src/aspep.c   ****     /* We must reset the RX state machine to be sure to not be in Waiting packet state */
 935:Src/aspep.c   ****     /* Otherwise the arrival of a new packet will trigger a NewPacketAvailable despite */
 936:Src/aspep.c   ****     /* the fact that bytes have been lost because of overrun (debugger paused for instance) */
 937:Src/aspep.c   ****     pHandle->ASPEP_TL_State = WAITING_PACKET;
 2181              		.loc 1 937 29
 2182 0008 7B68     		ldr	r3, [r7, #4]
 2183 000a 0022     		movs	r2, #0
 2184 000c 83F86520 		strb	r2, [r3, #101]
 938:Src/aspep.c   ****     pHandle->fASPEP_receive(pHandle->HWIp, pHandle->rxHeader, ASPEP_HEADER_SIZE);
 2185              		.loc 1 938 12
 2186 0010 7B68     		ldr	r3, [r7, #4]
 2187 0012 5B6D     		ldr	r3, [r3, #84]
 2188              		.loc 1 938 5
 2189 0014 7A68     		ldr	r2, [r7, #4]
 2190 0016 5069     		ldr	r0, [r2, #20]
 2191              		.loc 1 938 51
 2192 0018 7A68     		ldr	r2, [r7, #4]
 2193 001a 02F11C01 		add	r1, r2, #28
 2194              		.loc 1 938 5
 2195 001e 0422     		movs	r2, #4
 2196 0020 9847     		blx	r3
 2197              	.LVL9:
 939:Src/aspep.c   **** #ifdef NULL_PTR_CHECK_ASP
 940:Src/aspep.c   ****   }
 941:Src/aspep.c   **** #endif
 942:Src/aspep.c   **** }
 2198              		.loc 1 942 1
 2199 0022 00BF     		nop
 2200 0024 0837     		adds	r7, r7, #8
 2201              	.LCFI72:
 2202              		.cfi_def_cfa_offset 8
 2203 0026 BD46     		mov	sp, r7
 2204              	.LCFI73:
 2205              		.cfi_def_cfa_register 13
 2206              		@ sp needed
 2207 0028 80BD     		pop	{r7, pc}
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s 			page 63


 2208              		.cfi_endproc
 2209              	.LFE1103:
 2211              		.text
 2212              	.Letext0:
 2213              		.file 3 "c:\\programdata\\chocolatey\\lib\\gcc-arm-embedded\\tools\\gcc-arm-none-eabi-10.3-2021.10
 2214              		.file 4 "c:\\programdata\\chocolatey\\lib\\gcc-arm-embedded\\tools\\gcc-arm-none-eabi-10.3-2021.10
 2215              		.file 5 "Drivers/STM32L4xx_HAL_Driver/Inc/stm32l4xx_ll_tim.h"
 2216              		.file 6 "Drivers/STM32L4xx_HAL_Driver/Inc/stm32l4xx_ll_dma.h"
 2217              		.file 7 "MCSDK_v6.2.1-Full/MotorControl/MCSDK/MCLib/Any/Inc/mcptl.h"
 2218              		.file 8 "Inc/aspep.h"
ARM GAS  C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s 			page 64


DEFINED SYMBOLS
                            *ABS*:00000000 aspep.c
C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s:20     .rodata.OFFSET_TAB_CCMRx:00000000 $d
C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s:23     .rodata.OFFSET_TAB_CCMRx:00000000 OFFSET_TAB_CCMRx
C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s:26     .rodata.SHIFT_TAB_OCxx:00000000 $d
C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s:29     .rodata.SHIFT_TAB_OCxx:00000000 SHIFT_TAB_OCxx
C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s:32     .rodata.SHIFT_TAB_ICxx:00000000 $d
C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s:35     .rodata.SHIFT_TAB_ICxx:00000000 SHIFT_TAB_ICxx
C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s:38     .rodata.SHIFT_TAB_CCxP:00000000 $d
C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s:41     .rodata.SHIFT_TAB_CCxP:00000000 SHIFT_TAB_CCxP
C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s:44     .rodata.SHIFT_TAB_OISx:00000000 $d
C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s:47     .rodata.SHIFT_TAB_OISx:00000000 SHIFT_TAB_OISx
C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s:50     .rodata.CHANNEL_OFFSET_TAB:00000000 $d
C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s:53     .rodata.CHANNEL_OFFSET_TAB:00000000 CHANNEL_OFFSET_TAB
C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s:56     .rodata.CRC4_Lookup8:00000000 $d
C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s:59     .rodata.CRC4_Lookup8:00000000 CRC4_Lookup8
C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s:81     .rodata.CRC4_Lookup4:00000000 $d
C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s:84     .rodata.CRC4_Lookup4:00000000 CRC4_Lookup4
C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s:88     .text.ASPEP_ComputeHeaderCRC:00000000 $t
C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s:93     .text.ASPEP_ComputeHeaderCRC:00000000 ASPEP_ComputeHeaderCRC
C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s:205    .text.ASPEP_ComputeHeaderCRC:00000084 $d
C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s:211    .text.ASPEP_CheckHeaderCRC:00000000 $t
C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s:216    .text.ASPEP_CheckHeaderCRC:00000000 ASPEP_CheckHeaderCRC
C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s:315    .text.ASPEP_CheckHeaderCRC:00000074 $d
C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s:320    .text.ASPEP_start:00000000 $t
C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s:326    .text.ASPEP_start:00000000 ASPEP_start
C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s:392    .text.ASPEP_sendBeacon:00000000 $t
C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s:398    .text.ASPEP_sendBeacon:00000000 ASPEP_sendBeacon
C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s:1138   .text.ASPEP_TXframeProcess:00000000 ASPEP_TXframeProcess
C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s:480    .text.ASPEP_sendNack:00000000 $t
C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s:485    .text.ASPEP_sendNack:00000000 ASPEP_sendNack
C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s:545    .text.ASPEP_sendPing:00000000 $t
C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s:551    .text.ASPEP_sendPing:00000000 ASPEP_sendPing
C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s:649    .text.ASPEP_getBuffer:00000000 $t
C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s:655    .text.ASPEP_getBuffer:00000000 ASPEP_getBuffer
C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s:799    .text.ASPEP_CheckBeacon:00000000 $t
C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s:804    .text.ASPEP_CheckBeacon:00000000 ASPEP_CheckBeacon
C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s:982    .text.ASPEP_sendPacket:00000000 $t
C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s:988    .text.ASPEP_sendPacket:00000000 ASPEP_sendPacket
C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s:1133   .text.ASPEP_TXframeProcess:00000000 $t
C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s:1376   .text.ASPEP_HWDataTransmittedIT:00000000 $t
C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s:1382   .text.ASPEP_HWDataTransmittedIT:00000000 ASPEP_HWDataTransmittedIT
C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s:1615   .text.ASPEP_RXframeProcess:00000000 $t
C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s:1621   .text.ASPEP_RXframeProcess:00000000 ASPEP_RXframeProcess
C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s:1972   .text.ASPEP_HWDataReceivedIT:00000000 $t
C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s:1978   .text.ASPEP_HWDataReceivedIT:00000000 ASPEP_HWDataReceivedIT
C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s:2157   .text.ASPEP_HWDMAReset:00000000 $t
C:\Users\ep_ygh\AppData\Local\Temp\cc0TtqlT.s:2163   .text.ASPEP_HWDMAReset:00000000 ASPEP_HWDMAReset

NO UNDEFINED SYMBOLS
